package Libraries.Language.Compile.Symbol

use Libraries.Language.Compile.QualifiedName
use Libraries.Language.Compile.CompilerError
use Libraries.Language.Compile.CompilerErrorManager
use Libraries.Language.Compile.CompilerErrorType
use Libraries.Containers.HashTable
use Libraries.Language.Compile.Location
use Libraries.Containers.Iterator
use Libraries.Containers.Array
use Libraries.System.File
use Libraries.Language.Compile.Translate.QuorumOpcode
use Libraries.Language.Support.CompareResult
use Libraries.Language.Compile.Hints.UseHint
use Libraries.Language.Compile.Hints.Hint
use Libraries.Containers.List
use Libraries.Language.Compile.Translate.ActionCallOpcode
use Libraries.Language.Compile.Library
use Libraries.Language.Compile.Hints.GetterGenerationHint
use Libraries.Language.Compile.Hints.SetterGenerationHint

class Class is Symbol
    QualifiedName packageName
    HashTable<text, Action> actions
    HashTable<text, Action> virtualActions
    HashTable<text, Action> parentActions
    HashTable<text, Array<Type>> parentGenerics
    HashTable<text, HashTable<integer, integer>> parentGenericMap = undefined
    HashTable<text, Variable> fields
    HashTable<text, Class> dependencies
    Action constructor = undefined
    boolean hasMain = false
    HashTable<text, QualifiedName> unresolvedUseStatements
    Array<QualifiedName> unresolvedParents
    HashTable<text, Class> validUses
    HashTable<text, Class> validUsesFullyQualified
    HashTable<text, Class> parents
    Array<Class> parentCreationOrder = undefined
    Array<Class> directParents
    Array<text> generics
    HashTable<text, integer> genericHash
    boolean areParentsResolved = false
    boolean isResolvingParents = false
    boolean isTypeResolved = false
    File file = undefined
    boolean hasSystemAction = false
    constant text LIBRARIES_LANGUAGE_OBJECT = "Libraries.Language.Object"
    constant text LIBRARIES_LANGUAGE_ERRORS_ERROR = "Libraries.Language.Errors.Error"
    boolean isMainClass = false
    Array<Array<Class>> resolvedParentLevels
    boolean hasBlueprints = false
    Location nameLocation = undefined
    HashTable<text, List<Location>> useLocationHash
    text staticKey = ""
    text staticKeyUnderscores = ""
    text staticKeySlashes = ""
    boolean staticClass = false

    on create
        QualifiedName object
        object:Add("Libraries")
        object:Add("Language")
        object:Add("Object")

        AddUnresolvedUseStatement(object)

        QualifiedName textObject
        textObject:Add("Libraries")
        textObject:Add("Language")
        textObject:Add("Types")
        textObject:Add("Text")

        AddUnresolvedUseStatement(textObject)

        QualifiedName booleanObject
        booleanObject:Add("Libraries")
        booleanObject:Add("Language")
        booleanObject:Add("Types")
        booleanObject:Add("Boolean")

        AddUnresolvedUseStatement(booleanObject)

        QualifiedName integerObject
        integerObject:Add("Libraries")
        integerObject:Add("Language")
        integerObject:Add("Types")
        integerObject:Add("Integer")

        AddUnresolvedUseStatement(integerObject)

        QualifiedName numberObject
        numberObject:Add("Libraries")
        numberObject:Add("Language")
        numberObject:Add("Types")
        numberObject:Add("Number")

        AddUnresolvedUseStatement(numberObject)

        QualifiedName errorObject
        errorObject:Add("Libraries")
        errorObject:Add("Language")
        errorObject:Add("Errors")
        errorObject:Add("Error")

        AddUnresolvedUseStatement(errorObject)
    end

    action IsStatic returns boolean
        return staticClass
    end

    action SetStatic(boolean value)
        staticClass = value
    end

    action AddUseLocation(Location location) 
        File file = location:GetFile()
        if file = undefined
           return now //ignore if this isn't supported
        end
        text path = file:GetAbsolutePath()
        List<Location> list = undefined
        if useLocationHash:HasKey(path)
            list = useLocationHash:GetValue(path)
        end

        if list = undefined
            List<Location> list2
            list = list2
            useLocationHash:Add(path, list)
        end

        list:Add(location)
    end

    action GetUseLocationIterator(File file) returns Iterator<Location>
        text path = file:GetAbsolutePath()
        if useLocationHash:HasKey(path)
            List<Location> loc = useLocationHash:GetValue(path)
            return loc:GetIterator()
        end

        return undefined
    end

    action GetNameLocation returns Location
        return nameLocation
    end

    action SetNameLocation(Location location)
        nameLocation = location
    end

    action HasBlueprints returns boolean
        return hasBlueprints
    end

    action HasParentGenerics(text key) returns boolean
        return parentGenerics:HasKey(key)
    end

    action GetParentGenerics(text key) returns Array<Type>
        return parentGenerics:GetValue(key)
    end

    action SetParentGenerics(text key, Array<Type> types)
        parentGenerics:Set(key, types)
    end
        
    action IsProgramStartingClass returns boolean
        return isMainClass
    end

    action SetIsProgramStartingClass(boolean main)
        isMainClass = main
    end

    action AddGeneric(text name)
        generics:Add(name)
        genericHash:Add(name, generics:GetSize() - 1)
    end

    action GetNumberGenerics returns integer
        return generics:GetSize()
    end

    action GetGeneric(integer location) returns text
        return generics:Get(location)
    end

    /*
        This action determines whether a generic of a particular name 
        exists in this class.
    */
    action HasGeneric(text name) returns boolean
        return genericHash:HasKey(name)
    end

    /*
        This action digs through the generics and, if it finds one
        by this name, returns its index. If no generic by this name
        is found, then this returns -1.
    */
    action GetIndexOfGeneric(text name) returns integer
        if HasGeneric(name)
            return genericHash:GetValue(name)
        else
            return -1
        end
    end

    action ConvertStaticKeyToParentActionName returns text
        key = GetStaticKey()
        result = "parent" + key:Replace(".", "_") + "_"
        return result
    end

    /*
        This action looks at all actions listed in this class's declared
        action table, in addition to those actions declared in parents,
        and fills up a new virtual action table with all actions combined.
        If this action has an error, it is created and sent to the 
        compiler error manager passed in.
    */
    action ComputeVirtualActionTable (CompilerErrorManager errors)
        Iterator<Action> declaredActions = GetActions()
        repeat while declaredActions:HasNext()
            Action act = declaredActions:Next()
            virtualActions:Add(act:GetStaticKey(), act)
        end

        HashTable<text, Class> computed
        //now dig through all parents and add any virtual methods that are
        //necessary
        Iterator<Class> parentIterator = GetParentClasses()
        repeat while parentIterator:HasNext()
            Class mom = parentIterator:Next()
            computed:Add(mom:GetStaticKey(), mom)
            Iterator<Action> momActions = mom:GetActions()
            repeat while momActions:HasNext()
                Action act = momActions:Next()
                WeaveActionFromDirectParent(mom, act, errors)                
            end
        end

        //now go through all of the actions in the v-table 
        //and see if any if the actions are blueprints. If they are,
        //mark this class so it cannot be instantiated.
        Iterator<Action> it = GetVirtualTable()
        repeat while it:HasNext()
            Action a = it:Next()
            if a:IsBlueprint()
                hasBlueprints = true
                return now
            end
        end
    end
    
    action WeaveActionFromDirectParent(Class mom, Action act, CompilerErrorManager errors)
        text key = act:GetStaticKey()
        Type returnType = act:GetReturnType()
        text returnKey = returnType:GetStaticKey()

        Action actionCopy = virtualActions:GetValue(key)
        if actionCopy = undefined //it doesn't exist, so add it.
           virtualActions:Add(key, act) 
           parentActions:Add(key, act) 
        else
            //check to see if the action is overriden
            Action baseAction = actions:GetValue(key)

            //if it exists, just make sure it has the same return type
            if baseAction not= undefined
                Class dad = baseAction:GetParentClass()
                Type baseReturnType = baseAction:GetReturnType()
                text baseReturnKey = baseReturnType:GetStaticKey()

                //also make sure the base class didn't override with a blueprint
                //as that wouldn't make any sense.
                if not act:IsBlueprint() and baseAction:IsBlueprint()
                    CompilerError error
                    CompilerErrorType t
                    t:SetCurrentType(t:INHERITANCE_AMBIGUOUS)
                    error:SetCompilerErrorType(t)
                    error:SetErrorMessage("The action " + key + " is defined in the parent "
                        + mom:GetStaticKey() + ", but is overriden in the base class " 
                        + dad:GetStaticKey() + " as a blueprint. I do not understand what that would mean.")
                    error:SetLocation(mom)
                    errors:Add(error)
                end

                //if the returnType of the parent (returnType) has a generic, map it
                //to the specific isntance located in the class template declaration
                //if it isn't an Object or isn't a generic, don't map generic types
                if returnType:IsMappedToGeneric() and returnType:GetStaticKey() = returnType:OBJECT_KEY
                    text genericName = returnType:GetMappedGeneric()

                    if mom:HasGeneric(genericName)
                        //get the index of the generic from the parent
                        integer index = mom:GetIndexOfGeneric(genericName)

                        //this tells us the index of the template
                        //now grab the nth element from the declared type list
                        //if it exists. If it doesn't, ignore this
                        Array<Type> values = GetParentGenerics(mom:GetStaticKey())
                        if values not= undefined //sizing is already checked
                            Type actualType = values:Get(index)
                            //if it's not a generic, set the return type value
                            //to the declared value and see if it matches
                            if actualType:GetStaticKey() not= actualType:OBJECT_KEY
                                returnType = actualType
                                returnKey = returnType:GetStaticKey()
                            end
                        end
                    end
                end

                if returnKey not= baseReturnKey //this is an error
                    CompilerError error
                    CompilerErrorType t
                    t:SetCurrentType(t:INHERITANCE_MISSMATCHED_RETURN)
                    error:SetCompilerErrorType(t)
                    error:SetErrorMessage("The action " + key + " is defined in the parent "
                        + dad:GetStaticKey() + ", but the return types (" 
                        + baseReturnKey + " and "+ returnKey + ") do not match.")
                    error:SetLocation(mom)
                    errors:Add(error)
                end //otherwise, everything is fine, so ignore it
            else //the base action is undefined, this could be an error
                 //or it could be the case that the method is from a subclass,
                 //and as such, this is just fine. Or, it could be the case
                 //that the method is in a super class, and as such, needs to be
                 //overriden
                 Class dad = actionCopy:GetParentClass()
                 if dad:HasParentClass(mom:GetStaticKey()) //ignore this, everything is fine
                    a = 5
                 elseif mom:HasParentClass(dad:GetStaticKey())
                    virtualActions:Set(key, act) 
                    parentActions:Set(key, act) 
                 else
                    if act:IsBlueprint() or actionCopy:IsBlueprint()
                       //check to see if the one in the v-table is a blueprint
                       //check to make sure both of them aren't blueprints
                       if not (act:IsBlueprint() and actionCopy:IsBlueprint())
                           //at least one is not a blueprint, so make sure
                           //that is the one in the v-table
                           if actionCopy:IsBlueprint()
                               virtualActions:Set(act:GetStaticKey(), act)
                           end
                       end

                    else

                       CompilerError error
                       error:SetErrorMessage("The action " + key + " is defined"
                          +   " in parents " + mom:GetStaticKey() + " and " 
                          + dad:GetStaticKey() + ". Since I cannot determine which action should"
                          + " be called, the action must be overriden in the"
                          + " base class " + me:GetStaticKey() + ".")
                       error:SetLocation(me)
                       CompilerErrorType errorType
                       errorType:SetCurrentType(errorType:INHERITANCE_AMBIGUOUS)
                       error:SetCompilerErrorType(errorType)
                       errors:Add(error)
                    end
                 end
            end
        end
    end

    action GetVirtualTable returns Iterator<Action>
        return virtualActions:GetValueIterator()
    end

    action GetParentActions returns Iterator<Action> 
        return parentActions:GetValueIterator()
    end

    /*
        This action returns a list of of all generic names. For example, if
        the class is declared as A<Type, Value>, then this action will return
        "Type, Value" without double quotes.
    */ 
    action GetGenericList returns text
        text value = ""
        
        i = 0
        repeat GetNumberGenerics() times
            if i = 0
                value = value + GetGeneric(i)
            else 
                value = value + ", " + GetGeneric(i)
            end
            i = i + 1
        end
        return value
    end

    action Add(Action method) returns CompilerError
        if not IsDefined(method)
            actions:Add(method:GetStaticKey(), method)
            if method:IsMain()
                hasMain = true
            end

            if method:IsSystem()
                hasSystemAction = true
            end
            return undefined
        end

        CompilerError error
        error:SetLineNumber(method:GetLineNumber())
        error:SetFile(method:GetFile())
        error:SetLineNumberEnd(method:GetLineNumber())
        error:SetColumnNumber(method:GetColumnNumber())
        error:SetColumnNumber(method:GetColumnNumber())
        error:SetErrorMessage("Action " + method:GetDisplayName() + " is already defined. That is not possible, because I would not know which definition to use.")
        CompilerErrorType errorType
        errorType:SetCurrentType(errorType:DUPLICATE)
        error:SetCompilerErrorType(errorType)
        return error
    end

    action HasSystemAction returns boolean
        return hasSystemAction
    end

    /*
        This action returns whether or not this particular class
        represents Libraries.Language.Object.
    */
    action IsObject returns boolean
        if GetStaticKey() = LIBRARIES_LANGUAGE_OBJECT
            return true
        else
            return false
        end
    end


    /*
        This action returns true if this class is either Libraries.Language.Errors.Error
        or is a subclass.
    */
    action IsError returns boolean
        if GetStaticKey() = LIBRARIES_LANGUAGE_ERRORS_ERROR
            return true
        elseif HasParentClass(LIBRARIES_LANGUAGE_ERRORS_ERROR)
            return true
        else
            return false
        end
    end

    action GenerateSetterNameFromField(Variable variable) returns text
        text result = "Set_"
        result = result + ConvertStaticKeyToFieldPath() + variable:GetName() + "_"
        return result
    end

    action ConvertToActionNameFromField(Variable variable, boolean isGetter) returns text
        if isGetter
            return "Get_" + staticKeyUnderscores + "__" + variable:GetName() + "_"
        else
            return "Set_" + staticKeyUnderscores + "__" + variable:GetName() + "_"
        end
    end

    action SetName(text name)
        parent:Symbol:name = name
        CalculateStaticKey()
    end

    private action CalculateStaticKey
        text pack = packageName:GetStaticKey()
        if pack:IsEmpty()
            staticKey =  me:GetName()
        else 
            staticKey = pack + "." + me:GetName()
        end

        staticKeyUnderscores = staticKey:Replace(".", "_")
        staticKeySlashes = staticKey:Replace(".", "/")
    end

    action AddUnresolvedParent(QualifiedName name)
        unresolvedParents:Add(name)
    end

    action AddParentClass(Class clazz) //check for compiler error or just ignore?
        parents:Add(clazz:GetStaticKey(), clazz)
    end
    
    /*
        This action checks to see if all types have been resolved for this class.
    */
    action IsResolved returns boolean
        return isTypeResolved
    end

    action ResolveUseStatements(SymbolTable table, CompilerErrorManager errors)
        //first resolve all use statements
        Iterator<QualifiedName> unresolvedUse = GetUnresolvedUseStatements()
        repeat while unresolvedUse:HasNext()
            QualifiedName name = unresolvedUse:Next()
            text key = name:GetStaticKey()

            
            //if this is an all statement, then grab anything in the container
            if name:IsAll()
                noAllKey = name:GetStaticKeyNoAll()
                Iterator<Class> classes = table:GetClassesInPackage(noAllKey)
                if classes not= undefined
                    repeat while classes:HasNext()
                        Class clazz = classes:Next()
                        AddValidUse(clazz)
                    end
                else
                    CompilerError error
                    error:SetLocation(name)
                    CompilerErrorType type
                    type:SetCurrentType(type:MISSING_USE)
                    error:SetCompilerErrorType(type)
                    error:SetErrorMessage("I could not locate the package named "
                        +  noAllKey + ". Are you sure you spelled it correctly?" )
                    errors:Add(error)
                end
            else 
                Class clazz = GetClass(name:GetStaticKey(), table, errors)
                if clazz not= undefined
                    AddValidUse(clazz)
                else
                    CompilerError error
                    error:SetLocation(name)
                    CompilerErrorType type
                    type:SetCurrentType(type:MISSING_USE)
                    error:SetCompilerErrorType(type)
                    error:SetErrorMessage("I could not locate the package named "
                        +   name:GetStaticKey() + ". Are you sure you spelled it correctly?" )
                    errors:Add(error)
                end
            end
        end
    end

    action ResolveAllTypes(SymbolTable table, CompilerErrorManager errors)
        //next resolve all parents
        ResolveParents(table, errors)
        ResolveParentLevels(table)

        //now all parents are resolved. Resolve the generics of those parents
        //first rehash all of the parent uses
        ResolveParentGenerics(table, errors)
        
        //now resolve all the fields
        ResolveFields(table, errors)

        //next resolve all actions and their blocks
        ResolveActions(table, errors)

        MapParentGenerics()
        isTypeResolved = true
    end

    action HasGenerics returns boolean
        return GetNumberGenerics() not= 0
    end

    private action MapParentGenerics
        HashTable<text, HashTable<integer, integer>> map
        text key = GetStaticKey()

        Iterator<text> parents = parentGenerics:GetKeyIterator()
        repeat while parents:HasNext()
            text next = parents:Next()
            HashTable<integer, integer> parentMap
            Array<Type> gens = GetParentGenerics(next)
            i = 0
            repeat while i < gens:GetSize()
                Type type = gens:Get(i)
                if type:IsMappedToGeneric()
                    text gen = type:GetMappedGeneric()
                    if HasGeneric(gen)
                        text mappedValue = undefined
                        integer mappedIndex = -1
                        j = 0
                        repeat while j < generics:GetSize()
                            text myGeneric = generics:Get(j)
                            if myGeneric = gen
                                mappedValue = gen
                                mappedIndex = j
                            end
                            j = j + 1
                        end

                        if not (mappedValue = undefined)
                            parentMap:Add(i, mappedIndex)
                        end
                    else

                    end
                    
                end
                if not parentMap:IsEmpty()
                    map:Add(next, parentMap)
                end
                i = i + 1
            end
        end
        parentGenericMap = map
    end

    action HasGenericMapToParent(text key) returns boolean
        if parentGenericMap:HasKey(key)
            return true
        end

        return false
    end

    action ComputeGenericsTables(CompilerErrorManager compilerErrorManager)
        Iterator<text> it = parentGenericMap:GetKeyIterator()
        HashTable<text, HashTable<integer, integer>> tempParentMap
        HashTable<integer, HashTable<text, integer>> circularMap
        
        HashTable<text, HashTable<integer, integer>> finalParentMap
        repeat while it:HasNext()
            text next = it:Next()
            tempParentMap:Add(next, parentGenericMap:GetValue(next))
            finalParentMap:Add(next, parentGenericMap:GetValue(next))
        end

        it = tempParentMap:GetKeyIterator()
        text key = GetStaticKey()
        b = 5

        repeat while it:HasNext()
            HashTable<text, HashTable<integer, integer>> newTempParentMap
            repeat while it:HasNext()
                text next = it:Next()
                Class par = GetParentClass(next)
                HashTable<text, HashTable<integer, integer>> parentMap = par:GetParentGenericMap()
                if not parentMap:IsEmpty()
                    Iterator<text> parentIt = parentMap:GetKeyIterator()
                    HashTable<integer, integer> directParentMap = tempParentMap:GetValue(next)

                    repeat while parentIt:HasNext()
                        text nextParent = parentIt:Next()
                        //do we already have a map from this class to this parent?

                        HashTable<integer, integer> values = parentMap:GetValue(nextParent)
                        HashTable<integer, integer> myValues = parentGenericMap:GetValue(nextParent)
                        //if so, check it for consistency
                        if values not= undefined
                            if myValues = undefined //we don't have a map to this parent
                                HashTable<integer, integer> newMap
                                Iterator<integer> myClassValues = directParentMap:GetValueIterator()
                                repeat while myClassValues:HasNext()
                                    integer val = myClassValues:Next()
                                    if values:HasKey(val)
                                        newMap:Add(val, values:GetValue(val))
                                    end
                                end
                                if not newMap:IsEmpty()
                                    if not parentGenericMap:HasKey(nextParent)
                                        newTempParentMap:Add(nextParent, newMap)
                                        parentGenericMap:Add(nextParent, newMap)
                                    end
                                end
                            else
                                boolean test = CheckHashTableConsistency(
                                    compilerErrorManager, directParentMap, 
                                    myValues, next, nextParent)
                                
                                //I don't think anything needs to be done with this value
                                //if it fails, as an error will be issued.
                            end
                        end
                    end
                end
            end

            tempParentMap = newTempParentMap
            it = tempParentMap:GetKeyIterator()
        end
    end

    private action GetPositionName(integer pos) returns text
        text message = "the "
        if pos = 0
            return message + "first"
        elseif pos = 1
            return message + "second"
        elseif pos = 2
            return message + "third"
        elseif pos = 3
            return message + "fourth"
        elseif pos = 4
            return message + "fifth"
        elseif pos = 5
            return message + "sixth"
        elseif pos = 6
            return message + "seventh"
        elseif pos = 7
            return message + "eighth"
        elseif pos = 8
            return message + "ninth"
        elseif pos = 9
            return message + "tenth"
        end

        return " position " + (pos + 1) 
    end

    private action CheckHashTableConsistency(CompilerErrorManager compilerErrorManager, 
        HashTable<integer, integer> left, HashTable<integer, integer> right, text next, text nextParent) returns boolean
        lsize = left:GetSize()
        rsize = right:GetSize()

        //if these do not match, it's an error
        if lsize not= rsize
            CompilerError error
            error:SetLocation(me)
            CompilerErrorType t
            t:SetCurrentType(t:MISMATCHED_TEMPLATES)
            error:SetCompilerErrorType(t)
            text message = "The class " + GetStaticKey() + " defines generics "
            message = message + "that lead to its parent class " + nextParent + 
                " having two different definitions."
            error:SetErrorMessage(message)
            compilerErrorManager:Add(error)
            return false
        end

        Iterator<integer> lit = left:GetKeyIterator()
        repeat while lit:HasNext()
            lkey = lit:Next()

            lval = left:GetValue(lkey)

            if right:HasKey(lkey)
                rval = right:GetValue(lkey)
                if lval not= rval
                    CompilerError error
                    error:SetLocation(me)
                    CompilerErrorType t
                    t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                    error:SetCompilerErrorType(t)
                    text message = "The class " + GetStaticKey() + " defines generics "
                    message = message + "that lead to its parent class " + nextParent + 
                        " having two contradictory values, " + GetPositionName(lval) + " (" + GetGeneric(lval) + "), and " + 
                        GetPositionName(rval) + " (" + GetGeneric(rval) + "). In this case, this is caused by "
                        + "the definition of the parent " + next + "."
                    error:SetErrorMessage(message)
                    compilerErrorManager:Add(error)
                    return false
                end
            else
                CompilerError error
                error:SetLocation(me)
                CompilerErrorType t
                t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                error:SetCompilerErrorType(t)
                text message = "The class " + GetStaticKey() + " defines generics "
                message = message + "that lead to its parent class " + nextParent + 
                    " having two contradictory values, position " + lval + " (" + GetGeneric(lval) + "), and an undefined definition."
                error:SetErrorMessage(message)
                compilerErrorManager:Add(error)
                return false
            end
        end

        return true
    end

    private action GetParentGenericMap returns HashTable<text, HashTable<integer, integer>>
        return parentGenericMap
    end

    action MapParentGenericToMe(text parentKey, integer index) returns integer
        if HasParentClass(parentKey)
            //do we have a map for this generic?
            HashTable<integer, integer> map = parentGenericMap:GetValue(parentKey)
            if map not= undefined
                if map:HasKey(index)
                    return map:GetValue(index)
                else
                    return -1
                end
            else //we couldn't find the map. Ask the parent, and any of its parents, if it has one
                //check all of the maps to see if any of them lead to the one
                //in question. If this is not unique, is this an issue? Think on this more
                

            end
        end

        return -1
    end

    private action ResolveParentGenerics(SymbolTable table, CompilerErrorManager errors)
        //before we tackle the generics, lets setup all the parents as valid 
        //uses.
        Iterator<Class> myParents = GetParentClasses()
        repeat while myParents:HasNext()
            Class c = myParents:Next()
            AddValidUse(c)
        end
        
        HashTable<text, Array<Type>> newParentGenerics
        Iterator<text> keys = parentGenerics:GetKeyIterator()
        repeat while keys:HasNext()
            text key = keys:Next()
            Array<Type> theTypes = parentGenerics:GetValue(key)
            Class clazz = me:GetValidUseName(key)
            if clazz = undefined //could be ok if this is a generic
                if HasGeneric(key) //hash it as the type, which will be unique
                    newParentGenerics:Set(key, theTypes)
                else 
                    CompilerError error
                    error:SetLocation(me)
                    error:SetErrorMessage("I could not locate a class named " + key
                        + " from the class " + GetStaticKey() + "."
                    )
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:MISSING_USE)
                    error:SetCompilerErrorType(errorType)
                    FindPossibleUsage(table, error, key, errors)
                    errors:Add(error)
                end
            else
                newParentGenerics:Set(clazz:GetStaticKey(), theTypes)
            end
        end
        parentGenerics = newParentGenerics

        Iterator<Class> parentIterator = parents:GetValueIterator()
        repeat while parentIterator:HasNext()
            Class next = parentIterator:Next()
            key = next:GetStaticKey()
            Array<Type> types = GetParentGenerics(key)

            //first check if the class actually has any declared generics
            //if it doesn't, make sure the user didn't specify any
            boolean hasGenerics = next:HasGenerics()
            if hasGenerics = false
                if types not= undefined
                    if not types:IsEmpty() //the class has no generics, but the user tried to specify them
                        CompilerError error
                        error:SetLocation(me)
                        error:SetErrorMessage("I noticed there were generics specified for "
                            + "the parent " + next:GetStaticKey() + ", but this class "
                            + "does not have any generics."
                        )
                        CompilerErrorType errorType
                        errorType:SetCurrentType(errorType:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(errorType)
                        errors:Add(error)
                    end
                end
            else
                //if it does have generics, but the user didn't specify any
                //that's just fine. No need to do anything for this case
                

                //if there are generics, and they are specified, make sure
                //that the number of generics is exactly the same. If it isn't
                //that's an error, as it has to match.
                if types not= undefined
                    //first check that the number of parameters matches
                    baseSize = types:GetSize()
                    parentSize = next:GetNumberGenerics()
                    if baseSize not= parentSize
                        CompilerError error
                        error:SetLocation(me)
                        error:SetErrorMessage("I noticed there were generics specified for "
                            + "the parent " + next:GetStaticKey() + ", but this class "
                            + "has " + parentSize + " generics declared, but you " 
                            + "specified " + baseSize + "."
                        )
                        CompilerErrorType errorType
                        errorType:SetCurrentType(errorType:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(errorType)
                        errors:Add(error)
                    else 
                        //the numbers match, so line them up.
                        i = 0
                        repeat baseSize times
                            Type baseType = types:Get(i)
                            //resolve this type. If there are no errors, we're good.
                            ResolveType(me, baseType, table, errors)

                            //now we've resolved it, but we really only want to
                            //check to make sure this is either a propogation
                            //of types up the chain, but not a remapping,
                            //as I am suspicious this would get confusing to
                            //people

                            //add a compiler error if it's a primitie or a type
                            //other than a valid name
                            if baseType:IsPrimitive() or (not baseType:IsPrimitive() and baseType:GetStaticKey() not= baseType:OBJECT_KEY)
                                CompilerError error
                                error:SetLocation(me)
                                CompilerErrorType t
                                t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                                error:SetCompilerErrorType(t)
                                text message = "I noticed that there was generic defined in the class " + GetStaticKey() 
                                    + " for the parent " + key + " that is defined as " + baseType:GetStaticKey()
                                    + ". "

                                if generics:GetSize() = 1
                                    message = message + "The only allowed types that I know of is "
                                elseif generics:IsEmpty()
                                    message = message + " No generics are defined in " +  GetStaticKey() + " so none can be defined here."
                                else
                                    message = message + "The only allowed types that I know of are "
                                end

                                text genericList = ""
                                Iterator<text> gens = generics:GetIterator()
                                i = 0 
                                repeat while gens:HasNext()
                                    genericList = genericList + gens:Next()
                                    boolean hasNext = gens:HasNext() 
                                    boolean isLast = i = generics:GetSize() - 2
                                    if hasNext and not isLast
                                        genericList = genericList + ", "
                                    elseif hasNext and isLast and generics:GetSize() > 3
                                        genericList = genericList + ", and "
                                    elseif hasNext and isLast and generics:GetSize() = 2
                                        genericList = genericList + " and "
                                    end
                                    i = i + 1
                                end

                                message = message + genericList + "."
                                error:SetErrorMessage(message)
                                errors:Add(error)
                            end
                            i = i + 1
                        end
                    end
                end
            end
        end
    end

    private action ResolveFields(SymbolTable table, CompilerErrorManager errors)
        Iterator<Variable> iterator = GetVariables()    
        repeat while iterator:HasNext()
            Variable var = iterator:Next()
            ResolveVariable(var, table, errors)
        end
    end

    action GetInterfaceName returns text
        text name = GetName()
        return name + "_"
    end

    private action ResolveActions(SymbolTable table, CompilerErrorManager errors)
        Iterator<Action> actionIterator = me:GetActions()
        Array<Action> temp
        repeat while actionIterator:HasNext()
            Action next = actionIterator:Next()
            temp:Add(next)

            //first, we resolve the parameters
            Iterator<Variable> parameters = next:GetParameterIterator()
            repeat while parameters:HasNext()
                Variable param = parameters:Next()
                ResolveParameterType(param, param:GetType(), table, errors)
            end

            Type returnType = next:GetReturnType()
            if not returnType:IsVoid()
                ResolveParameterType(next, returnType, table, errors)
            end

            //next we resolve all of the variables in its blocks
            if next:GetBlock() not= undefined
                ResolveBlock(next:GetBlock(), table, errors)
            end
        end

        //now resolve the constructor, if one exists
        Action constructor = GetConstructor()
        if constructor not= undefined
            ResolveBlock(constructor:GetBlock(), table, errors)
        end

        //now we pull all actions out of the hash and re-hash them,
        //now with resolved type names and keys
        hasMain = false
        actions:Empty()
        actionIterator = temp:GetIterator()
        repeat while actionIterator:HasNext()
            Action next = actionIterator:Next()
            CompilerError error = Add(next)
            if error not= undefined
                errors:Add(error)
            end
        end
    end

    action ResolveFrames
        Iterator<Action> actionIterator = me:GetActions()
        repeat while actionIterator:HasNext()
            Action next = actionIterator:Next()
            if not next:IsSystem() and not next:IsBlueprint()
                Block b = next:GetBlock()
                b:AssignBytecodeLocations()
            end
        end
        if constructor not= undefined
            Block b = constructor:GetBlock()
            b:AssignBytecodeLocations()
        end
    end

    private action ResolveBlock(Block block, SymbolTable table, CompilerErrorManager errors)
        //first resolve all of the variables in this block
        Iterator<Variable> variables = block:GetVariables()
        repeat while variables:HasNext()
            Variable next = variables:Next()
            ResolveVariable(next, table, errors)
        end

        //next resolve any variables in the children
        Iterator<Block> blocks = block:GetBlocks()
        repeat while blocks:HasNext()
            Block next = blocks:Next()
            ResolveBlock(next, table, errors)
        end
    end

    private action ResolveParameterType(Location location, Type type, SymbolTable table, CompilerErrorManager errors)
        if type = undefined //this is an implicit type, which has to be a primitive
                            //therefore, it is safe to ignore this
            return now
        end

        //check if this class has generics. If it does, either map
        //the parameter to a generic or resolve it normally.
        if GetNumberGenerics() > 0
            key = type:GetStaticKey()
            if HasGeneric(key)
                //this is a generic parameter. Set it to object, but map it
                //to this generic name
                type:MapToGeneric(key)
                type:SetToObject(type:OBJECT_KEY)
            else
                ResolveType(location, type, table, errors)
            end

        else
            ResolveType(location, type, table, errors)
        end
    end

    private action ResolveVariable(Variable variable, SymbolTable table, CompilerErrorManager errors)
        Type type = variable:GetType()
        if type = undefined //this is an implicit type, which has to be a primitive
                            //therefore, it is safe to ignore this
            return now
        end
        ResolveType(variable, type, table, errors)
    end

    action ResolveType(Location location, Type type, SymbolTable table, CompilerErrorManager errors)
        if type = undefined
            return now
        end
        if not type:IsPrimitive() //if it's a primitive, do nothing
            text key = type:GetStaticKey()
            Class clazz = GetClass(key, table, errors)
            if clazz not= undefined
                has = HasGeneric(key)
                if has
                    type:MapToGeneric(key)
                end
                type:SetToObject(clazz:GetStaticKey())
                if type:HasGenerics()
                    //check to see if the number of generics matches with the class
                    if clazz:GetNumberGenerics() not= type:GetNumberGenerics() 
                        CompilerError error
                        error:SetLocation(location)
                        CompilerErrorType t
                        t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(t)
                        error:SetErrorMessage("I noticed there is a variable of type "
                            +  key + ". This class requires " + clazz:GetNumberGenerics()
                            + " generics, but there are " + type:GetNumberGenerics() + " defined.")
                        errors:Add(error)
                    end


                    Iterator<Type> generics = type:GetGenerics()
                    repeat while generics:HasNext()
                        Type generic = generics:Next()
                        if type:HasGenerics()
                            ResolveType(location, generic, table, errors)
                        end
                    end
                end
            else
                CompilerError error
                error:SetLocation(location)
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_USE)
                error:SetCompilerErrorType(t)
                error:SetErrorMessage("I could not locate a type named "
                    +  key + ". Did you forget a use statement?" )
                FindPossibleUsage(table, error, key, errors)
                errors:Add(error)
            end
        end
    end

    private action FindPossibleUsage(SymbolTable table, CompilerError error, text key, CompilerErrorManager errors)
        HashTable<text, Class> possibleUses

        Library library = table:GetLibrary()
        //first check the cache and see if the name exists
        
        Iterator<Class> iterator = table:GetClassByName(key)
        repeat while iterator not= undefined and iterator:HasNext()
            Class value = iterator:Next()
            if not possibleUses:HasKey(value:GetStaticKey())
                possibleUses:Add(value:GetStaticKey(), value)
            end
        end

        if library not= undefined
            SymbolTable stlTable = library:GetSymbolTable()
            iterator = stlTable:GetClassByName(key)
            repeat while iterator not= undefined and iterator:HasNext()
                Class value = iterator:Next()
                if not possibleUses:HasKey(value:GetStaticKey())
                    possibleUses:Add(value:GetStaticKey(), value)
                end
            end
        end

        //we now have the complete set of possible options that could be uses
        //now make hints for them.
        Iterator<Class> classes = possibleUses:GetValueIterator()
        repeat while classes:HasNext()
            Class possible = classes:Next()
            //add an editor hint telling the user
            UseHint hint
            Location locationCopy = error:CreateLocationCopy()
            hint:SetLocation(locationCopy)
            text code = "use " + possible:GetStaticKey()
            code = code + code:GetCarriageReturn() + code:GetLineFeed()
            hint:SetCode(code)
            hint:SetLibraryName(possible:GetStaticKey())

            integer packageOffset = packageName:GetIndexEnd()
            //this needs to compute an offset range in whatever way 
            //NetBeans or other IDEs need them in.
            Iterator<QualifiedName> uses = unresolvedUseStatements:GetValueIterator()
            integer index = 0
            repeat while uses:HasNext()
                QualifiedName n = uses:Next()
                if n:GetIndexEnd() > index
                    index = n:GetIndexEnd()
                end
            end

            if packageOffset > index
                index = packageOffset
            end

            //if the index is not at the start of the file, add
            //a carriage return and line feed
            if index not= 0
                index = index + 2
            end
            hint:SetStartOffset(index)
            hint:SetEndOffset(index)

            errors:Add(hint)
        end
    end

    private action ResolveType(Variable variable, Type type, SymbolTable table, CompilerErrorManager errors)
        if type = undefined
            return now
        end
        if not type:IsPrimitive() //if it's a primitive, do nothing
            text key = type:GetStaticKey()
            Class clazz = GetClass(key, table, errors)
            if clazz not= undefined
                //if the name of the object is a generic
                if HasGeneric(type:GetStaticKey())
                    type:MapToGeneric(type:GetStaticKey())
                end
                type:SetToObject(clazz:GetStaticKey())
                if type:HasGenerics()
                    //check to see if the number of generics matches with the class
                    if clazz:GetNumberGenerics() not= type:GetNumberGenerics() 
                        CompilerError error
                        error:SetLocation(variable)
                        CompilerErrorType t
                        t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(t)
                        error:SetErrorMessage("I noticed there is a variable of type "
                            +  key + ". This class requires " + clazz:GetNumberGenerics()
                            + " generics, but there are " + type:GetNumberGenerics() + " defined.")
                        errors:Add(error)
                    end


                    Iterator<Type> generics = type:GetGenerics()
                    repeat while generics:HasNext()
                        Type generic = generics:Next()
                        if type:HasGenerics()
                            ResolveType(variable, generic, table, errors)
                        end
                    end
                end
            else
                CompilerError error
                error:SetLocation(variable)
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_USE)
                error:SetCompilerErrorType(t)
                error:SetErrorMessage("I could not locate a type named "
                    +  key + ". Did you forget a use statement?" )
                FindPossibleUsage(table, error, key, errors)
                errors:Add(error)
            end
        end
    end

    /*
        This action resolves a type that lives in an action.
    */
    private action ResolveType(Action act, Type type, SymbolTable table, CompilerErrorManager errors)
        if not type:IsPrimitive() //if it's a primitive, do nothing
            text key = type:GetStaticKey()
            Class parentForAction = act:GetParentClass()
            if parentForAction:HasGeneric(type:GetStaticKey())
                //this is referencing a generic, so there's no need to check
                //the symbol table. Grab Object and tell it its mapped
                //generic name
                type:MapToGeneric(key)
                type:SetToObject(type:OBJECT_KEY)
                return now
            end

            Class clazz = GetClass(key, table, errors)
            if clazz not= undefined
                type:SetToObject(clazz:GetStaticKey())
                if type:HasGenerics()
                    //check to see if the number of generics matches with the class
                    if clazz:GetNumberGenerics() not= type:GetNumberGenerics() 
                        CompilerError error
                        error:SetLocation(act)
                        CompilerErrorType t
                        t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(t)
                        error:SetErrorMessage("I noticed there is a variable of type "
                            +  key + ". This class requires " + clazz:GetNumberGenerics()
                            + " generics, but there are " + type:GetNumberGenerics() + " defined.")
                        errors:Add(error)
                    end


                    Iterator<Type> generics = type:GetGenerics()
                    repeat while generics:HasNext()
                        Type generic = generics:Next()
                        if type:HasGenerics()
                            ResolveType(act, generic, table, errors)
                        end
                    end
                end
            else
                CompilerError error
                error:SetLocation(act)
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_USE)
                error:SetCompilerErrorType(t)
                error:SetErrorMessage("I could not locate a type named "
                    +  key + ". Did you forget a use statement?" )
                FindPossibleUsage(table, error, key, errors)
                errors:Add(error)
            end
        end
    end

    action ResolveActionKey(text name, Iterator<Variable> parameters, 
        SymbolTable table, CompilerErrorManager errors) returns text
        text final = name
        
        repeat while parameters:HasNext()
            Variable param = parameters:Next()
            Type type = param:GetType()
            if type:IsPrimitive()
                final = final + ":" + type:GetStaticKey() 
            else
                Class clazz = GetClass(type:GetStaticKey(), table, errors)
                if clazz not= undefined //if it is, an error has been issued
                    final = final + ":" + clazz:GetStaticKey()
                end
            end
        end

        return final
    end

    private action GetGenericKey(Iterator<Type> generics, 
        SymbolTable table, CompilerErrorManager errors) returns text
        text final = "<"
        first = true
        repeat while generics:HasNext()
            Type type = generics:Next()
            
            if type:IsPrimitive()
                if first
                    final = final + type:GetStaticKey() 
                    first = false
                else
                    final = final + ":" + type:GetStaticKey() 
                end
                
            else
                Class clazz = GetClass(type:GetStaticKey(), table, errors)
                if clazz not= undefined //if it is, an error has been issued
                    if first
                        final = final + clazz:GetStaticKey()
                        first = false
                    else
                        final = final + ":" + clazz:GetStaticKey()
                    end
                    
                end

                //does the type have generics
                if type:HasGenerics()
                    Iterator<Type> gen = type:GetGenerics()
                    final = final + GetGenericKey(gen, table, errors)
                end
            end
        end

        return final + ">"
    end

    private action GetClass(text key, SymbolTable table, CompilerErrorManager errors) returns Class
        Class clazz = undefined
        Array<text> split = key:Split("\.")

        //first check if this is a full name in the symbol table. 
        //be careful to check the default package only if this class
        //is in the default package. 
        if split:GetSize() > 1
            clazz = table:GetClass(key)
        end

        if clazz not= undefined
            return clazz
        end
        //next check if this is the name of a generic in this class
        has = HasGeneric(key)
        if has
            Type type
            clazz = table:GetClass(type:OBJECT_KEY)
        end

        if clazz not= undefined
            return clazz
        end

        //if we still haven't found it, then check if there are any classes
        //in the current package of the class by that name. If there are, then
        //use that.
        Class fromPackage = table:GetClassInPackage(me:GetPackageKey(), key)

        //is there a name in the use list?
        Class fromUse = me:GetValidUseName(key)

        //is there a name in both the use list and the package?
        //if so, it's a compiler error if they conflict
        //if no name is found, this is an error
        //if the name is unique, use that one and put it in the class
        if fromPackage not= undefined and fromUse = undefined
            clazz = fromPackage
        elseif fromPackage = undefined and fromUse not= undefined
            clazz = fromUse
        elseif fromPackage not= undefined and fromUse not= undefined
            //if both classes are the same, then return it
            if fromPackage:GetStaticKey() = fromUse:GetStaticKey()
                clazz = fromPackage
            else //this is a conflict and a compiler error
                CompilerError error
                text a = ""
                a = a:GetDoubleQuote()
                error:SetErrorMessage("The name " + a + key + a
                    + " could be either " + a + fromPackage:GetStaticKey() + a 
                    + " or " + a + fromUse:GetStaticKey() + a + ". I cannot tell which one you meant." ) 
                //TODO: Add in compiler error line and location.
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:USE_AMBIGUOUS)
                error:SetCompilerErrorType(errorType)
                errors:Add(error)
            end
        end

        if clazz not= undefined
            //check to make sure that this class is listed in our dependencies
            //if it is not, but it is valid, then add it.
            if not dependencies:HasKey(clazz:GetStaticKey())
                dependencies:Add(clazz:GetStaticKey(), clazz)
            end
            return clazz
        end

        return undefined
    end

    action ResolveParentLevels(SymbolTable table)
        HashTable<text, Class> tempParents
        Array<Array<Class>> leveledParents
        Array<Class> levelOneParents
        leveledParents:Add(levelOneParents)

        Iterator<QualifiedName> names = GetUnresolvedParents()
        repeat while names:HasNext()
            QualifiedName name = names:Next()
            
            Class myParent = table:GetClass(name:GetStaticKey())

            if myParent not= undefined //if it is defined, add it as a valid parent
                if not tempParents:HasKey(myParent:GetStaticKey())
                    levelOneParents:Add(myParent)
                    tempParents:Add(myParent:GetStaticKey(), myParent)
                end
            end //if it is not, ignore it, as an error has already been issued
        end

        directParents = levelOneParents

        Array<Class> currentLevelParents = levelOneParents
        Array<Class> nextLevelParents
        Iterator<Class> nextLevel = currentLevelParents:GetIterator()
        repeat while nextLevel:HasNext()
            Class next = nextLevel:Next()

            Iterator<QualifiedName> nextNames = next:GetUnresolvedParents()
            repeat while nextNames:HasNext()
                QualifiedName name = nextNames:Next()

                Class myParent = table:GetClass(name:GetStaticKey())

                if myParent not= undefined
                    if not tempParents:HasKey(myParent:GetStaticKey())
                        nextLevelParents:Add(myParent)
                        tempParents:Add(myParent:GetStaticKey(), myParent)
                    end
                end //if it is not, ignore it, as an error has already been issued
            end

            //check if this is the last parent in this level.
            //if it is start going over the next level, which might be empty.
            if not nextLevel:HasNext()
                if not nextLevelParents:IsEmpty()
                    leveledParents:Add(nextLevelParents)
                end
                currentLevelParents = nextLevelParents
                Array<Class> classes
                nextLevelParents = classes
                nextLevel = currentLevelParents:GetIterator()
            end
        end

        resolvedParentLevels = leveledParents
    end

    action ResolveParents(SymbolTable table, CompilerErrorManager errors)
        isResolvingParents = true
        HashTable<text, QualifiedName> tempHash
        Iterator<QualifiedName> names = GetUnresolvedParents()
        repeat while names:HasNext()
            QualifiedName name = names:Next()
            Class myParent = GetClass(name:GetStaticKey(), table, errors)

            if myParent not= undefined //if it is defined, add it as a valid parent
                parents:Add(myParent:GetStaticKey(), myParent)
                tempHash:Add(myParent:GetStaticKey(), name)
            end //if it is not, ignore it, as an error has already been issued
        end

        //ok, we now have all first level parents, so check them all
        //if they are already resolved, then flatten their lists and check
        //for circular dependencies
        //if the parents are not resolved, then resolve them before doing this.
        //since each parent's list is flattened after solution,
        //this does not need to go another level deeper.
        Iterator<Class> parentIterator = parents:GetValueIterator()
        repeat while parentIterator:HasNext()
            Class next = parentIterator:Next()
            
            //if this parent is in the middle of a ResolveParents call
            //we have a circular dependency and should throw a compiler error
            //we should also bail out at this point, because the behavior
            //would make no sense
            if next:IsResolvingParents()
                CompilerError error
                text a = ""
                a = a:GetDoubleQuote()
                error:SetErrorMessage("The parent name " + a + next:GetStaticKey() + a + 
                    " has the current class as a parent, but I do not understand what this would mean.") 
                //TODO: Add in compiler error line and location.
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:INHERITANCE_CIRCULAR)
                error:SetCompilerErrorType(errorType)
                errors:Add(error)

                isResolvingParents = false
                areParentsResolved = true
            end

            //also make sure the parent is not a shared class
            //There is a technical solution to make this work, but 
            //allowing it could be confusing for users and more studies are required.
            if next:IsStatic()
                CompilerError error
                text a = ""
                a = a:GetDoubleQuote()
                error:SetErrorMessage("The parent " + a + next:GetStaticKey() + a + 
                    " is a shared class, which cannot be inherited from. Please remove the reference to "
                    + a + next:GetStaticKey() + a + " after the " + a + " is " + a + " statement in class " + GetStaticKey()) 
 
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:SHARED_PARENT_CLASS)
                error:SetCompilerErrorType(errorType)
                error:SetLineNumber(me:GetLineNumber())
                error:SetLineNumberEnd(me:GetLineNumber())
                error:SetFile(me:GetFile())
                
                QualifiedName value = tempHash:GetValue(next:GetStaticKey())
                if value = undefined
                    error:SetIndex(me:GetIndex())
                    error:SetIndexEnd(me:GetIndex() + GetName():GetSize() + 5) //the class and the name
                else 
                    error:SetIndex(value:GetIndex())
                    error:SetIndexEnd(value:GetIndexEnd()) //the class and the name
                end

                errors:Add(error)
            end

            //otherwise check if the parent is resolved
            if not next:AreParentsResolved()
                next:ResolveParents(table, errors)
            end
            //the parent is now resolved. 
            Iterator<Class> list = next:GetParentClasses()
            repeat while list:HasNext()
                Class possibleParent = list:Next()
                //if this parent is not in our list, add it
                if not parents:HasKey(possibleParent:GetStaticKey())
                    parents:Add(possibleParent:GetStaticKey(), possibleParent)
                end
            end
        end

        

        //regardless of whether the user has errors in their code,
        //the parents have been resolved.
        isResolvingParents = false
        areParentsResolved = true
        if not errors:HasErrors()
            ComputeParentCreationOrder(errors)
        end
    end

    /*
        This action computes the order that parents should be instantiated in 
        when a child is created, for a particular class hierarchy.
    */
    private action ComputeParentCreationOrder(CompilerErrorManager errors)
        Iterator<Class> parentIterator = parents:GetValueIterator()
        if not parentIterator:HasNext()
            return now
        end

        HashTable<text, integer> order
        repeat while parentIterator:HasNext()
            Class par = parentIterator:Next()
            text key = par:GetStaticKey()
            order:Add(key, 0)
        end

        parentIterator = parents:GetValueIterator()
        repeat while parentIterator:HasNext()
            Class par = parentIterator:Next()
            text key = par:GetStaticKey()
            
            //Get all of the parents and add 1 for everything in the flattened list
            Iterator<Class> grandParentIterator = par:GetParentClasses()
            repeat while grandParentIterator:HasNext()
                Class grandparent = grandParentIterator:Next()
                text grandparentKey = grandparent:GetStaticKey()
                integer value = order:GetValue(grandparentKey)
                order:Set(grandparentKey, value + 1)
            end
        end
        Array<ClassAttribute> attributes
        Iterator<text> keys = order:GetKeyIterator()
        repeat while keys:HasNext()
            text key = keys:Next()
            integer value = order:GetValue(key)
            ClassAttribute attribute
            attribute:name = key
            attribute:value = value
            attributes:Add(attribute)
        end

        text theFirstOrder = ""
        attributes:Sort()
        Array<Class> parentCreationOrderArray
        i = 0
        repeat while i < attributes:GetSize()
            text key = attributes:Get(i):name
            //get the parent corresponding to this key
            Class newParent = GetParentClass(key)
            //create the array
            parentCreationOrderArray:Add(newParent)
            i = i + 1
        end

        if not errors:HasErrors()
            parentCreationOrder = parentCreationOrderArray
        end
    end

    /*
        This action returns the order in which parents should be instantiated.
        It provides an optimal ordering to ensure children do not get created 
        before their parents.
    */
    action  GetParentCreationOrder returns Iterator<Class>
        if GetStaticKey() = LIBRARIES_LANGUAGE_OBJECT and parentCreationOrder = undefined
            Array<Class> parentCreationOrderArray
            parentCreationOrder = parentCreationOrderArray
        end

        if parentCreationOrder = undefined
            return parents:GetValueIterator()
        end
        return parentCreationOrder:GetIterator()
    end

    /*
        This action returns true only if the action ResolveParents is currently
        executing for this class. It is useful in detecting circular inheritance,
        which is not allowed in Quorum.
    */
    action IsResolvingParents returns boolean
        return isResolvingParents
    end

    /*
        This action determines whether this class has a complete
        flattened list of parents from all possible super-classes.
        For example, if we have a class A is B, class B is C, and class C is D,
        then the flattened list of A is B, C, D, and Libraries.Language.Object.
    */
    private action AreParentsResolved returns boolean
        return me:areParentsResolved
    end

    action HasParentClass(text key) returns boolean
        return parents:GetValue(key) not= undefined
    end

    action GetParentClass(text key) returns Class
        return parents:GetValue(key)
    end

    /*
        Obtains a list of all parents reachable from this class. This includes
        parents and the parents of parents as a flattened list.
    */
    action GetParentClasses returns Iterator<Class>
        return parents:GetValueIterator()
    end

    /*
        This action returns those parents that are directly specified 
        in the class. Object is also always included in this list.
    */
    action GetDirectParentClasses returns Iterator<Class>
        return directParents:GetIterator()
    end

    action AddValidUse(Class clazz) returns CompilerError
        name = clazz:GetName()
        if validUses:HasKey(name)
            //see if we're trying to add the same class. If so, it's just fine
            //if it's the same name, but a different class, then throw an error
            Class other = validUses:GetValue(name)
            if other:GetStaticKey() not= clazz:GetStaticKey()
                Class defined = validUses:GetValue(name)
                CompilerError error
                CompilerErrorType type
                type:SetCurrentType(type:USE_AMBIGUOUS)
                error:SetCompilerErrorType(type)
                error:SetErrorMessage("I do not understand what is meant by defining " + name + " as type " + clazz:GetStaticKey() + "." + 
                    " I already defined it as type " + defined:GetStaticKey() + ".")
                return error
            else //it's fine to return undefined, because we just ignored the request
                return undefined
            end
        else
            validUses:Add(name, clazz)
            validUsesFullyQualified:Add(clazz:GetStaticKey(), clazz)
        end
        return undefined
    end

    /*
        Returns the file on disk that contains the implementation of this class.
    */
    action GetFile returns File
        return file
    end

    /*
        Sets a pointer to the file on disk that contains this class.
    */
    action SetFile(File container)
        file = container
    end

    action HasMainAction returns boolean
        Action main = actions:GetValue("Main")
        if main not= undefined
            if not main:IsBlueprint() and not main:IsSystem()
                return true
            end
        end
        return false
    end

    action AddUnresolvedUseStatement(QualifiedName name)
        unresolvedUseStatements:Add(name:GetStaticKey(), name)
    end

    action GetUnresolvedUseStatement(text key) returns QualifiedName
        return unresolvedUseStatements:GetValue(key)
    end

    action GetUnresolvedUseStatements returns Iterator<QualifiedName>
        return unresolvedUseStatements:GetValueIterator()
    end

    action GetUnresolvedParents returns Iterator<QualifiedName>
        return unresolvedParents:GetIterator()
    end

    /*
        This action returns a class from a name, like Object, for
        Libraries.Language.Object. It assumes that the name passed in is
        not resolved. Fully resolvable names (Libraries.Language.Object) will
        not be resolved by this action, and as such, need to be resolved
        from the symbol table.
    */
    action GetValidUseName(text name) returns Class
        if validUses:HasKey(name)
            return validUses:GetValue(name)
        end

        return undefined
    end

    /*
        This returns all classes that have valid use statements in the class. 
    */
    action GetValidUses returns Iterator<Class>
        return validUsesFullyQualified:GetValueIterator()
    end

    action Add(Variable variable) returns CompilerError
        if fields:HasKey(variable:GetStaticKey())
            CompilerError error
            CompilerErrorType type
            type:SetCurrentType(type:DUPLICATE)
            error:SetCompilerErrorType(type)
            error:SetLocation(variable)
            error:SetErrorMessage("Variable " + variable:GetDisplayName() + " has already been defined in class " + me:GetDisplayName())
            return error
        end
        variable:SetIsField(true)
        fields:Add(variable:GetStaticKey(), variable)
        return undefined
    end

    action CalculateFieldHints(CompilerErrorManager errors)
        Iterator<text> iterator = fields:GetKeyIterator()
        repeat while iterator:HasNext()
            text key = iterator:Next()
            Variable var = fields:GetValue(key)

            text getter = var:GetDefaultGetterName()

            //first check if there's a getter
            boolean hasGetter = false
            Action getterAction = actions:GetValue(getter)
            if getterAction not= undefined
                Type theReturn = getterAction:GetReturnType()
                if theReturn:GetStaticKey() = var:GetType():GetStaticKey() 
                    hasGetter = true
                end
            end

            if not hasGetter //generate a hint for the getter
                GetterGenerationHint hint
                Location locationCopy = var:CreateLocationCopy()
                hint:SetLocation(locationCopy)
                text code = 
"
    action " + getter + " returns " + var:GetType():GetName() +
"
        return " + var:GetName() + "
    end"
                code = code + code:GetCarriageReturn() + code:GetLineFeed()
                hint:SetCode(code)
                hint:SetLibraryName(var:GetName())

                integer finish = GetIndexEnd() - 3 //the end keyword
                hint:SetStartOffset(finish)
                hint:SetEndOffset(finish)
                errors:Add(hint)
            end

            //now check if there's a setter
            boolean hasSetter = false
            text setter = var:GetDefaultSetterName()
            text setterSignature = setter + ":" + var:GetType():GetStaticKey()
            Action setterAction = actions:GetValue(setterSignature)
            if setterAction not= undefined
                Type theReturn = setterAction:GetReturnType()
                if theReturn:IsVoid()
                    hasSetter = true
                end
            end

            if not hasSetter //generate a hint for the getter
                SetterGenerationHint hint
                Location locationCopy = var:CreateLocationCopy()
                hint:SetLocation(locationCopy)
                text code = 
"
    action " + setter + "(" + var:GetType():GetName() + " " + var:GetName() + ")" +
"
        me:" + var:GetName() + " = " + var:GetName() + 
"
    end"
                code = code + code:GetCarriageReturn() + code:GetLineFeed()
                hint:SetCode(code)
                hint:SetLibraryName(var:GetName())

                integer finish = GetIndexEnd() - 3 //the end keyword
                hint:SetStartOffset(finish)
                hint:SetEndOffset(finish)
                errors:Add(hint)
            end
        end
    end

    action GetVariable(text key) returns Variable
        return fields:GetValue(key)
    end

    action GetVariables returns Iterator<Variable> 
        return fields:GetValueIterator()
    end

    action GetAction(text key) returns Action
        return actions:GetValue(key)
    end

    action GetVirtualAction(text key) returns Action
        return virtualActions:GetValue(key)
    end

    action GetActions returns Iterator<Action>
        return actions:GetValueIterator()
    end

    action HasAction(text key) returns boolean
        return actions:HasKey(key)
    end

    private action IsDefined(Action method) returns boolean
        return actions:HasKey(method:GetStaticKey())
    end

    /*
        This action returns whether or not the class has an explicity constructor
        defined. If it returns true, the user has defined a constructor. If
        it returns false, they have not.
    */
    action HasConstructor returns boolean
        return constructor not= undefined
    end

    action GetConstructor returns Action
        return constructor
    end

    action SetConstructor(Action method) 
        constructor = method
    end

    action GetStaticKey returns text
        return staticKey
    end

    /*
        This action returns the static key formatted as a class name in 
        Java bytecode.
    */
    action ConvertStaticKeyToJavaScriptName returns text
        return "quorum_" + staticKeyUnderscores + "_"
    end

    /*
        This action returns the static key formatted as a class name in 
        Java bytecode.
    */
    action ConvertStaticKeyToBytecodePath returns text
        return "quorum/" + staticKeySlashes
    end

    action ConvertStaticKeyToUnderScore returns text
        return "quorum_" + staticKeyUnderscores + "_"
    end
    
    /*
        This action returns the static key formatted as a class name in 
        the style of a field.
    */
    action ConvertStaticKeyToFieldPath returns text
        return staticKeyUnderscores + "_"
    end

    /*
        This action returns the static key formatted as a class name in 
        Java bytecode.
    */
    action ConvertStaticKeyToBytecodeInterfacePath returns text
        return "quorum/" + staticKeySlashes + "_"
    end

    /*
        This action returns the static key formatted as a plugin class name in 
        Java bytecode.
    */
    action ConvertStaticKeyToPluginPath returns text
        return "plugins/quorum/" + staticKeySlashes
    end

    /*
        This action returns the static key formatted as a plugin class type name in 
        Java bytecode.
    */
    action ConvertStaticKeyToPluginPathTypeName returns text
        return "Lplugins/quorum/" + staticKeySlashes + ";"
    end

    /*
        Returns the name of the plugin for this class.
    */
    action GetPluginName returns text
        return "plugin_"
    end

    /*
        This action returns the static key formatted as a type name in
        Java bytecode.
    */
    action ConvertStaticKeyToBytecodePathTypeName returns text
        return "Lquorum/" + staticKeySlashes + ";"
    end

    /*
        This action returns the static key formatted as a type name in
        Java bytecode. This version acts as an interface type.
    */
    action ConvertStaticKeyToBytecodePathTypeNameInterface returns text
        return "Lquorum/" + staticKeySlashes + "_;"
    end

    action GetHiddenVariableName() returns text
        return "hidden_"
    end

    /*
        This action converts the static key of this class to a 
        name that can be used by the compiler as a class field name.
        An example would be that Libraries.Language.Object becomes
        Libraries_Language_Object__.
    */
    action ConvertStaticKeyToParentFieldName returns text
        return staticKeyUnderscores + "__"
    end

    /*
        This action converts the static key of this class to a 
        name that can be used by the compiler as a class field name.
        An example would be that Libraries.Language.Object becomes
        Libraries_Language_Object__.
    */
    action ConvertStaticKeyToParentFieldInterfaceName returns text
        return staticKeyUnderscores + "__"
    end

    /*
        This returns a key related to the package a class is contained in. For
        example, if a class's fully qualified name is Libraries.Language.Object,
        then this would return Libraries.Langauge. If the class's fully qualified
        name is Bob, then this would return the empty string, which indicates
        the default package.
    */
    action GetPackageKey returns text
        text pack = packageName:GetStaticKey()
        return pack
    end

    action GetDisplayName returns text
        return GetStaticKey()
    end

    action GetPackage returns QualifiedName
        return packageName:Copy()
    end

    /*
        This action removes all of the call locations from a particular file
        to a particular set of actions in this class's available actions. As such, 
        it removes them both from these actions and those defined and 
        used by the parent.
    */
    action RemoveCallLocationsFromActions(File file)
        Iterator<Action> it = GetActions()
        repeat while it:HasNext()
            Action value = it:Next()
            value:RemoveCallLocations(file)
        end

        //now get all of the parents and do those
        it = GetParentActions()
        repeat while it:HasNext()
            Action value = it:Next()
            value:RemoveCallLocations(file)
        end
    end

    action RemoveCallLocationsFromDependencies(File file)
        Iterator<Class> value = dependencies:GetValueIterator()
        repeat while value:HasNext()
            Class c = value:Next()
            c:RemoveCallLocationsFromActions(file)
            c:RemoveUseLocations(file)
        end
    end

    action RemoveUseLocations(File file)
        text path = file:GetAbsolutePath()
        if useLocationHash:HasKey(path)
            useLocationHash:RemoveKey(path)
        end

        //Now remove them from all of the actions in this class
        Iterator<Action> actions = GetActions()
        repeat while actions:HasNext()
            Action act = actions:Next()
            act:RemoveCallLocations(file)
        end

        Iterator<Variable> variables = GetVariables()
        repeat while variables:HasNext()
            Variable var = variables:Next()
            var:RemoveUseLocations(file)
        end
    end

    action ResolveAction(ActionCall call) returns ActionCallResolution
        ActionCallResolution resolution
        Array<Type> parameters = call:actualParameters
        //if this is null, then we somehow had an invalid sequence from the 
        //user (e.g., missing variable). An error has been thrown already, 
        //so ignore it here.
        if parameters = undefined
            return resolution
        end
        TypeChecker checker = call:checker

        Array<Action> named //actions with the right name
        Array<integer> scores
        Array<Action> matches
        Iterator<Action> all = undefined
        ActionCallOpcode code = call:opcode
        //this is an explicit call to the parent, so only grab that table.
        if code not= undefined and code:IsParentCall()
            Class par = code:GetParentToCallOn()
            if par = undefined
                //the error should already be defined
                return resolution
            end
            all = par:GetVirtualTable()
        else 
            all = virtualActions:GetValueIterator()
        end
        
        repeat while all:HasNext()
            Action act = all:Next()
            if act:GetName() = call:name //the name is right
                calledParameterSize = parameters:GetSize()
                actualParameterSize = act:GetParametersSize()

                if calledParameterSize = actualParameterSize //the number of parameters match
                    named:Add(act)
                end
            end
        end

        if named:IsEmpty()
            resolution:isResolved = false
            CompilerError error
            error:SetLocation(call)
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:MISSING_METHOD)
            error:SetCompilerErrorType(errorType)

            text message = "I could not find an action named '" + 
                call:name + "' in the class '" + me:GetStaticKey() + "'" 
            
            if parameters:IsEmpty()
                message = message + " without parameters."
            else
                text params = " with the "
                if parameters:GetSize() = 1
                    params = params + "parameter "
                else
                    params = params + "parameters "
                end

                i = 0
                repeat parameters:GetSize() times
                    Type type = parameters:Get(i)
                    if type = undefined
                        params = params + "undefined"
                    else
                        params = params + type:GetStaticKey()
                    end
                    
                    i = i + 1

                    if i < parameters:GetSize()
                        params = params + ", "
                    end
                end
                message = message + params
            end

            error:SetErrorMessage(message)
            error:SetLocation(call)
            resolution:error = error
            return resolution
        end
        Operation implicit
        implicit:SetOperation(implicit:IMPLICIT_CAST)

        Iterator<Action> it = named:GetIterator()
        //assume they have an equal number of parameters
        repeat while it:HasNext() 
            Action act = it:Next()
            i = 0
            integer actionPoints = 0
            Iterator<Variable> variables = act:GetParameterIterator()
            boolean isMatch = true
            repeat while variables:HasNext() and isMatch
                Variable formalParameter = variables:Next()
                Type formalParameterType = formalParameter:GetType()
                Type actualParameterType = parameters:Get(i)
                GenericResolution generic = ResolveGenericParameter(act, call, formalParameterType)

                //Check the types to make sure that they are compatible
                TypeCheckResult result = CheckTypeWithGeneric(generic, checker, formalParameterType, actualParameterType)
                CompilerError error = result:GetCompilerError(call)
                if error not= undefined //this action is not a match. We can break out
                    isMatch = false
                else 
                    TypeConversionPoints points = result:points
                    actionPoints = actionPoints + points:GetPoints()
                end
                i = i + 1
            end

            if isMatch
                matches:Add(act)
                scores:Add(actionPoints)
            end
        end
        
        Array<Action> finalMatches
        integer minPoints = 0
        minPoints = minPoints:GetMaximumValue()
        i = 0
        repeat matches:GetSize() times
            Action act = matches:Get(i)
            integer points = scores:Get(i)
            
            if points < minPoints
                minPoints = points
                finalMatches:Empty()
                finalMatches:Add(act)
            elseif points = minPoints
                finalMatches:Add(act)
            end

            i = i + 1
        end

        if finalMatches:GetSize() = 1
            resolution:resolvedAction = finalMatches:Get(0)
            Action final = finalMatches:Get(0)

            Location nameLocation = call:nameLocation
            if nameLocation not= undefined
                resolution:nameLocation = nameLocation:CreateLocationCopy()
                final:AddCallLocation(resolution:nameLocation)
            end

            if call:calledFrom not= undefined
                Action from = call:calledFrom
                from:AddActionCalls(resolution)
            end

            //now compute any implicit casts, if there are any
            Array<QuorumOpcode> casts
            Iterator<Variable> variables = final:GetParameterIterator()
            i = 0
            repeat while variables:HasNext()
                Type actual = parameters:Get(i)
                text actualText = actual:GetStaticKey()
                Variable var = variables:Next()
                Type formal = var:GetType()
                text formalText = formal:GetStaticKey()
                GenericResolution generic = ResolveGenericParameter(final, call, formal)

                if generic:hasGeneric and generic:error not= undefined
                    resolution:isResolved = false
                    resolution:error = generic:error
                    return resolution
                end

                //Check the types to make sure that they are compatible
                TypeCheckResult result = CheckTypeWithGeneric(generic, checker, formal, actual)

                //If this throws an error, it means that there was a generic
                //type that was mismatched.

                if result:errorType not= undefined
                    resolution:isResolved = false
                    CompilerError error = result:GetCompilerError(call)
                    resolution:error = error
                    return resolution
                end

                TypeConversionConstants constants = result:conversion
                if constants:GetConversion() = constants:NONE
                    casts:Add(undefined)
                else
                    QuorumOpcode op = result:GetQuorumOpcode()
                    casts:Add(op)
                end
                resolution:converter = casts

                i = i + 1
            end
            
            resolution:isResolved = true
        elseif finalMatches:GetSize() > 1 //check all of the scores
            resolution:resolvedAction = undefined
            resolution:isResolved = false
            CompilerError error

            text value = "I could not find an action that uniquely matches with the name '" + 
                call:name + "' in the class '" + me:GetStaticKey() + "' The reason is because the actions "

             Iterator<Action> m = finalMatches:GetIterator()
             repeat while m:HasNext()
                Action a = m:Next()
                value = value + a:GetStaticKey()

                if m:HasNext()
                    value = value + ", and "
                end
             end
             value = value + " all match the parameters."
             
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:METHOD_CALL_AMBIGUOUS)
            error:SetCompilerErrorType(errorType)
            error:SetErrorMessage(value)
            error:SetLocation(call)
            resolution:error = error
        else //There are no matches
            resolution:resolvedAction = undefined
            resolution:isResolved = false
            CompilerError error
            error:SetLocation(call)
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:MISSING_METHOD)
            error:SetCompilerErrorType(errorType)
            text message = "I could not find an action named '" + 
                call:name + "' in the class '" + me:GetStaticKey() + "'" 
            
            if parameters:IsEmpty()
                message = message + " without parameters."
            else
                text params = " with the "
                if parameters:GetSize() = 1
                    params = params + "parameter "
                end

                if parameters:GetSize() > 1
                    params = params + "parameters "
                end

                i = 0
                repeat parameters:GetSize() times
                    Type type = parameters:Get(i)
                    if type = undefined
                        params = params + "undefined"
                    else 
                        params = params + type:GetStaticKey()
                    end
                    
                    i = i + 1

                    if i < parameters:GetSize()
                        params = params + ", "
                    end
                end
                message = message + params
            end

            error:SetErrorMessage(message)
            resolution:error = error
        end

        return resolution
    end


    private action CheckTypeWithGeneric(GenericResolution generic, TypeChecker checker, Type formal, Type actual) returns TypeCheckResult
        TypeCheckResult result = undefined
        Operation implicit
        implicit:SetOperation(implicit:IMPLICIT_CAST)
        if generic:hasGeneric
            //ResolveGenericParameter(act, call, formalParameterType)
            Type resolved = generic:resolvedType //this may be null

            if resolved = undefined
                resolved = actual //temporary hack to prevent crashing while the templating system is finished.
            end

            if actual = undefined
                TypeCheckResult result2
                CompilerErrorType type
                type:SetCurrentType(type:MISSING_VARIABLE)
                result2:errorMessage = "A formal parameter with generic name " + formal:GetMappedGeneric() + " is missing."
                result2:errorType = type
                return result2
            end

            if actual:IsPrimitive()
                //if we have a primitive type that we're calling to, 
                //we need to do something special to ensure the generic
                //is correct.
                Type upCastResolved
                upCastResolved:SetToObject(resolved:ConvertToNonPrimitiveStaticKey())
                Operation genericCast
                genericCast:SetOperation(genericCast:GENERIC_CAST)
                result = checker:Check(upCastResolved, actual, genericCast, false)
            else
                //if resolved is a primitive, check if the actual type is compatible
                //with the type of primitive. If resolved is not a primitive
                //then just compare the resolved type to the actual type.
                //So long as it's a subclass, we're cool.
                if resolved:IsPrimitive()
                    Type upCastResolved
                    upCastResolved:SetToObject(resolved:ConvertToNonPrimitiveStaticKey())
                    resolved = upCastResolved
                end

                result = checker:Check(resolved, actual, implicit, false)
            end

        else
            result = checker:Check(formal, actual, implicit, false)
        end
        return result
    end

    /*
        This action returns a type resolution for the generic in this passed
        formal parameter. If the generic type is invalid, at the wrong index, 
        or otherwise detected as incorrect, an error is returned in the
        GenericResolution class. If the generic is correct, a Type is returned
        in the GenericResolution that matches the declared generic.
    */
    private action ResolveGenericParameter(Action act, ActionCall call, Type formal) returns GenericResolution
        GenericResolution generic
        if formal:IsMappedToGeneric()
            generic:hasGeneric = true
            Type mappedType
            //Variable classInstance = call:variable
            Type classInstance = call:calledOnType
            
            //if this is null, it's a compiler bug, or a compiler error?
            if classInstance = undefined
                Type type
                type:SetToObject(type:OBJECT_KEY)
                generic:resolvedType = type
            else
                Type declaredGenericFormal = classInstance//:GetType()
                text mappedName = formal:GetMappedGeneric()

                if HasGeneric(mappedName)
                    integer index = GetIndexOfGeneric(mappedName)
                    integer numGenerics = declaredGenericFormal:GetNumberGenerics()
                    if index not= -1
                        if index >= numGenerics 
                            CompilerError error
                            error:SetLocation(call)
                            CompilerErrorType errorType
                            errorType:SetCurrentType(errorType:MISMATCHED_TEMPLATES)
                            error:SetCompilerErrorType(errorType)
                            error:SetErrorMessage("I found an action with a declared generic of " +
                                mappedName + ", which is at position " + index + 
                                " in the class " + declaredGenericFormal:GetStaticKey() + "." +
                                " However, no generic was declared in the variable " + 
                                classInstance:GetStaticKey() + ".")
                            error:SetLocation(call)
                            generic:error = error
                        else
                            Type gen = declaredGenericFormal:GetGeneric(index)
                            generic:resolvedType = gen                            
                        end
                    end
                end
            end
        else
            
        end
        return generic
    end

    action SetPackage(QualifiedName pack)
        packageName = pack:Copy()
        CalculateStaticKey()
    end

    action Compare(Object object) returns integer
        Class right = cast(Class, object)
        text l = GetStaticKey()
        text r = right:GetStaticKey()

        if l < r
            return -1
        elseif l = r
            return 0
        else
            return 1
        end
    end
//
//    action Compare(Object object) returns CompareResult
//        CompareResult result
//        Class right = cast(Class, object)
//        text l = GetStaticKey()
//        text r = right:GetStaticKey()
//
//        if l < r
//            result:result = result:SMALLER
//        elseif l = r
//            result:result = result:EQUAL
//        else
//            result:result = result:LARGER
//        end
//        return result
//    end
end
