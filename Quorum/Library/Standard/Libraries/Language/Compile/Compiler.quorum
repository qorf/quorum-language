package Libraries.Language.Compile

use Libraries.System.File
use Libraries.Language.Compile.Symbol.all
use Libraries.Language.Compile.Library
use Libraries.Containers.HashTable
use Libraries.Containers.Array
use Libraries.Containers.Iterator
use Libraries.Language.Compile.Translate.JarGenerator
use Libraries.Containers.List
use Libraries.Language.Compile.Translate.ClassOpcode
use Libraries.System.DateTime
use Libraries.Language.Compile.Documentation.DocumentationGenerator
use Libraries.Language.Compile.Parsing.QuorumLexer
use Libraries.Language.Compile.Parsing.QuorumParser
use Libraries.Language.Compile.Context.StartContext
use Libraries.Language.Compile.CompilerErrorCodes
use Libraries.Language.Support.TextBuilder

class Compiler
    public constant number VERSION = 12.3
    File main = undefined
    File outputFolder = undefined
    File pluginFolder = undefined
    File dependencyFolder = undefined
    constant text DEFAULT_BUILD_FOLDER = "Build"
    constant text DEFAULT_RUN_FOLDER = "Run"
    constant text DEFAULT_STANDARD_LIBRARY_FOLDER = "Library/Standard"
    constant text WEB_DIRECTORY = "WEB-INF/classes"
    constant text DOCUMENTATION_FOLDER = "Documents/"
    constant text OBJECT = "Libraries.Language.Object"
    constant text JAR_DEPENDENCY_FOLDER = "libraries"
    File buildFolder = undefined
    File runFolder = undefined
    File standardLibraryFolder = undefined
    HashTable<text, Dependency> dependencies
    boolean isWebApplication = false
    text name = "Default"
    text convertedJavaScript = ""
    public constant integer JAVA_BYTECODE = 0
    public constant integer JAVASCRIPT = 1
    public constant integer DOCUMENT = 2
    public constant integer PYTHON = 3
    boolean hasScannedStandardLibrary = false

    integer currentOutputType = 0
    boolean outputSpeechCommands = true
    boolean containsSpeechCommandInCompile = false
    CompilerProfiler profiler
    Array<File> additionalPluginFolders
    Array<File> additionalJarFiles
    boolean hasBeenCompiled = false
    boolean writeJavaScriptToDisk = true
    boolean writePythonToDisk = true
    CodeCompletionHandler codeCompletionhandler
    DocumentationGenerator documentationGenerator
    CompilerErrorCodes compilerCodes

    Library standardLibrary

    action GetStandardLibrary returns Library
        return standardLibrary
    end

    action SetStandardLibrary(Library library) 
        standardLibrary = library
    end

    action IsWritingJavaScriptToDisk returns boolean
        return writeJavaScriptToDisk
    end

    action SetWritingJavaScriptToDisk(boolean write)
        writePythonToDisk = write
    end

    action IsWritingPythonToDisk returns boolean
        return writePythonToDisk
    end

    action SetWritingPythonToDisk(boolean write)
        writePythonToDisk = write
    end

    action HasSpeechCallInCompile returns boolean
        return containsSpeechCommandInCompile
    end

    action SetOutputSpeech(boolean doSay)
        outputSpeechCommands = doSay
    end

    action GetOutputSpeech returns boolean
        return outputSpeechCommands
    end

    action LoadDependency(text from, text to)
        Dependency dep
        dep:from = from
        dep:to = to
        dependencies:Add(from, dep)
    end

    /* This action sets what kind of output the compiler is going to have. By default
       this returns Java bytecode.
    */
    action GetOutputType returns integer
        return currentOutputType
    end

    /*
        This action tells the compiler what kind of output to emit.
    */
    action SetOutputType(integer type)
        if type >= JAVA_BYTECODE and type <= PYTHON
            currentOutputType = type
        else
            currentOutputType = 0
        end
    end

    action GetDependencies returns Iterator<Dependency>
        return dependencies:GetValueIterator()
    end

    /*
        This action scans the system classes available and parses them appropriately.
    */
    action ScanStandardLibrary
        Library library
        File standardLibraryFolder = GetStandardLibraryFolder()
        output standardLibraryFolder:GetAbsolutePath()


        library:SetLocation(standardLibraryFolder)
        library:Scan()
        standardLibrary = library
    end

    action Parse(File file, QuorumSourceListener listener) 
        text source = file:Read()
        listener:SetFile(file)
        Parse(source, listener)
    end

    action Parse(text source, QuorumSourceListener listener)
        CompilerErrorManager errors = listener:GetCompilerErrorManager()
        QuorumLexer lexer
        lexer:SetFile(listener:GetFile())
        lexer:SetCompilerErrorManager(errors)
        lexer:Read(source)

        if not errors:IsCompilationErrorFree()
            return now
        end

        QuorumParser parser
        parser:SetCompilerErrorManager(errors)
        parser:SetLexer(lexer)
        StartContext start = parser:Start()
        if start not= undefined and errors:IsCompilationErrorFree()
            start:Traverse(listener)
        end
    end

    action ParseSandbox(text source, QuorumSourceListener listener, SymbolTable table, CompilerErrorManager errors,
        TypeChecker types, File loc)
        listener:SetSymbolTable(table)
        listener:SetCompilerErrorManager(errors)
        listener:SetTypeChecker(types)
        listener:SetFile(loc)

        if not (source = undefined)
            listener:SetSource(source)
            Parse(source, listener)
        else 
            Parse(loc, listener)
        end
    end

    /*
        This action traverses an abstract syntax tree. If there isn't one, it makes it first.
    */
    action Traverse(text source, QuorumSourceListener listener, SymbolTable table, CompilerErrorManager errors,
        TypeChecker types, File loc, CompilerResult result)
        listener:SetSymbolTable(table)
        listener:SetCompilerErrorManager(errors)
        listener:SetTypeChecker(types)
        listener:SetFile(loc)

        //first check if we already have an abstract syntax tree in this call
        //we know this is the case if the tree exists and there are no errors.
        HashTable<text, StartContext> trees = result:trees
        if trees not= undefined and loc not= undefined
            StartContext start = trees:GetValue(loc:GetAbsolutePath())
            if start not= undefined and errors:IsCompilationErrorFree()
                start:Traverse(listener)
                return now
            end
        end

        //if this is not the case
        if not (source = undefined)
            listener:SetSource(source)
        else 
            source = loc:Read()
        end 

        QuorumLexer lexer
        lexer:SetFile(listener:GetFile())
        lexer:SetCompilerErrorManager(errors)
        lexer:Read(source)

        if not errors:IsCompilationErrorFree()
            return now
        end

        QuorumParser parser
        parser:SetCompilerErrorManager(errors)
        parser:SetLexer(lexer)
        StartContext start = parser:Start()
        if start not= undefined and errors:IsCompilationErrorFree()
            trees:Add(loc:GetAbsolutePath(), start)
            start:Traverse(listener)
        end
    end
    
    action Request(CodeCompletionRequest request) returns CodeCompletionResult
        return codeCompletionhandler:Request(request)
    end


    /*  Tells the compiler to build a program, given a particular request object. 
        Request objects may contain files and other information on what is to be built.
    */
    action Compile(CompilerRequest request) returns CompilerResult
        Array<File> files = request:files
        Array<text> filesValues = request:filesValues
        HashTable<text, File> originalFileHash
        //this is only used if the standard library is not pre-scanned
        HashTable<text, File> standardLibraryFileHash
        i = 0
        repeat while i < files:GetSize()
            File next = files:Get(i)
            originalFileHash:Add(next:GetAbsolutePath(), next)
            i = i + 1
        end

        if request:recompile not= undefined
            text value = request:recompile:GetAbsolutePath()
            SymbolTable table = request:symbolTable
            if table not= undefined
                Class clazz = table:GetClassInFile(value)
                table:RemoveFile(value)

                if clazz not= undefined
                    clazz:RemoveCallLocationsFromDependencies(request:recompile)
                end
            end
        end

        Library library = request:library
        CompilerResult result
        HashTable<text, ClassOpcode> theOpcodes = undefined
        HashTable<text, Lexer> lexers = result:lexers
        lexers:Empty()
        if request:opcodes not= undefined
            theOpcodes = request:opcodes
        else 
            HashTable<text, ClassOpcode> theOpcodes2
            theOpcodes = theOpcodes2
        end

        result:opcodes = theOpcodes
        File myMain = request:main

        
        text convertedJavaScript = ""
        text convertedPython = ""
        DateTime time
        boolean containsSpeechCommandInCompile = false
        boolean outputSpeechCommands = false

        //setup sandboxed values for compilation. 
        CompilerProfiler profiler
        TypeChecker checker
        SymbolTable table

        SymbolTable previousCompile = request:symbolTable
        if previousCompile not= undefined
            table:SetTo(previousCompile)
        end

        if table:GetLibrary() = undefined
            table:SetLibrary(library)
        end

        CompilerErrorManager errors
        SymbolTable standardLibraryTable = undefined
        profiler:Empty()
        profiler:Add(time:GetEpochTime())

        //setup the compiler result to store everything that was done
        result:compilerErrorManager = errors
        result:symbolTable = table
        result:typeChecker = checker
        result:standardLibrary = library
        result:profiler = profiler

        //check if the standard library is here and that the files are valid
        boolean isInvalidCompile = false
        //if the standard library is defined, set it up. Otherwise bail
        if library = undefined
            output "I attempted to compile code without a standard library. Please report this to the development team as a bug."
            return result
        end

        if files = undefined
            isInvalidCompile = true
        elseif files:IsEmpty()
            isInvalidCompile = true
        end

        if isInvalidCompile
            CompilerError error
            error:SetCode(compilerCodes:COMPILER_BAD_FILES)
            text message = ""
            if files = undefined
                message = "I cannot compile an array of files that is passed to me undefined"
            elseif files:IsEmpty()
                message = "I cannot compile an arry of files that is empty. Please specify which files you would like compiled."
            end
            error:SetErrorMessage(message)
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_FILE)
            error:SetCompilerErrorType(t)
            error:SetLineNumber(1)
            error:SetLineNumberEnd(1)
            error:SetColumnNumber(1)
            error:SetColumnNumberEnd(1)
            errors:Add(error)
            return result
        end

        //if these values are both defined, then the user is requesting
        //that one source file, from text, be compiled
        if request:recompile not= undefined and request:recompileValue not= undefined
            table:RemoveFile(request:recompile:GetAbsolutePath())
        end

        HashTable<text, boolean> needsCompilationSet
        //parse all of the files for the first time
        i = 0
        repeat while i < files:GetSize()
            File file = files:Get(i)
            
            Parser listener
            if request:recompile not= undefined and request:recompileValue not= undefined and file:GetAbsolutePath() = request:recompile:GetAbsolutePath()
                Traverse(request:recompileValue, listener, table, errors, checker, file, result)
                needsCompilationSet:Add(file:GetAbsolutePath(), true)
            elseif not table:HasFile(file:GetAbsolutePath())
                text value = ""
                if filesValues not= undefined and filesValues:GetSize() = files:GetSize()
                    value = filesValues:Get(i)
                else
                    value = file:Read()
                end
                Traverse(value, listener, table, errors, checker, file, result)
                needsCompilationSet:Add(file:GetAbsolutePath(), true)
            end //otherwise ignore it
            i = i + 1
        end
        profiler:Add(time:GetEpochTime())
        //if the needs compilation set is null, just return because nothing 
        //needs to be done
        if needsCompilationSet:IsEmpty()
            result:symbolTable = request:symbolTable
            result:opcodes = request:opcodes
        end

        SymbolTable originalTable = table:Copy()

        //if the standard library has already been scanned, just link stuff in
        //if not, then we need to crawl the transitive dependencies
        if library:IsScanned()
            LinkToStandardLibrary(table, checker, errors, library)
        else 
            //If we haven't scanned the standard library, we need to separately compile
            //all of those files
            HashTable<text, File> allFiles = GetAllRequiredFiles(table, checker, errors, library)
            Array<File> f = allFiles:CopyToValueArray()
            //because of the standard library, do a separate mini-pass of the files
            //to compile the standard library ones and to separate the tables.
            
            SymbolTable standardLibrarySymbolTable
            i = 0
            repeat while i < f:GetSize()
                File next = f:Get(i)
                //if it's not in the original hash, it's in the standard library
                if not originalFileHash:HasKey(next:GetAbsolutePath())
                    standardLibraryFileHash:Add(next:GetAbsolutePath(), next)
                    Class clazz = table:GetClassInFile(next:GetAbsolutePath())
                    if clazz not= undefined
                        standardLibrarySymbolTable:Add(clazz)
                    end
                end
                i = i + 1
            end

            if errors:IsCompilationErrorFree()
                TypeResolution(standardLibrarySymbolTable, checker, errors)
            else 
                return result
            end

            Array<File> standardLibraryFiles = standardLibraryFileHash:CopyToValueArray()
            Array<ClassOpcode> classOpcodes
            if errors:IsCompilationErrorFree()
                i = 0
                repeat while i < standardLibraryFiles:GetSize()
                    File file = standardLibraryFiles:Get(i)
                    QuorumBytecodeListener listener
                    Traverse(undefined, listener, standardLibrarySymbolTable, errors, checker, file, result)
                    i = i + 1
                end
            end
        end

        if errors:IsCompilationErrorFree()
            SymbolTable needsTable
            //check that any of the files in the original set actually need parsing
            Iterator<text> iterator = needsCompilationSet:GetKeyIterator()
            repeat while iterator:HasNext()
                text value = iterator:Next()
                if originalTable:HasFile(value)
                    needsTable:Add(originalTable:GetClassInFile(value))
                end
            end

            TypeResolution(needsTable, checker, errors, table)
        else 
            return result
        end
        profiler:Add(time:GetEpochTime())

        //tell the type checker to use the merged symbol table on this pass
        checker:SetSymbolTable(table)
        
        if errors:IsCompilationErrorFree()
            i = 0
            repeat while i < files:GetSize() and errors:IsCompilationErrorFree()
                File file = files:Get(i)
                QuorumBytecodeListener listener
                if request:recompile not= undefined and request:recompileValue not= undefined and file:GetAbsolutePath() = request:recompile:GetAbsolutePath()
                    Traverse(request:recompileValue, listener, table, errors, checker, file, result)
                    if listener:HasSayStatementInClass()
                        containsSpeechCommandInCompile = true
                    end
                    ClassOpcode op = listener:GetClassOpcode()
                    if op not= undefined
                        op:SetBuild(buildFolder)
                        theOpcodes:Add(op:GetStaticKey(), op)
                    end
                elseif needsCompilationSet:HasKey(file:GetAbsolutePath())
                    text value = undefined
                    if filesValues not= undefined and filesValues:GetSize() = files:GetSize()
                        value = filesValues:Get(i)                        
                    else
                        value = undefined
                    end
                    Traverse(value, listener, table, errors, checker, file, result)
                    if listener:HasSayStatementInClass()
                        containsSpeechCommandInCompile = true
                    end
                    ClassOpcode op = listener:GetClassOpcode()
                    if op not= undefined
                        op:SetBuild(buildFolder)
                        theOpcodes:Add(op:GetStaticKey(), op)
                    end
                end
                i = i + 1
            end
        else 
            return result
        end
        profiler:Add(time:GetEpochTime())

        Class m = GetMainClass(myMain, table)
        if m = undefined //no class that had a main method was selected, throw an error
            AddMainError(myMain, table, errors)
        elseif m not= undefined and m:HasMainAction() = false
            AddMainError(myMain, table, errors)
        else
            m:SetIsProgramStartingClass(true)
        end
        
        boolean isMissingBuildFile = false
        //at this point, if the build is compilation free, it 
        //is guaranteed to not have compile errors, as no errors
        //can be issues in the bytecode writing stage.
        //if an error is issued, it is a bug in the compiler and not
        //an intentional design decision.
        if errors:IsCompilationErrorFree()
            if request:GetOutputType() = JAVA_BYTECODE
                //open up and begin filling the Jar
                JarGenerator generator
                text manifest = GetManifest(request, generator, table)
                //text compiledName = request:GetName(name)
                File jar = undefined
                if not request:isFastCompileRequest
                    jar = GetExecutable(request)
                    generator:SetManifest(manifest)
                    generator:Open(jar)
                end

                //iterate over all the class opcodes and write them to disk
                Iterator<ClassOpcode> codes = theOpcodes:GetValueIterator()
                repeat while codes:HasNext()
                    ClassOpcode code = codes:Next()

                    //we may not need to actually write this file, as it may
                    //already be written. If so, then toss it in 
                    //the jar
                    Class clazz = code:GetClass()
                    clazz:CalculateFieldHints(errors)
                    File filePath = clazz:GetFile()
                    text needsPath = filePath:GetAbsolutePath()
                    if not request:noWritingFiles = true
                        if needsCompilationSet:HasKey(needsPath) and not library:GetSymbolTable():HasClass(clazz:GetStaticKey())
                            code:Write()
                        else 
                            code:SetBuildPaths()
                        end
                    end
                    
                    File build = code:GetBuildFile()
                    File buildInterface = code:GetBuildInterfaceFile()

                    text key = code:GetStaticKey()

                    //in this case, the build is missing files, which means
                    //the user may have manually deleted them. We need to tell them
                    //to issue a clean and build. This error should only be issued once
                    if  (build not= undefined and not build:Exists()) or
                        (buildInterface not= undefined and not buildInterface:Exists())
                        and not isMissingBuildFile

                        CompilerError error
                        error:SetCode(compilerCodes:COMPILER_MISSING_FILE)
                        CompilerErrorType t
                        t:SetCurrentType(t:MISSING_FILE)
                        error:SetCompilerErrorType(t)
                        error:SetErrorMessage("The file " + build:GetAbsolutePath() + " was missing, which means it may have been deleted manually. Please do a clean and build.")
                        error:SetLocation(clazz)
                        errors:Add(error)
                    end

                    //if the file is not part of the standard library, 
                    //generate it
                    if not request:isFastCompileRequest
                        if not library:GetSymbolTable():HasClass(clazz:GetStaticKey())
                            and build not= undefined and build:Exists() and buildInterface not= undefined and buildInterface:Exists()
                            if build not= undefined
                                if request:IsWebRequest()
                                    text path = WEB_DIRECTORY + "/" + build:GetPath()
                                    generator:Add(build, path)
                                else 
                                    generator:Add(build)
                                end
                            end

                            if buildInterface not= undefined
                                if request:IsWebRequest()
                                    text path = WEB_DIRECTORY + "/" + buildInterface:GetPath()
                                    generator:Add(buildInterface, path)
                                else 
                                    generator:Add(buildInterface)
                                end
                            end
                        end
                    end
                end
                profiler:Add(time:GetEpochTime())

                //ok all of the classes are written in the jar. Now fill it up
                //with any dependencies that are necessary.
                //only go through this if not a fast compile
                if not request:isFastCompileRequest
                    WriteDependencies(generator, library, request)
                    generator:Close()
                end
                profiler:Add(time:GetEpochTime())
                
            elseif request:GetOutputType() = JAVASCRIPT
                //first copy all of the standard library opcodes into the array
                Array<ClassOpcode> classOpcodes = theOpcodes:CopyToValueArray()
                convertedJavaScript = CompileToJavaScript(classOpcodes, request, m)
                result:convertedJavaScript = convertedJavaScript
                if request:writeJavaScriptToDisk
                    WriteJavaScript(convertedJavaScript, request)
                end
            elseif request:GetOutputType() = PYTHON
                //This is now general purpose and calculates the transitive dependencies                
                //first copy all of the standard library opcodes into the array
                Array<ClassOpcode> classOpcodes = theOpcodes:CopyToValueArray()

                //set that it's user code
                i = 0
                repeat while i < classOpcodes:GetSize()
                    ClassOpcode co = classOpcodes:Get(i)
                    Class c = co:GetClass()
                    c:SetUserCode(true)
                    i = i + 1
                end

                /*
                    The system may not cache opcodes under the condition that 
                    it needs to conserve memory. It does this in Quorum Studio,
                    but technically any run of the compiler could. In such a case
                    it can pull the transpiled code from disk instead.
                */
                boolean cache = library:IsCachingLibraryOpcodes()
                TextBuilder builder
                Class errorClass = table:GetClass("Libraries.Language.Errors.Error")
                //it's special so shove Error in the front
                if errorClass not= undefined
                    ClassOpcode op = library:GetOpcode(errorClass:GetStaticKey())
                    if op not= undefined
                        classOpcodes:AddToFront(op)
                    elseif not cache
                        ReadPythonFile(library, errorClass, builder)
                    end
                end
             
                HashTable<text, Class> transitiveDependencies = MiniTransitiveDependency(classOpcodes)
                Iterator<Class> iterator = transitiveDependencies:GetValueIterator()
                repeat while iterator:HasNext()
                    Class cl = iterator:Next()
                    ClassOpcode op = library:GetOpcode(cl:GetStaticKey())
                    boolean includeClass = true
                    if cl:GetStaticKey() = "Libraries.Language.Errors.Error"
                        includeClass = false //error has to go first
                    end

                    if op not= undefined and includeClass
                        classOpcodes:Add(op)
                        //If it's not caching, see if we can get it from the on disk store
                    elseif not cache and includeClass
                        ReadPythonFile(library, cl, builder)
                    end
                end

                convertedPython = CompileToPython(classOpcodes, request, m)
                if not cache
                    convertedPython = builder:ToText() + convertedPython
                end
                result:convertedPython = convertedPython
                if request:writePythonToDisk
                    WritePython(convertedPython, request)
                end
            elseif request:GetOutputType() = request:DOCUMENT
                CreateDocumentation(library, theOpcodes)
            end
        end
        
        return result
    end

    private action MiniTransitiveDependency(Array<ClassOpcode> codes) returns HashTable<text, Class>
        HashTable<text, Class> ops
        i = 0
        repeat while i < codes:GetSize()
            ClassOpcode op = codes:Get(i)
            Class clazz = op:GetClass()
            
            MiniTransitiveDependency(clazz, ops)
            i = i + 1
        end

        return ops
    end

    private action MiniTransitiveDependency(Class clazz, HashTable<text, Class> ops)
        if not ops:HasKey(clazz:GetStaticKey())
            ops:Add(clazz:GetStaticKey(), clazz)
        end

        Iterator<Class> uses = clazz:GetValidUses()
        repeat while uses:HasNext()
            Class dependency = uses:Next()
            if not ops:HasKey(dependency:GetStaticKey())
                MiniTransitiveDependency(dependency, ops)
            end
        end
    end

    private action ReadPythonFile(Library library, Class cl, TextBuilder builder)
        text path = library:GetPythonPath()
        text pythonPath = cl:GetStaticKey():Replace(".", "/") + ".py"
        File pythonReadFile
        pythonReadFile:SetWorkingDirectory(path)
        pythonReadFile:SetPath(pythonPath)
        if pythonReadFile:Exists()
            text value = pythonReadFile:Read()
            builder:Append(value + value:GetLineFeed())
        end
    end

    private action CreateDocumentation(Library library, HashTable<text, ClassOpcode> opcodes)
        documentationGenerator:SetRunFolder(runFolder)
        documentationGenerator:Write(library, opcodes, false)
    end

    action TypeResolution(SymbolTable table, TypeChecker types, CompilerErrorManager errors, SymbolTable fullCompilation)
        Iterator<Class> classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()
            next:ResolveUseStatements(fullCompilation, errors)
        end
        
        classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()

            //because of the way the parent flattening algorithm works,
            //classes may already be resolved
            if not next:IsResolved()
                next:ResolveAllTypes(fullCompilation, errors)
            end
        end

        classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()
            next:ComputeVirtualActionTable(errors)
            next:ComputeGenericsTables(errors)
            types:Add(next)
        end
    end

    private action WritePython(text value, CompilerRequest request)
        //check if the run folder is there.
        File run = GetRunFolder()
        if run not=undefined
            if not run:Exists()
                run:CreateDirectories()
            end

            File pythonFile
            pythonFile:SetWorkingDirectory(run:GetAbsolutePath())
            pythonFile:SetPath(GetName() + ".py")

            //if the file already exists, delete it
            if pythonFile:Exists()
                pythonFile:Delete()
            end

            pythonFile:Write(value)
        end
    end

    private action WriteJavaScript(text value, CompilerRequest request)
        //check if the run folder is there.
        File run = GetRunFolder()
        if run not=undefined
            if not run:Exists()
                run:CreateDirectories()
            end

            File jsFile
            jsFile:SetWorkingDirectory(run:GetAbsolutePath())
            jsFile:SetPath(GetName() + ".js")
            jsFile:Write(value)

            File jsSTLCopyLocation
            jsSTLCopyLocation:SetWorkingDirectory(run:GetAbsolutePath())
            jsSTLCopyLocation:SetPath("QuorumStandardLibrary.js")

            //now copy the standard library            
            File loc = request:library:GetLocation()
            loc = loc:GetParentDirectory()
            File jsStandardLibrary
            jsStandardLibrary:SetWorkingDirectory(loc:GetAbsolutePath())
            jsStandardLibrary:SetPath("Compiled/Run/QuorumStandardLibrary.js")
            jsStandardLibrary:Copy(jsSTLCopyLocation)

            File jsFontsCopyLocation
            jsFontsCopyLocation:SetWorkingDirectory(run:GetAbsolutePath())
            
            jsStandardLibrary:SetPath("Compiled/Run/load.js")
            jsFontsCopyLocation:SetPath("load.js")
            jsStandardLibrary:Copy(jsFontsCopyLocation)

            jsStandardLibrary:SetPath("Compiled/Run/load.wasm")
            jsFontsCopyLocation:SetPath("load.wasm")
            jsStandardLibrary:Copy(jsFontsCopyLocation)

            jsStandardLibrary:SetPath("Compiled/Run/load.data")
            jsFontsCopyLocation:SetPath("load.data")
            jsStandardLibrary:Copy(jsFontsCopyLocation)
        
            text readMeText = 
"
For this default file to run, the bottom of the Quorum generated JavaScript, this:

var $starter = new quorum_Main_();
$starter.Main();
OuTpUt_$tRiNg_;

Must be replaced with this function:

function Start()
{
    var $starter = new quorum_Main_();
    $starter.Main();
    OuTpUt_$tRiNg_;
}

There are many ways to load canvases and this is provided only as an exemplar. 
"
            text dq = readMeText:GetDoubleQuote()
            text testHTML = 
"
<!DOCTYPE html>
<html>
    <head>
        <title>Test Web Application</title>
        <meta charset=" + dq + "UTF-8" + dq + ">
        <meta name="+ dq +"viewport" + dq +"content="+ dq +"width=device-width, initial-scale=1.0"+ dq +">
        <style>
            html, body, #QuorumUIRoot {
                position: absolute;
                left: 0;
                bottom: 0;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
        </style>
        <script src = "+ dq +"QuorumStandardLibrary.js"+ dq +"></script>
        <script src = "+ dq + GetName() + ".js"+ dq +"></script>
    </head>
    <body>
        <div id="+ dq +"QuorumUIContainer"+ dq +"></div>
        <script type="+ dq +"text/javascript"+ dq +">
            var Module = {
                onRuntimeInitialized: function () {
                    Start();
                    console.log("+ dq +"start()"+ dq +");
            }
        };
            </script>
            <script type="+ dq +"application/javascript"+ dq +" src="+ dq +"load.js"+ dq +"></script>
    </body>
</html>
"
            File readMeFile
            readMeFile:SetWorkingDirectory(run:GetAbsolutePath())
            readMeFile:SetPath("README.txt")
            readMeFile:Write(readMeText)

            File htmlFile
            htmlFile:SetWorkingDirectory(run:GetAbsolutePath())
            htmlFile:SetPath(GetName() + ".html")
            htmlFile:Write(testHTML)
        end
    end

    /*
        This action returns a profiler that has tracked information about 
        each phase of a compile as it goes. 
    */
    action GetCompilerProfiler returns CompilerProfiler
        return profiler
    end

    /*
        This action adds a directory of plugins to be written to the output jar
    */ 
    action AddPluginFolder(File file)
        if file:IsDirectory()
            additionalPluginFolders:Add(file)
        end
    end

    action EmptyAdditionalPluginFolders
        additionalPluginFolders:Empty()
    end

    action EmptyAdditionalJars
        additionalJarFiles:Empty()
    end

    /*
        This action checks if this is a jar file and then adds it as a dependency.
    */
    action AddJar(File file)
        text extension = file:GetFileExtension()
        if extension = "jar"
            additionalJarFiles:Add(file)
        end
    end

    // A convenience action used to write jars to disk.
    private action WriteJarToDisk(File file)
        File copyLocation
        File run = GetRunFolder()
        copyLocation:SetWorkingDirectory(run:GetWorkingDirectory())
        copyLocation:SetPath(run:GetPath() + "/" + JAR_DEPENDENCY_FOLDER + "/")


        if not copyLocation:Exists()
            copyLocation:CreateDirectories()
        end

        copyLocation:SetPath(run:GetPath() + "/" + JAR_DEPENDENCY_FOLDER + "/" + file:GetFileName())
        // Check if the jar already exists. If it does, we leave it as is.
        if not copyLocation:Exists()
            file:Copy(copyLocation)
        end
    end

    private action WriteDependencies(JarGenerator generator, Library library, CompilerRequest request)
        File libraryLocation = library:GetLocation()
        if not additionalPluginFolders:IsEmpty()
            Iterator<File> it = additionalPluginFolders:GetIterator()
            repeat while it:HasNext()
                File folder = it:Next()
                WritePlugins(generator, folder, folder, request)
            end
        end

        //copy any jar files that are dependencies to disk
        if not additionalJarFiles:IsEmpty()
            Iterator<File> jars = additionalJarFiles:GetIterator()
            repeat while jars:HasNext()
                File file = jars:Next()
                WriteJarToDisk(file)
            end
        end

        File compiledStandardLibraryFolder
        compiledStandardLibraryFolder:SetWorkingDirectory(libraryLocation:GetParentDirectory():GetAbsolutePath() + "/Compiled/")
        compiledStandardLibraryFolder:SetPath("Run")
        
        if request:IsWebRequest()
            File servlet
            servlet:SetWorkingDirectory(libraryLocation:GetAbsolutePath() + "/Plugins/web/")
            servlet:SetPath("WEB-INF/classes/web/servlet/Processor.class")
            generator:Add(servlet)

            File glassfish
            glassfish:SetWorkingDirectory(libraryLocation:GetAbsolutePath() + "/Plugins/web/")
            glassfish:SetPath("WEB-INF/glassfish-web.xml")
            generator:Add(glassfish)

            File web
            web:SetWorkingDirectory(libraryLocation:GetAbsolutePath() + "/Plugins/web/")
            web:SetPath("WEB-INF/web.xml")
            generator:Add(web)

            File context
            context:SetWorkingDirectory(libraryLocation:GetAbsolutePath() + "/Plugins/web/")
            context:SetPath("META-INF/context.xml")
            generator:Add(context)

            File stdlib
            stdlib:SetWorkingDirectory(libraryLocation:GetParentDirectory():GetAbsolutePath() + "/Compiled/Run/")
            stdlib:SetPath("QuorumStandardLibrary.jar")
            generator:Add(stdlib, "WEB-INF/lib/QuorumStandardLibrary.jar")

            File stdplug
            stdplug:SetWorkingDirectory(libraryLocation:GetParentDirectory():GetAbsolutePath() + "/Compiled/Run/")
            stdplug:SetPath("QuorumStandardPlugins.jar")
            generator:Add(stdplug, "WEB-INF/lib/QuorumStandardPlugins.jar")
        end

        CopyMissingFiles(compiledStandardLibraryFolder, runFolder)
    end


    /*
    Copy all files from the first directory into the second directory. If the
    second directory already contains any files from the first directory, they
    are skipped rather than overwritten.
    */
    private action CopyMissingFiles(File copyFrom, File copyTo)
        if not copyTo:Exists()
            copyTo:CreateDirectories()
        end
        
        //get all the files in this folder and copy them over
        Array<File> files = copyFrom:GetDirectoryListing()
        Iterator<File> it = files:GetIterator()
        repeat while it:HasNext()
            File file = it:Next()
            if not file:IsHidden()

                File next
                next:SetWorkingDirectory(copyTo:GetAbsolutePath() + "/")
                next:SetPath(file:GetPath())
                if file:IsFile()
                    // If it doesn't already exist, copy the file.
                    if not next:Exists()
                        file:Copy(next)
                    end
                elseif file:IsDirectory()
                    recursiveCopyDirectory(file, next)
                end
            end
        end
    end

    private action recursiveCopyDirectory(File from, File to) 
        if not to:Exists()
            to:CreateDirectories()
        end
        Array<File> files = from:GetDirectoryListing()
        Iterator<File> it = files:GetIterator()
        repeat while it:HasNext()
            File next = it:Next()
            if not next:IsHidden()
                if next:IsFile()
                    File copyTo
                    copyTo:SetWorkingDirectory(to:GetAbsolutePath() + "/")
                    copyTo:SetPath(next:GetPath())

                    DateTime fileTime = next:GetLastModifiedDate()
                    DateTime nextTime = copyTo:GetLastModifiedDate()

                    //if it doesn't exist, copy the file
                    if not copyTo:Exists()
                        next:Copy(copyTo)
                    else
                        //if it does exist
                        if fileTime:GetEpochTime() > nextTime:GetEpochTime()
                            next:Copy(copyTo)
                        end
                    end
                elseif next:IsDirectory()
                    File copyTo
                    copyTo:SetWorkingDirectory(to:GetAbsolutePath() + "/")
                    copyTo:SetPath(next:GetPath())
                    if not copyTo:Exists()
                        copyTo:CreateDirectories()
                    end
                    recursiveCopyDirectory(next, copyTo)
                end
            end
        end
    end

    private action WritePlugins(JarGenerator generator, File file, File originalLocation, CompilerRequest request)
        if file:IsDirectory()
            Array<File> files = file:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()

            repeat while it:HasNext()
                File f = it:Next()
                if not f:IsHidden() and not (f:GetFileExtension() = "DS_Store")
                    WritePlugins(generator, f, originalLocation, request)
                end
            end
        else
            text pluginPath = originalLocation:GetWorkingDirectory()
            text path = file:GetAbsolutePath()
            path = path:GetSubtext(pluginPath:GetSize())
            text wd = file:GetAbsolutePath()
            boolean finished = true

            //if there's a slash at the end of the path, ignore it.
            if pluginPath:GetCharacter(pluginPath:GetSize() - 1) = "/"
                wd = wd:GetSubtext(0, pluginPath:GetSize() - 1)
                finished = false
            end

            if finished
                wd = wd:GetSubtext(0, pluginPath:GetSize())
            end

            File f
            f:SetWorkingDirectory(wd)
            f:SetPath(path)
            if request:IsWebRequest()
                text newPath = WEB_DIRECTORY + "/" + f:GetPath()
                generator:Add(f, newPath)
            else 
                generator:Add(f)
            end
        end
    end

    private action GetManifest(CompilerRequest request, JarGenerator jar, SymbolTable table) returns text
        text version = jar:GetManifestVersion() + ": 1.0"
        line = version:GetCarriageReturn() + version:GetLineFeed()
        version = version + line
        
        
        text created = "Created-By: " + me:GetVersion()
        created = created + line

        text main = jar:GetManifestMainClass()

        File mainFile = request:main
        Class mainClass = me:GetMainClass(mainFile, table)
        text classKey = "quorum." + mainClass:GetStaticKey()
        main = main + ": " + classKey
        main = main + line

        SymbolTable symbolTable = table
        boolean usesLWJGL = symbolTable:HasClass("Libraries.Sound.Audio") or symbolTable:HasClass("Libraries.Game.Game")

        Iterator<Class> tempIterator = symbolTable:GetClassesInPackage("Libraries.Robots.Lego")
        boolean hasRobots = false
        if tempIterator not= undefined
            hasRobots = tempIterator:HasNext()
        end

        //now write any jar dependencies into the manifest
        //if not additionalJarFiles:IsEmpty() or usesLWJGL or hasRobots
        Iterator<File> jars = additionalJarFiles:GetIterator()
        text classpath = "Class-Path: "
        text libraries = JAR_DEPENDENCY_FOLDER

        classpath = classpath + "QuorumStandardLibrary.jar"
        classpath = classpath + " QuorumStandardPlugins.jar"

        boolean isFirst = true
        if not additionalJarFiles:IsEmpty()
            repeat while jars:HasNext()
                File file = jars:Next()
                classpath = classpath + " " + libraries + "/" + file:GetFileName()
                isFirst = false
            end
        end
        main = main + classpath + line

        total = version + created + main + line
        return total
    end

    private action AddMainError(File starter, SymbolTable table, CompilerErrorManager errors)
        CompilerError error
        error:SetCode(compilerCodes:COMPILER_BAD_STARTING_POINT)
        text message = "I noticed that the class " + starter:GetPath() 
            +   " was specified as the starting point for this program, " 
            + "but it does not have an action named Main. " 

        Class clazz = table:GetClassInFile(starter:GetAbsolutePath())
        if clazz not= undefined
            if clazz:GetAction("main") not= undefined
                message = message + "This class does have an action named "
                    + "main, with a lower case m, did you mean for it to be "
                    + "capitalized?"
            end
        end
        error:SetErrorMessage(message)
        CompilerErrorType t
        t:SetCurrentType(t:MISSING_MAIN)
        error:SetCompilerErrorType(t)
        error:SetFile(starter)
        error:SetLineNumber(1)
        error:SetLineNumberEnd(1)
        error:SetColumnNumber(1)
        error:SetColumnNumberEnd(1)
        errors:Add(error)
    end

    private action CompileToPython(Array<ClassOpcode> classOpcodes, CompilerRequest request, Class mainClass) returns text
        text result = ""
        text plugins = ""
        text main = ""
        Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
        repeat while codes:HasNext()
            ClassOpcode code = codes:Next()
            Class clazz = code:GetClass()

            //Class mainClazz = mainClass
            text mainClazzName = mainClass:GetStaticKey()
            text clazzName = clazz:GetStaticKey()
            if mainClass:GetStaticKey() = clazzName
                main = code:WritePython()
            else
                result = result + code:WritePython()
            end

            //check if this class has a plugin. If it does, include it.
            if clazz:HasSystemAction()
                File folder = GetStandardLibraryFolder() 
                path = folder:GetPath() + "/Plugins/python/"

                key = clazz:GetStaticKey()
                Array<text> keys = key:Split("\.")
                i = 0
                repeat keys:GetSize() times
                    newKey = keys:Get(i)
                    if i = keys:GetSize() - 1
                        path = path + newKey + ".py"
                    else
                        path = path + newKey + "/"
                    end
                    i = i + 1
                end
                File location
                location:SetWorkingDirectory(folder:GetWorkingDirectory())
                location:SetPath(path)
                if location:Exists() 
                    value = location:Read()
                    plugins = plugins + value + value:GetCarriageReturn() + value:GetLineFeed()
                end
            end
        end
        return plugins + result + main
    end

    private action CompileToJavaScript(Array<ClassOpcode> classOpcodes, CompilerRequest request, Class mainClass) returns text
        text result = ""
        text plugins = ""
        text main = ""

        if request:mainOnlyJavaScript
            Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
            repeat while codes:HasNext()
                ClassOpcode code = codes:Next()
                Class clazz = code:GetClass()
    
                //Class mainClazz = mainClass
                text mainClazzName = mainClass:GetStaticKey()
                text clazzName = clazz:GetStaticKey()
                if mainClass:GetStaticKey() = clazzName
                    main = code:WriteJavaScript()
                    if clazz:HasSystemAction()
                        File folder = GetStandardLibraryFolder() 
                        path = folder:GetPath() + "/Plugins/javascript/"
        
                        key = clazz:GetStaticKey()
                        Array<text> keys = key:Split("\.")
                        i = 0
                        repeat keys:GetSize() times
                            newKey = keys:Get(i)
                            if i = keys:GetSize() - 1
                                path = path + newKey + ".js"
                            else
                                path = path + newKey + "/"
                            end
                            i = i + 1
                        end
                        File location
                        location:SetWorkingDirectory(folder:GetWorkingDirectory())
                        location:SetPath(path)
                        if location:Exists() 
                            value = location:Read()
                            plugins = plugins + value + value:GetCarriageReturn() + value:GetLineFeed()
                        end
                    end
                end
            end
            return plugins + result + main
        end
        Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
        repeat while codes:HasNext()
            ClassOpcode code = codes:Next()
            Class clazz = code:GetClass()

            //Class mainClazz = mainClass
            text mainClazzName = mainClass:GetStaticKey()
            text clazzName = clazz:GetStaticKey()
            if mainClass:GetStaticKey() = clazzName
                main = code:WriteJavaScript()
            else
                result = result + code:WriteJavaScript()
            end

            //check if this class has a plugin. If it does, include it.
            if clazz:HasSystemAction()
                File folder = GetStandardLibraryFolder() 
                path = folder:GetPath() + "/Plugins/javascript/"

                key = clazz:GetStaticKey()
                Array<text> keys = key:Split("\.")
                i = 0
                repeat keys:GetSize() times
                    newKey = keys:Get(i)
                    if i = keys:GetSize() - 1
                        path = path + newKey + ".js"
                    else
                        path = path + newKey + "/"
                    end
                    i = i + 1
                end
                File location
                location:SetWorkingDirectory(folder:GetWorkingDirectory())
                location:SetPath(path)
                if location:Exists() 
                    value = location:Read()
                    plugins = plugins + value + value:GetCarriageReturn() + value:GetLineFeed()
                end
            end
        end
        return plugins + result + main
    end

    action TypeResolution(SymbolTable table, TypeChecker types, CompilerErrorManager errors)
        Iterator<Class> classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()
            next:ResolveUseStatements(table, errors)
        end

        classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()

            //because of the way the parent flattening algorithm works,
            //classes may already be resolved
            if not next:IsResolved()
                next:ResolveAllTypes(table, errors)
            end
        end

        classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()
            next:ComputeVirtualActionTable(errors)
            next:ComputeGenericsTables(errors)
            types:Add(next)
        end
    end

    private action TypeResolution(SymbolTable table, TypeChecker types, CompilerErrorManager errors, Array<Class> justTheseClasses)
        Iterator<Class> classes = justTheseClasses:GetIterator()
        repeat while classes:HasNext()
            Class next = classes:Next()
            next:ResolveUseStatements(table, errors)
        end

        classes = justTheseClasses:GetIterator()
        repeat while classes:HasNext()
            Class next = classes:Next()

            //because of the way the parent flattening algorithm works,
            //classes may already be resolved
            if not next:IsResolved()
                next:ResolveAllTypes(table, errors)
            end
        end

        classes = justTheseClasses:GetIterator()
        repeat while classes:HasNext()
            Class next = classes:Next()
            next:ComputeVirtualActionTable(errors)
            next:ComputeGenericsTables(errors)
            types:Add(next)
        end
    end

    private action LinkToStandardLibrary(SymbolTable table, TypeChecker types, CompilerErrorManager errors, Library library)
        Iterator<Class> classes = table:GetClasses()
        Array<Class> copy
        repeat while classes:HasNext()
            Class clazz = classes:Next()
            copy:Add(clazz)
        end

        classes = copy:GetIterator()
        
        //gather up all the classes on the system and check their
        //use statements for classes we don't know about
        //if there are some, mark them as unparsed
        HashTable<text, text> resolvedPackages

        repeat while classes:HasNext()
            Class clazz = classes:Next()
            File classFile = clazz:GetFile()
            text path = classFile:GetAbsolutePath()
            Iterator<QualifiedName> names = clazz:GetUnresolvedUseStatements()
            repeat while names:HasNext()
                QualifiedName qn = names:Next()
                if qn:IsAll()
                    ResolveAllClassesInContainer(table, qn, library, resolvedPackages, errors)
                else
                    text key = qn:GetStaticKey()
                    ResolveClass(table, key, clazz, library, errors)
                end
            end

            //now check the package we are in to see if there's anything
            //in this package we need to include
            QualifiedName pack = clazz:GetPackage()
            ResolveAllClassesInContainer(table, pack, library, resolvedPackages, errors)

            names:Rewind()
            ResolveQualifiedNames(table, names, clazz, library, resolvedPackages, errors)

            Iterator<QualifiedName> parents = clazz:GetUnresolvedParents()
            ResolveParents(table, parents, clazz, library, errors)

            ResolveBlocks(table, clazz, library, errors)
        end

        //now get any transitive dependencies in the standard library. There is no need
        //to resolve them here, we just need to know what they are.
        Array<Class> dependencies
        Iterator<Class> iterator = table:GetClasses()
        repeat while iterator:HasNext()
            Class clazz = iterator:Next()
            dependencies:Add(clazz)
        end

        i = 0
        repeat while i < dependencies:GetSize()
            Class clazz = dependencies:Get(i)
            text key = clazz:GetStaticKey()
            if not table:HasClass(key)
                table:Add(clazz)
            end

            //now get all the valid uses and add them
            Iterator<Class> uses = clazz:GetValidUses()
            repeat while uses:HasNext()
                Class next = uses:Next()
                text nextKey = next:GetStaticKey()
                if not table:HasClass(nextKey)
                    table:Add(next)
                    //this wasn't in the list, so check its dependencies as well
                    dependencies:Add(next)
                end
            end

            QualifiedName pack = clazz:GetPackage()
            ResolveAllClassesInContainer(table, pack, library, resolvedPackages, errors)

            Iterator<QualifiedName> parents = clazz:GetUnresolvedParents()
            ResolveParents(table, parents, clazz, library, errors)

            ResolveBlocks(table, clazz, library, errors)
            i = i + 1
        end

        //now that we have the table, we need to add everything to the type checker
        iterator = table:GetClasses()
        repeat while iterator:HasNext()
            Class clazz = iterator:Next()
            types:Add(clazz)
        end
    end

    private action ResolveBlocks(SymbolTable table, Class clazz, Library library, CompilerErrorManager errors)
        
        Iterator<Action> actions = clazz:GetActions()
        repeat while actions:HasNext()
            Action act = actions:Next()
            //resolve parameters first
            Iterator<Variable> parameters = act:GetParameterIterator()
            repeat while parameters:HasNext()
                Variable parameter = parameters:Next()
                Type type = parameter:GetType()
                ResolveClass(table, type:GetStaticKey(), clazz, library, errors)
            end
        end
    end

    private action ResolveParents(SymbolTable table, Iterator<QualifiedName> names, 
            Class clazz, Library library, CompilerErrorManager errors)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            text key = qn:GetStaticKey()
            ResolveClass(table, key, clazz, library, errors)
        end
    end

    private action ResolveQualifiedNames(SymbolTable table, Iterator<QualifiedName> names, 
        Class clazz, Library library, HashTable<text, text> resolvedPackages, CompilerErrorManager errors)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            if qn:IsAll()
                ResolveAllClassesInContainer(table, qn, library, resolvedPackages, errors)
            else
                text key = qn:GetStaticKey()
                ResolveClass(table, key, clazz, library, errors)
            end
        end
    end

    private action ResolveAllClassesInContainer(SymbolTable table,
            QualifiedName name, Library library, HashTable<text, text> resolvedPackages, CompilerErrorManager errors)
        //Get the container name without the "all" at the end
        text value = ""

        if not name:IsEmpty()
            value = name:GetStaticKeyNoAll()
        end

        if resolvedPackages:HasKey(value) //already resolved, so skip it
            return now
        else
            resolvedPackages:Add(value, value)
        end


        SymbolTable standardLibrary = library:GetSymbolTable()
        Iterator<Class> iterator = table:GetClassesInPackage(value)

        boolean processedClass = false
        if iterator not= undefined
            processedClass = true
            repeat while iterator:HasNext()
                Class clazz = iterator:Next()
                if not table:HasClass(clazz:GetStaticKey())
                    table:Add(clazz)
                end
            end
        end

        iterator = standardLibrary:GetClassesInPackage(value)
        if iterator not= undefined
            processedClass = true
            repeat while iterator:HasNext()
                Class clazz = iterator:Next()
                if not table:HasClass(clazz:GetStaticKey())
                    table:Add(clazz)
                end
            end
        end
        if not processedClass
            CompilerError error
            error:SetCode(compilerCodes:COMPILER_BAD_PACKAGE)
            error:SetErrorMessage("I noticed a package named " + value + 
                " was referenced, but I cannot find any record of it.")
            error:SetLocation(name)
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_CLASS)
            error:SetCompilerErrorType(t)
            errors:Add(error)
            return now
        end
        
    end

    private action ResolveClass(SymbolTable table, text key, Class clazz, Library library, CompilerErrorManager errors)
        if table:HasClass(key)
            return now
        end

        boolean done = false
        Class c = undefined

        Type typeCheck
        typeCheck:SetToObject(key)
        //is this really just a primitive, pretending to be a class?
        if typeCheck:IsPrimitive()
            return now
        end


        //first check if it's already valid by looking at the symbol
        //table
        c = table:GetClass(key)

        //if it isn't there, check our use table
        if c = undefined
            c = clazz:GetValidUseName(key)
        end

//        //if it isn't there, check the standard library
        SymbolTable standardLibrary = library:GetSymbolTable()
        c = standardLibrary:GetClass(key)

        if c not= undefined
            table:Add(c) //this was already checked to ensure it wasn't in the table.
        end
    end

    /*
        This action is called after the parsing phase, returning an array
        of all files were required for building the project.
    */
    action GetAllRequiredFiles(SymbolTable table, TypeChecker types, 
        CompilerErrorManager errors, Library library) returns HashTable<text, File>
        Array<File> files

        HashTable<text, File> parsed
        HashTable<text, File> unparsed

        Iterator<Class> classes = table:GetClasses()
        repeat while classes:HasNext()
            //gather up all the classes on the system and check their
            //use statements for classes we don't know about
            //if there are some, mark them as unparsed
            repeat while classes:HasNext()
                Class clazz = classes:Next()
                File classFile = clazz:GetFile()
                text path = classFile:GetAbsolutePath()
                if not parsed:HasKey(path)
                    parsed:Add(path, clazz:GetFile())
                end
                Iterator<QualifiedName> names = clazz:GetUnresolvedUseStatements()
                ResolveQualifiedNames(table, names, parsed, unparsed, clazz)

                Iterator<QualifiedName> parents = clazz:GetUnresolvedParents()
                ResolveParents(table, parents, parsed, unparsed, clazz)

                ResolveBlocks(table, parsed, unparsed, clazz)
                ResolveFields(table, parsed, unparsed, clazz)
            end

            //make list of any new classes that need to be analyzed
            //that have not previously been parsed. If there are some
            //send them back through the loop
            List<Class> newClasses
            Iterator<File> mustParse = unparsed:GetValueIterator()
            repeat while mustParse:HasNext()
                File next = mustParse:Next()
                Parser listener
                text null = undefined
                ParseSandbox(null, listener, table, errors, types, next)
                parsed:Add(next:GetAbsolutePath(), next)

                Iterator<Class> parsedClasses = listener:GetClassesIterator()
                repeat while parsedClasses:HasNext()
                    Class clazz = parsedClasses:Next()
                    newClasses:Add(clazz)
                    if not table:HasClass(clazz:GetStaticKey())
                        table:Add(clazz)
                    end
                end
            end
            classes = newClasses:GetIterator()
            unparsed:Empty()
        end
        return parsed
    end

    private action ResolveFields(SymbolTable table, HashTable<text, File> parsed,
        HashTable<text, File> unparsed, Class clazz)
        
        Iterator<Variable> variables = clazz:GetVariables()
        repeat while variables:HasNext()
            Variable var = variables:Next()
            Type type = var:GetType()
            ResolveClass(table, type:GetStaticKey(), clazz, parsed, unparsed)
        end
    end

    private action ResolveBlocks(SymbolTable table, HashTable<text, File> parsed,
        HashTable<text, File> unparsed, Class clazz)
        
        Iterator<Action> actions = clazz:GetActions()
        repeat while actions:HasNext()
            Action act = actions:Next()
            //resolve parameters first
            Iterator<Variable> parameters = act:GetParameterIterator()
            repeat while parameters:HasNext()
                Variable parameter = parameters:Next()
                Type type = parameter:GetType()
                ResolveClass(table, type:GetStaticKey(), clazz, parsed, unparsed)
            end

            Block value = act:GetBlock()
            if value not= undefined
                ResolveBlock(value, table, parsed, unparsed, clazz)
            end
        end
    end

    private action ResolveBlock(Block block, SymbolTable table, HashTable<text, File> parsed,
        HashTable<text, File> unparsed, Class clazz)
        
        Iterator<Variable> variables = block:GetVariables()
        repeat while variables:HasNext()
            Variable var = variables:Next()
            Type type = var:GetType()
            if type not= undefined
                ResolveClass(table, type:GetStaticKey(), clazz, parsed, unparsed)
            end
        end

        Iterator<Block> blocks = block:GetBlocks()
        repeat while blocks:HasNext()
            Block nestedBlock = blocks:Next()
            ResolveBlock(nestedBlock, table, parsed, unparsed, clazz)
        end
    end
    /*
        This action handles resolving a class or otherwise scheduling a parse
        from the standard library. If a class is returned, then it has
        already been parsed and is in the symbol table. If the class
        returns is undefined, then either the class does not exist or 
        it is in the standard library and has not yet been parsed. As such,
        returning undefined is not necessarily a compiler error.
    */
    private action ResolveClass(SymbolTable table, text key, Class clazz, HashTable<text, File> parsed,
        HashTable<text, File> unparsed)
        boolean done = false
        Class c = undefined

        Type typeCheck
        typeCheck:SetToObject(key)
        //is this really just a primitive, pretending to be a class?
        if typeCheck:IsPrimitive()
            return now
        end


        //first check if it's already valid by looking at the symbol
        //table
        c = table:GetClass(key)

        //if it isn't there, check our use table
        if c = undefined
            c = clazz:GetValidUseName(key)
        end

        //if it isn't there, check the standard library, to 
        //see if there's a file in the right place
        //if there is, mark it for parsing
        if c = undefined
            File file = GetStandardLibraryFile(key, clazz:GetPackageKey())
            if file not= undefined
                text newPath = file:GetAbsolutePath()
                if parsed:HasKey(newPath) //this class has already been parsed
                elseif unparsed:HasKey(newPath) //this class is already scheduled for parsing
                else
                    unparsed:Add(newPath, file)
                end
            else //ok last chance. Check an unresolved use statement to
                 //see if one of these reference the standard library
                 QualifiedName qn = clazz:GetUnresolvedUseStatement(key)
                 if qn not= undefined
                    file = GetStandardLibraryFile(qn:GetStaticKey(), clazz:GetPackageKey())
                    if file not= undefined
                        text newPath = file:GetAbsolutePath()
                        if parsed:HasKey(newPath) //this class has already been parsed
                        elseif unparsed:HasKey(newPath) //this class is already scheduled for parsing
                        else
                            unparsed:Add(newPath, file)
                        end
                    end
                 end
            end
        end
    end

    private action ResolveParents(SymbolTable table, Iterator<QualifiedName> names, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            text key = qn:GetStaticKey()
            ResolveClass(table, key, clazz, parsed, unparsed)
        end
    end

    private action ResolveQualifiedNames(
            SymbolTable table, 
            Iterator<QualifiedName> names, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            if qn:IsAll()
                ResolveAllClassesInContainer(table, qn, parsed, unparsed, clazz)
            else
                text key = qn:GetStaticKey()
                ResolveClass(table, key, clazz, parsed, unparsed)
            end
        end
    end

    private action ResolveAllClassesInContainer(SymbolTable table,
            QualifiedName name, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        //Get the container name without the "all" at the end
        File folder = GetStandardLibraryFolderForPackage(name:GetStaticKeyNoAll())

        //check if this is the standard library. If so, load them all into unparsed
        //if they aren't already in there or in parsed
        if folder not= undefined
            Array<File> files = folder:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()
            repeat while it:HasNext()
                File file = it:Next()
                text path = file:GetAbsolutePath()
                if not file:IsDirectory() and not parsed:HasKey(path) and not unparsed:HasKey(path)
                    and file:GetFileExtension() = "quorum" and not table:HasFile(file:GetAbsolutePath())
                    unparsed:Add(path, file)
                end
            end
        end
    end

    private action GetStandardLibraryFolderForPackage(text key) returns File
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            standardLibraryFolder = build
        end
        text loc = standardLibraryFolder:GetWorkingDirectory()
        text loc2 = standardLibraryFolder:GetAbsolutePath()

        File file
        file:SetWorkingDirectory(loc2)

        Array<text> values = key:Split("\.")

        text location = "/"
        Iterator<text> it = values:GetIterator()
        repeat while it:HasNext()
            text next = it:Next()
            location = location + next

            if it:HasNext()
                location = location + "/"
            end
        end

        file:SetPath(location)
        if file:Exists()
            return file
        end
        return undefined
    end

    action GetStandardLibraryFile(text key, text fromPackage) returns File
        Array<text> values = key:Split("\.")
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            standardLibraryFolder = build
        end
        text loc = standardLibraryFolder:GetWorkingDirectory()
        text loc2 = standardLibraryFolder:GetAbsolutePath()

        File file
        file:SetWorkingDirectory(loc2)

        if values:GetSize() = 1
            text mySplit = "/" + fromPackage:Replace(".", "/") + "/" + key + ".quorum"
            file:SetPath(mySplit)
            if file:Exists()
                return file
            end
        else
            text location = "/"
            Iterator<text> it = values:GetIterator()
            repeat while it:HasNext()
                text next = it:Next()
                location = location + next

                if it:HasNext()
                    location = location + "/"
                else
                    location = location + ".quorum"
                end
            end

            file:SetPath(location)
            if file:Exists()
                return file
            end
        end
        
        return undefined
    end

    action GetName returns text
        return name
    end

    action SetName(text name)
        me:name = name
    end

    action GetMainClass(File theMain, SymbolTable table) returns Class
        if theMain not= undefined and table not= undefined
            text path = theMain:GetAbsolutePath()
            Class c = table:GetClassInFile(path)
            return c
        end
        
        return undefined
    end

    action GetVersion returns text
        return "Quorum " + VERSION
    end

    action GetOutputFolder returns File
        return outputFolder
    end

    action SetOutputFolder(File file)
        if file not= undefined
            outputFolder = file
            text path = file:GetAbsolutePath()

            if not file:Exists()
                file:CreateDirectories()
            end

            File build
            build:SetWorkingDirectory(path)
            build:SetPath(DEFAULT_BUILD_FOLDER)
            buildFolder = build

            File run 
            run:SetWorkingDirectory(path)
            run:SetPath(DEFAULT_RUN_FOLDER)
            me:runFolder = run
        else
            File root
            outputFolder = root
        end
    end

    action GetBuildFolder returns File
        return buildFolder
    end

    action GetStandardLibraryFolder returns File
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            return build
        end
        return standardLibraryFolder
    end

    action SetStandardLibraryFolder(File file)
        standardLibraryFolder = file
        File f
        f:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
        f:SetPath("plugins")
        pluginFolder = f

        File f2
        f2:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
        f2:SetPath("org")
        dependencyFolder = f2
    end

    action GetExecutable(CompilerRequest request) returns File
        File run = GetRunFolder()
        text path = run:GetPath() + "/"
        File newRun
        newRun:SetWorkingDirectory(run:GetWorkingDirectory())
        text value = request:GetName(name)
        newRun:SetPath(path + value)
        return newRun
    end

    action GetRunFolder returns File
        return runFolder
    end
end
