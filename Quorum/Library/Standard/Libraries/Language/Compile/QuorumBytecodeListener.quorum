package Libraries.Language.Compile

use Libraries.Language.Compile.Context.all
use Libraries.Language.Compile.Translate.JavaBytecodeClassWriter
use Libraries.Language.Compile.Translate.JavaBytecodeMethodWriter
use Libraries.Language.Compile.Translate.QuorumBytecodeConverter
use Libraries.Language.Compile.Translate.JavaBytecodeOpcodes
use Libraries.Language.Compile.Symbol.all
use Libraries.Language.Compile.Translate.all
use Libraries.Language.Compile.Hints.all

use Libraries.Containers.Array
use Libraries.Containers.List
use Libraries.Containers.HashTable
use Libraries.Containers.Iterator
use Libraries.System.File
use Libraries.Containers.Stack

class QuorumBytecodeListener is QuorumSourceListener 
    QualifiedName packageValue = undefined
    JavaBytecodeClassWriter classWriter = undefined
    JavaBytecodeClassWriter interfaceWriter = undefined
    JavaBytecodeMethodWriter methodWriter = undefined
    JavaBytecodeMethodWriter interfaceMethodWriter = undefined

    QuorumBytecodeConverter converter
    JavaBytecodeOpcodes opcodes
    Action currentAction = undefined
    ActionOpcode currentActionOpcode = undefined
    ClassOpcode currentClassOpcode = undefined
    boolean isInAction = false

    Class currentClass = undefined
    Block currentBlock = undefined
    Block recentlyPoppedBlock = undefined
    constant integer ME = 0
    text build = "TestBuild"
    text run = "TestRun"
    constant text QUORUM = "quorum"

    constant text JAVA_THROWABLE = "java/lang/Throwable"
    constant text JAVA_OBJECT = "java/lang/Object"
    constant text QUORUM_ERROR = "quorum/Libraries/Language/Errors/Error"
    boolean isNormalAction = false
    boolean isSystemAction = false
    boolean isBluePrintAction = false
    boolean isNextVariableReferenceMe = false
    Stack<QuorumOpcode> opcodeStack
    Stack<CheckDetectOpcode> checkStack
    Stack<ConditionalOpcode> ifStack
    Stack<LoopOpcode> loopStack
    Stack<ParentVariableFunctionCallContext> parentCallStack
    File buildFile = undefined
    File buildInterfaceFile = undefined
    BlockOpcode currentBlockOpcode = undefined
    Stack<BlockOpcode> poppedBlockOpcodes
    Stack<BlockOpcode> currentBlocks
    Stack<integer> blockPositionStack
    Stack<ActionExpressionListContext> actionCallParameterStack
    HashTable<integer, Array<ActionCallOpcode>> actionCallStacks
    integer currentActionStack = 0
    integer loopCounter = 0
    integer ifCount = 0
    integer checkCount = 0
    boolean isInAlwaysBlock = false
    boolean recentStatementWasReturn = false
    boolean hasSayStatement = false

    private action HasErrors returns boolean
        CompilerErrorManager manager = GetCompilerErrorManager()
        File file = currentClass:GetFile()
        key = file:GetAbsolutePath()

        if manager:HasErrorsAtKey(key)
            return true
        end
        return false
    end

    /*
        This returns true if a say statement exists within this class.
    */
    action HasSayStatementInClass returns boolean
        return hasSayStatement
    end

    action GetClassOpcode returns ClassOpcode
        return currentClassOpcode
    end

    action GetBuildFile returns File
        return buildFile
    end

    action GetBuildInterfaceFile returns File
        return buildInterfaceFile
    end
    
    private action SetNormalAction 
        isNormalAction = true
        isSystemAction = false
        isBluePrintAction = false
    end

    private action SetSystemAction 
        isNormalAction = false
        isSystemAction = true
        isBluePrintAction = false
    end

    private action SetBlueprintAction 
        isNormalAction = false
        isSystemAction = false
        isBluePrintAction = true
    end

    private action ClearActionState
        isNormalAction = false
        isSystemAction = false
        isBluePrintAction = false
    end

    action ExitPackageRule(PackageContext context) 
        packageValue = context:name
        if packageValue not= undefined
            packageValue:SetLocation(context:GetLocation())
        end
    end

    action EnterFullClassDeclaration(FullClassDeclarationContext context) 
        AddClass(context:className)
    end

    private action AddClass(text className) 
        JavaBytecodeClassWriter newClassWriter
        JavaBytecodeClassWriter newIinterfaceWriter

        classWriter = newClassWriter
        interfaceWriter = newIinterfaceWriter
        ClassOpcode classOp
        currentClassOpcode = classOp

        text name = className
        SymbolTable table = me:GetSymbolTable()
        currentClassOpcode:SetSymbolTable(table)

        text staticKey = ""
        if packageValue = undefined
            QualifiedName default
            packageValue = default
        end
        staticKey = packageValue:GetClassStaticKey(name)
        currentClass = table:GetClass(staticKey)
        currentClassOpcode:SetClass(currentClass)
        currentClassOpcode:SetName(name)
        currentClassOpcode:SetStaticKey(staticKey)
        currentClassOpcode:SetPackage(packageValue)
        currentClassOpcode:SetClassWriter(classWriter)
        currentClassOpcode:SetInterfaceWriter(interfaceWriter)

        if currentClass not= undefined
            Iterator<Class> iterator = currentClass:GetValidUses()
            repeat while iterator:HasNext()
                Class clazz = iterator:Next()
                clazz:RemoveUseLocations(currentClass:GetFile())
            end
        end
    end

    action EnterNoActionsNoClass(NoActionsNoClassContext context) 
        File file = GetFile()
        text name = file:GetFileName()
        text extension = file:GetFileExtension()
        integer length = extension:GetSize()
        name = name:GetSubtext(0, name:GetSize() - length - 1)
        AddClass(name)


        if currentClass not= undefined
            //get the method name
            Array<Variable> vars
            Iterator<Variable> paramIt = vars:GetIterator()
            text key = currentClass:ResolveActionKey("Main", paramIt,
                GetSymbolTable(), GetCompilerErrorManager())

            Action method = currentClass:GetAction(key)
            currentAction = method
            ActionOpcode actionOpcode
            actionOpcode:SetLocation(context:GetLocation())
            currentActionOpcode = actionOpcode
            currentActionOpcode:SetAction(method)
            currentActionOpcode:SetClass(currentClass)

            boolean isMain = method:IsMain()
            text null = undefined
            text actionName = method:GetName()
            text params = method:ConvertActionToBytecodeParameterInterfaceSignature()
            methodWriter = 
                classWriter:VisitMethod(opcodes:GetPublic(), 
                actionName, params, null, undefined)
            currentActionOpcode:SetMethodWriter(methodWriter)
            currentClassOpcode:Add(currentActionOpcode)


            BlockContext b
            Location loc = b:GetLocation()
            loc:SetLocation(context:GetLocation())
            EnterBlock(b)
            isInAction = true
        end
    end

    action EnterActionsNoClass(ActionsNoClassContext context) 
        File file = GetFile()
        text name = file:GetFileName()
        text extension = file:GetFileExtension()
        integer length = extension:GetSize()
        name = name:GetSubtext(0, name:GetSize() - length - 1)
        AddClass(name)
    end

    action ExitActionsNoClass(ActionsNoClassContext context) 
        ExitClass()
    end

    action ExitNoActionsNoClass(NoActionsNoClassContext context) 
        BlockContext b
        Location loc = b:GetLocation()
        loc:SetLocation(context:GetLocation())
        ExitBlock(b)


        ActionContext actContext
        loc = actContext:GetLocation()
        loc:SetLocation(context:GetLocation())
        ExitAction(actContext)
        ExitClass()
    end

    action ExitClass
        if currentClass not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            if manager:IsCompilationErrorFree()
                currentClass:ResolveFrames()
            end
        end
    end

    action ExitFullClassDeclaration(FullClassDeclarationContext context) 
        ExitClass()
    end

    action ExitActionHeader(ActionContext context)
        if currentClass not= undefined
            //get the method name
            List<Variable> list = context:parameters
            Iterator<Variable> paramIt = list:GetIterator()
            text key = currentClass:ResolveActionKey(context:actionName, paramIt,
                GetSymbolTable(), GetCompilerErrorManager())

            Action method = currentClass:GetAction(key)
            Location returnLocation = context:returnLocation
            if returnLocation not= undefined
                method:SetReturnLocation(returnLocation)
                Type returnType = method:GetReturnType()
                if returnType not= undefined
                    if not returnType:IsPrimitive()
                        text returnKey = returnType:GetStaticKey()
                        SymbolTable table = GetSymbolTable()
                        Class clazz = table:GetClass(returnKey)
                        if clazz not= undefined
                            clazz:AddUseLocation(returnLocation:CreateLocationCopy())
                        else 
                            CompilerError e
                            e:SetErrorMessage("Could not find the class  " + returnKey +
                                " used in the return statement.")
                            CompilerErrorType t
                            t:SetCurrentType(t:MISSING_CLASS)
                            e:SetCompilerErrorType(t)
                            e:SetLocation(context:GetLocation())
                            CompilerErrorManager manager = GetCompilerErrorManager()
                            manager:Add(e)
                        end
                    end
                end
            end

            currentAction = method
            ActionOpcode actionOpcode
            actionOpcode:SetLocation(context:GetLocation())
            currentActionOpcode = actionOpcode
            currentActionOpcode:SetAction(method)
            currentActionOpcode:SetClass(currentClass)

            boolean isMain = method:IsMain()
            text null = undefined
            text name = method:GetName()
            text params = method:ConvertActionToBytecodeParameterInterfaceSignature()
            methodWriter = 
                classWriter:VisitMethod(opcodes:GetPublic(), 
                name, params, null, undefined)
            currentActionOpcode:SetMethodWriter(methodWriter)
            currentClassOpcode:Add(currentActionOpcode)
        end
    end

    action EnterConstructor(ConstructorContext context) 
        currentAction = currentClass:GetConstructor()
        isInAction = true

        ActionOpcode actionOpcode
        actionOpcode:SetLocation(context:GetLocation())
        currentActionOpcode = actionOpcode
        currentActionOpcode:SetAction(currentAction)
        currentActionOpcode:SetClass(currentClass)
        currentActionOpcode:SetMethodWriter(methodWriter)
        currentActionOpcode:SetIsConstructor(true)
        currentClassOpcode:SetConstructor(currentActionOpcode)
    end

    action ExitConstructor(ConstructorContext context) 
        ClearActionState()
        
        if currentActionOpcode not= undefined
            if not poppedBlockOpcodes:IsEmpty()
                currentActionOpcode:Add(poppedBlockOpcodes:Pop())
            end

            //if there are opcodes on the opcode stack for a return, pop them
            //there should never be more than 1, so throw an error if there is
            remaining = opcodeStack:GetSize()
            if remaining not= 0
                if remaining not= 1
                    //alert("Compiler Bug: Cannot have more than 1 remaining opcode on the opcode stack at the end of an action.")
                else 
                    QuorumOpcode op = opcodeStack:Pop()
                    currentActionOpcode:Add(op)
                end
            end
        end
        currentAction = undefined
        currentActionOpcode = undefined
        isInAction = false
    end

    action EnterAction(ActionContext context) 
        SetNormalAction()
        isInAction = true
    end

    action ExitAction(ActionContext context) 
        ClearActionState()
        
        if currentActionOpcode not= undefined
            Location location = context:GetLocation()
            currentActionOpcode:SetLocation(location)
            if not poppedBlockOpcodes:IsEmpty()
                currentActionOpcode:Add(poppedBlockOpcodes:Pop())
            end

            //if there are opcodes on the opcode stack for a return, pop them
            //there should never be more than 1, so throw an error if there is
            remaining = opcodeStack:GetSize()
            if remaining not= 0
                if remaining not= 1
                    //alert("Compiler Bug: Cannot have more than 1 remaining opcode on the opcode stack at the end of an action.")
                else 
                    QuorumOpcode op = opcodeStack:Pop()
                    currentActionOpcode:Add(op)
                end
            end
        end
        isInAction = false

        Block block = currentAction:GetBlock()

        boolean satisfied = block:HasReturnThisBlock()
        Type returnType = currentAction:GetReturnType()
        //if we don't have a void function, make sure that there is a return
        //either in a top level block or all appropriate sub-blocks
        if not returnType:IsVoid() and not satisfied
            CompilerError e
            e:SetErrorMessage("The action " + currentAction:GetStaticKey() +
                " is missing a return statement.")
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_RETURN)
            e:SetCompilerErrorType(t)
            e:SetLocation(context:GetLocation())
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(e)
        end
    end

    action ExitAlertStatement(AlertContext context)
        recentStatementWasReturn = true
        QuorumOpcode op = opcodeStack:Pop()
        if op = undefined
            return now //This cannot be determined, but the error has been issued already.
        end
        AlertOpcode al
        al:SetLocation(context:GetLocation())
        al:SetOpcode(op)
        al:SetMethodWriter(methodWriter)

        Type type = op:GetType()
        if type = undefined
            return now //This cannot be determined, but the error has been issued already.
        end
        key = type:GetStaticKey()
        boolean isText = type:IsText()
        boolean isErrorType = false
        //if it isn't text, it better be either Object or a subclass

        SymbolTable table = GetSymbolTable()
        Class clazz = table:GetClass(key)
        if clazz not= undefined
            if clazz:IsError()
                isErrorType = true
            end
        end

        if not isText and not isErrorType
            CompilerError error
            error:SetErrorMessage("The alert was passed type " + key + 
                ". Alert can only accept text, objects of type Libraries.Language.Errors.Error, or subclasses of Error.")
            error:SetLocation(context:GetLocation())
            CompilerErrorType t
            t:SetCurrentType(t:INCOMPATIBLE_TYPES)
            error:SetCompilerErrorType(t)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
        end
        currentBlockOpcode:Add(al)
    end

    action ExitIs(IsContext context) 
        QualifiedName name = context:name
        //now resolve the name from the current class
        key = name:GetStaticKey()
        Type right
        right:SetToObject(key)
        CompilerErrorManager manager = GetCompilerErrorManager()
        errors = manager:GetErrorAmount()
        currentClass:ResolveType(context:GetLocation(), right, GetSymbolTable(), manager)
        //check if there was an error. If so, ignore the rest.
        errors2 = manager:GetErrorAmount()

        if errors = errors2
            //now check to see if it's even possible that this type "is" the other type
            TypeChecker checker = GetTypeChecker()
            Operation operation
            operation:SetOperation(operation:IS)

            QuorumOpcode op = opcodeStack:Pop()
            if op = undefined
                return now
            end
            Type left = op:GetType()
            TypeCheckResult result = checker:Check(left, right, operation)

            if result:errorType = undefined
                IsOpcode opcode = cast(IsOpcode, result:GetQuorumOpcode())
                opcode:SetCastTo(right)
                text newKey = right:GetStaticKey()
                SymbolTable table = GetSymbolTable()
                Class cl = table:GetClass(newKey)
                if cl not= undefined
                    if cl:IsError()
                        opcode:SetIsErrorCast(true)
                    end
                end //should this be an error, or is it already caught?

                opcode:SetOpcode(op)
                opcode:SetMethodWriter(methodWriter)
                opcodeStack:Push(opcode)
            else
                IsOpcode isOpcode //empty, but we're throwing an error anyway
                opcodeStack:Push(isOpcode)

                CompilerError error = result:GetCompilerError(context:GetLocation())
                manager:Add(error)
            end
        end
    end

    action ExitOutputStatement(OutputContext context)
        QuorumOpcode op = opcodeStack:Pop()
        if op = undefined
            return now //This cannot be determined, but the error has been issued already.
        end
        Type type = op:GetType()

        if type = undefined
            return now //This cannot be determined, but the error has been issued already.
        end
        if type:IsPrimitive()
            OutputOpcode out
            out:SetLocation(context:GetLocation())
            out:SetOpcode(op)
            out:SetMethodWriter(methodWriter)
            currentBlockOpcode:Add(out)
        else
            CompilerError error
            error:SetLocation(context:GetLocation())
            error:SetErrorMessage("Output can only use integer, text, number, or boolean types.")
            CompilerErrorType t
            t:SetCurrentType(t:INCOMPATIBLE_TYPES)
            error:SetCompilerErrorType(t)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
        end
    end

    action ExitSayStatement(SayContext context)
        QuorumOpcode op = opcodeStack:Pop()
        if op = undefined
            return now //This cannot be determined, but the error has been issued already.
        end
        Type type = op:GetType()

        if type = undefined
            return now //This cannot be determined, but the error has been issued already.
        end

        if type:IsPrimitive()
            SayOpcode out
            out:SetLocation(context:GetLocation())
            hasSayStatement = true

            out:SetOpcode(op)
            out:SetMethodWriter(methodWriter)
            currentBlockOpcode:Add(out)
        else
            CompilerError error
            error:SetLocation(context:GetLocation())
            error:SetErrorMessage("Say can only use integer, text, number, or boolean types.")
            CompilerErrorType t
            t:SetCurrentType(t:INCOMPATIBLE_TYPES)
            error:SetCompilerErrorType(t)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
        end
    end

    action EnterBlock(BlockContext context)
        if currentBlock = undefined
            currentBlock = currentAction:GetBlock()
            blockPositionStack:Push(0)
        else 
            integer value = blockPositionStack:Pop()
            if value < currentBlock:GetSubBlockSize()
                currentBlock = currentBlock:GetBlock(value)
                blockPositionStack:Push(value + 1)
                //now push on a 0 for the new block
                blockPositionStack:Push(0)
            else 
                alert("Compiler Bug in EnterBlock of the Type Check Listener.")
            end
        end

        if currentBlockOpcode = undefined
            BlockOpcode block
            block:SetMethodWriter(methodWriter)
            currentBlockOpcode = block
            currentBlocks:Push(block)
        else
            BlockOpcode block
            block:SetMethodWriter(methodWriter)
            block:SetParentBlock(currentBlockOpcode)
            currentBlockOpcode = block
            currentBlocks:Push(block)
        end
        currentBlockOpcode:SetBlock(currentBlock)
    end
    
    action ExitBlock(BlockContext context)
        if currentBlock not= undefined
            recentlyPoppedBlock = currentBlock
            currentBlock = currentBlock:GetParentBlock() //may be undefined
            blockPositionStack:Pop()
        end

        if currentBlockOpcode not= undefined
            BlockOpcode op = currentBlocks:Pop()
            poppedBlockOpcodes:Push(op)
            if currentBlocks:IsEmpty()
                currentBlockOpcode = undefined
            else
                currentBlockOpcode = currentBlocks:Peek()
            end
        end
    end

    action EnterLoopStatement(LoopContext context) 
        LoopOpcode loop
        loop:SetLocation(context:GetLocation())
        loop:SetMethodWriter(methodWriter)
        if context:isUntil
            loop:SetUntil()
        elseif context:isTimes
            loop:SetTimes()
        else
            loop:SetWhile()
        end

        if context:isTimes
            constant text LOOP_NAME = "Loopy"
            constant text LOOP_NAME_RESULT = "LoopyResult"
            Variable variable = undefined
            variable = currentBlock:GetVariable(loopCounter + LOOP_NAME)
            loop:SetVariable(variable)

            Variable variable2 = undefined
            variable2 = currentBlock:GetVariable(loopCounter + LOOP_NAME_RESULT)

            loop:SetVariableTimesResult(variable2)
        end

        loopStack:Push(loop)
        loopCounter = loopCounter + 1
    end

    action ExitLoopStatement(LoopContext context) 
        LoopOpcode loop = loopStack:Pop()
        QuorumOpcode qop = opcodeStack:Pop()
        if qop = undefined
            return now
        end
        qop:SetIsIfExpression(true)
        
        Type type = qop:GetType()
        if type = undefined
            CompilerError error
            error:SetErrorMessage("The type of the loop expression is not clear.")
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:REPEAT_NON_BOOLEAN)
            error:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        if loop:IsTimes()
            if not type:IsInteger()
                CompilerError error
                error:SetErrorMessage("Repeat times can only use integers, but the type was " + type:GetStaticKey() + ".")
                error:SetLocation(context:GetLocation())
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:REPEAT_TIMES_NON_INTEGER)
                error:SetCompilerErrorType(errorType)
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end
        else
            if not type:IsBoolean()
                CompilerError error
                error:SetErrorMessage("Repeat while and until statements can only use booleans, but the type was " + type:GetStaticKey() + ".")
                error:SetLocation(context:GetLocation())
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:REPEAT_NON_BOOLEAN)
                error:SetCompilerErrorType(errorType)
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end
        end        

        loop:SetExpression(qop)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        Block value = recentlyPopped:GetBlock()
        if loop:IsTimes()
            value:SetBlockType(value:REPEAT_TIMES)
        elseif loop:IsWhile()
            value:SetBlockType(value:REPEAT_WHILE)
        else
            value:SetBlockType(value:REPEAT_UNTIL)
        end
        loop:SetBlock(recentlyPopped)
        
        currentBlockOpcode:Add(loop)
    end

    action EnterCheckStatement(CheckContext context) 
        CheckDetectOpcode ch
        ch:SetCheckLabelInteger(checkCount)
        ch:SetMethodWriter(methodWriter)
        checkCount = checkCount + 1
        checkStack:Push(ch)
    end
    
    action ExitCheckStatement(CheckContext context) 
        CheckDetectOpcode checkOp = checkStack:Pop()
        checkOp:SetLocation(context:GetLocation())
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        checkOp:SetBlock(recentlyPopped)
        Block value = recentlyPopped:GetBlock()
        value:SetBlockType(value:CHECK)
        currentBlockOpcode:Add(checkOp)
        checkCount = checkCount + 1
    end

    action EnterDetectStatement(DetectStatementContext context) 
    end

    action ExitDetectStatement(DetectStatementContext context) 
        CheckDetectOpcode checkOp = checkStack:Peek()
        DetectBlockOpcode op
        op:SetLocation(context:GetLocation())
        op:SetMethodWriter(methodWriter)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        op:SetBlock(recentlyPopped)
        Block value = recentlyPopped:GetBlock()
        value:SetBlockType(value:DETECT)
        integer loc = recentlyPoppedBlock:GetBytecodeLocation()
        Type type

        List<QualifiedName> parents = context:parents

        if parents:IsEmpty()
            QualifiedName error
            error:Add("Libraries")
            error:Add("Language")
            error:Add("Errors")
            error:Add("Error")


            SymbolTable table = GetSymbolTable()
            Class clazz = table:GetClass("Libraries.Language.Errors.Error")
            op:AddDetect(clazz)
            checkOp:SetErrorClass(clazz)

            boolean hasError = checkOp:HasErrorDetectBlock()
            if not hasError
                checkOp:AddDetectBlockType(error:GetStaticKey(), op)
                checkOp:SetErrorDetectBlock(op)
            else
                CompilerError e
                e:SetErrorMessage("There are two places where " +
                    "Libraries.Language.Errors.Error is detected. This is not allowed because there is no " +
                    "way to determine where the program would jump to if this type of error happened.")
                CompilerErrorType t
                t:SetCurrentType(t:INVALID_ERROR)
                e:SetCompilerErrorType(t)
                e:SetLocation(context:GetLocation())
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(e)
            end
        else
            Iterator<QualifiedName> it = parents:GetIterator()
            boolean hasError = false
            repeat while it:HasNext()
                QualifiedName name = it:Next()

                //check to make sure this is valid in the current class.
                Class clazz = currentClass:GetValidUseName(name:GetStaticKey())
                if clazz = undefined
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    CompilerErrorType t
                    t:SetCurrentType(t:MISSING_CLASS)
                    error:SetCompilerErrorType(t)
                    error:SetErrorMessage("I could not locate the class named " +
                        name:GetStaticKey() + ". Did you spell it correctly?")
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                end

                //now make sure that this class inherits from Error
                if not clazz:HasParentClass(type:ERROR_KEY)
                   and clazz:GetStaticKey() not= type:ERROR_KEY
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    CompilerErrorType t
                    t:SetCurrentType(t:INVALID_ERROR)
                    error:SetCompilerErrorType(t)
                    error:SetErrorMessage("The class '" + clazz:GetStaticKey() +
                        "' exists, but it must inherit from Libraries.Language.Errors.Error." )
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                end

                //and now check that this class's key isn't already in the check
                //block
                if checkOp:HasDetectBlockType(clazz:GetStaticKey())
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    CompilerErrorType t
                    t:SetCurrentType(t:INVALID_ERROR)
                    error:SetCompilerErrorType(t)
                    error:SetErrorMessage("There are two places where " +
                    clazz:GetStaticKey() + " is detected. This is not allowed because there is no " +
                    "way to determine where the program would jump to if this type of error happened.")
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                end

                //this detect block has a generic error. Take note of that.
                if clazz:GetStaticKey() = "Libraries.Language.Errors.Error"
                    checkOp:SetErrorClass(clazz)
                    hasError = true
                end

                checkOp:AddDetectBlockType(clazz:GetStaticKey(), op)
                op:AddDetect(clazz)

                if hasError
                    checkOp:SetErrorDetectBlock(op)
                end
            end
        end

        //get the exception variable from the block
        Variable exceptionVariable = recentlyPoppedBlock:GetExceptionVariable()
        op:SetExceptionVariable(exceptionVariable)
        checkOp:AddDetectBlock(op)
    end

    action EnterAlwaysStatement(AlwaysStatementContext context)
        isInAlwaysBlock = true
    end

    action ExitAlwaysStatement(AlwaysStatementContext context) 
        CheckDetectOpcode checkOp = checkStack:Peek()

        DetectBlockOpcode op
        op:SetLocation(context:GetLocation())
        op:SetMethodWriter(methodWriter)
        op:SetIsAlways(true)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        Variable exceptionVariable = recentlyPoppedBlock:GetExceptionVariable()
        op:SetExceptionVariable(exceptionVariable)
        op:SetBlock(recentlyPopped)
        Block value = recentlyPopped:GetBlock()
        value:SetBlockType(value:ALWAYS)

        checkOp:SetAlwaysBlock(op)
        isInAlwaysBlock = false
    end

    action EnterIfStatement(IfContext context) 
        ConditionalOpcode conditional
        conditional:SetIfLabelInteger(ifCount)
        conditional:SetMethodWriter(methodWriter)

        ifCount = ifCount + 1
        ifStack:Push(conditional)
    end
    

    action ExitIfStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Pop()
        QuorumOpcode qop = opcodeStack:Pop()

        if qop = undefined //there is a problem and we have previously thrown a compiler error
            return now
        end
        Type type = qop:GetType()
        if type = undefined
            CompilerError error
            error:SetErrorMessage("If can only use booleans, but the type is unknown.")
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:IF_INVALID_EXPRESSION)
            error:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        elseif not type:IsBoolean()
            CompilerError error
            error:SetErrorMessage("If can only use booleans, but the type is " + type:GetStaticKey() + ".")
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:IF_INVALID_EXPRESSION)
            error:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        qop:SetIsIfExpression(true)
        conditional:SetExpression(qop)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        conditional:SetBlock(recentlyPopped)
        Block value = recentlyPopped:GetBlock()
        value:SetBlockType(value:IF)

        Type t = currentAction:GetReturnType()
        if not t:IsVoid()
            boolean isFullySatisfied = true
            //is the return condition satisfied for all of the if statement?
            //for this to be true, it must have an else, and all if-else combos
            //must also have a return

            //check all my blocks to make sure we satisfy a return
            Block ifBlock = recentlyPopped:GetBlock()
            if not ifBlock:HasReturnThisBlock()
                isFullySatisfied = false
            end

            //get all of the elseif blocks and check them too
            Iterator<BlockOpcode> ops = conditional:GetElseIfBlockIterator()
            repeat while ops:HasNext()
                BlockOpcode op = ops:Next()
                Block elseIfBlock = op:GetBlock()
                if not elseIfBlock:HasReturnThisBlock()
                    isFullySatisfied = false
                end
            end

            BlockOpcode elseOp = conditional:GetElseBlock()
            if elseOp = undefined
                isFullySatisfied = false
            else
                Block elseBlock = elseOp:GetBlock()
                if not elseBlock:HasReturnThisBlock()
                    isFullySatisfied = false
                end
            end
            if isFullySatisfied //we can't do anything past this point.
                //currentBlock:SetReturnThisBlock(true)
                recentStatementWasReturn = true
            end
        end

        currentBlockOpcode:Add(conditional)
    end

    action EnterElseIfStatement(IfContext context) end
    action ExitElseIfStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Peek()
        QuorumOpcode qop = opcodeStack:Pop()
        if qop = undefined
            return now
        end

        Type type = qop:GetType()
        if type = undefined
            CompilerError error
            error:SetErrorMessage("If can only use booleans, but the type is unknown.")
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:IF_INVALID_EXPRESSION)
            error:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        elseif not type:IsBoolean()
            CompilerError error
            error:SetErrorMessage("If can only use booleans, but the type is " + type:GetStaticKey() + ".")
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:IF_INVALID_EXPRESSION)
            error:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end



        qop:SetIsIfExpression(true)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        Block value = recentlyPopped:GetBlock()
        value:SetBlockType(value:ELSE_IF)
        conditional:AddElseIf(qop, recentlyPopped)
    end

    action EnterElseStatement(IfContext context) end
    action ExitElseStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Peek()
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        Block value = recentlyPopped:GetBlock()
        value:SetBlockType(value:ELSE)
        conditional:SetElseBlock(recentlyPopped)
    end

    action ExitObjectAssignment(ObjectAssignmentContext context) 
        text name = context:name       
        text object = context:object
        QualifiedName theParent = context:parentName
        CompilerErrorManager manager = GetCompilerErrorManager()

        Variable variable = undefined
        Variable field = undefined
        Class clazz = undefined
        Class fieldHolder = undefined
        if not isInAction
            variable = currentClass:GetVariable(object)
        else 
            variable = currentBlock:GetVariable(object)
        end

        if variable not= undefined
            Location useLocation
            useLocation:SetLocation(context:objectLocation)
            variable:AddUseLocation(useLocation)
        end


        //this is an assignment to a field in a parent
        if theParent not= undefined
            //get the full static key of the parent
            Type type = variable:GetType()
            text staticKey = type:GetStaticKey()
            SymbolTable table = GetSymbolTable()
            TypeChecker checker = GetTypeChecker()
            Class baseClass = table:GetClass(staticKey)

            //this class exists, otherwise we would have thrown an error already
            //now get the resolved static key of the parent
            

            Type resolvedType
            resolvedType:SetToObject(theParent:GetStaticKey())
            currentClass:ResolveType(context:GetLocation(), resolvedType, table, manager)

            hasParent = baseClass:HasParentClass(resolvedType:GetStaticKey())
            if not hasParent
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_PARENT)
                error:SetCompilerErrorType(t)
                text message = "I could not locate a parent class named " + resolvedType:GetStaticKey() + "."
                error:SetErrorMessage(message)
                manager:Add(error)
                return now
            end
            Class parentClass = baseClass:GetParentClass(resolvedType:GetStaticKey())
            Variable var = parentClass:GetVariable(name)
            if var = undefined
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_VARIABLE)
                error:SetCompilerErrorType(t)
                text message = "I could not find the variable " + name + " in class " + parentClass:GetStaticKey()
                error:SetErrorMessage(message)
                manager:Add(error)
                return now
            end

            if var not= undefined
                if var:IsConstant() //issue an error, this is not allowed.
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:CONSTANT_REASSIGNMENT)
                    error:SetCompilerErrorType(errorType)
                    error:SetErrorMessage("The variable " + var:GetName() + " in the parent "
                        + parentClass:GetStaticKey() + " is a constant and cannot be modified.")
                    manager:Add(error)
                end
            end

            var:SetIsDefined(true)
            Type left = var:GetType()

            QuorumOpcode right = opcodeStack:Pop()
            Operation assign
            assign:SetOperation(assign:EQUALS)

            if right = undefined //the system should have already output an error, so return
                return now
            end

            TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 
            CompilerError error = result:GetCompilerError(context:GetLocation())

            if error not= undefined
                manager:Add(error)
                return now
            end

            Type value = result:result
            QuorumOpcode qop = result:GetQuorumOpcode()
            AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
            if currentBlock = undefined
                assignment:SetIsInFieldBlock(true)
            end
            assignment:SetLocation(context:GetLocation())
            assignment:SetClass(currentClass)
            assignment:SetRightHandSide(right)
            assignment:SetType(value)
            assignment:SetMethodWriter(methodWriter)
            assignment:SetVariable(var)
            assignment:SetField(variable)
            assignment:SetParentWithField(parentClass)

            if isInAction
                currentBlockOpcode:Add(assignment)
            else //add the opcode to the field calculator
                currentClassOpcode:AddField(assignment)
            end
            return now
        else
            if variable not= undefined //if it is, it should have been caught in a previous phase
                Type type = variable:GetType()
                if not type:IsPrimitive() //if it is, again previous phase
                    text staticKey = type:GetStaticKey()
                    SymbolTable table = GetSymbolTable()
                    clazz = table:GetClass(staticKey)
                    fieldHolder = clazz

                    //get a field. It has to be there, otherwise a previous phase would have complained
                    if clazz not= undefined
                        field = clazz:GetVariable(name)
                    end

                    if field not= undefined
                        if field:IsConstant() //issue an error, this is not allowed.
                            CompilerError error
                            error:SetLocation(context:GetLocation())
                            CompilerErrorType errorType
                            errorType:SetCurrentType(errorType:CONSTANT_REASSIGNMENT)
                            error:SetCompilerErrorType(errorType)
                            error:SetErrorMessage("The variable " + field:GetName() + " in the parent "
                                + fieldHolder:GetStaticKey() + " is a constant and cannot be modified.")
                            manager:Add(error)
                            return now
                        end
                    else
                        CompilerError error
                        error:SetLocation(context:GetLocation())
                        CompilerErrorType errorType
                        errorType:SetCurrentType(errorType:MISSING_VARIABLE)
                        error:SetCompilerErrorType(errorType)
                        error:SetErrorMessage("Cannot find the variable " +
                        name + " to assign to in " + object + ", of class " + type:GetStaticKey() + ".")
                        manager:Add(error)
                        return now
                    end
                else  
                    CompilerError error
                    error:SetLocation(variable)
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:INVALID_OPERATOR)
                    error:SetCompilerErrorType(errorType)
                    error:SetErrorMessage("I cannot assign a value to a variable " +
                        "named " + variable:GetName() + " because it is of type " + type:GetStaticKey() + ", which is a primitive")
                    manager:Add(error)
                end
                variable:SetIsDefined(true)
            else 
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:MISSING_VARIABLE)
                error:SetCompilerErrorType(errorType)
                error:SetErrorMessage("Cannot assign to "
                    + object + ", in the variable "
                    + name + " because " + name + " does not exist.")
                manager:Add(error)
                return now
            end
        end

        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode implicitCast = undefined
        QuorumOpcode right2 = right

        Operation assign
        assign:SetOperation(assign:EQUALS)

        TypeChecker checker = GetTypeChecker()

        //so far as I can tell, this only happens when we have a cascading error,
        //which doesn't need to be reported to the user.
        if field = undefined
            return now
        end
        Type fieldType = field:GetType()
        if fieldType not= undefined and fieldType:IsMappedToGeneric()
            text map = fieldType:GetMappedGeneric()
            index = fieldHolder:GetIndexOfGeneric(map)
            Type type = variable:GetType()
            
            if index not= -1
                Type generic = type:GetGeneric(index)

                Operation op
                TypeCheckResult result = undefined
                if generic:IsPrimitive()
                    op:SetOperation(op:GENERIC_CAST)
                    Type newGeneric
                    newGeneric:SetToObject(generic:ConvertToNonPrimitiveStaticKey())
                    result = checker:Check(newGeneric, right:GetType(), op, false) 
                else
                    op:SetOperation(op:IMPLICIT_CAST)
                    result = checker:Check(field:GetType(), right:GetType(), op, false) 
                end
                
                CompilerError error = result:GetCompilerError(context:GetLocation())
                if error not= undefined
                    manager:Add(error)
                    return now
                end

                QuorumOpcode opcode = result:GetQuorumOpcode()
                if opcode not= undefined
                    opcode:SetLocation(context:GetLocation())
                    opcode:SetMethodWriter(methodWriter)

                    implicitCast = opcode
                    right2 = implicitCast
                end
            else
                CompilerError error
                error:SetLocation(variable)
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:MISMATCHED_TEMPLATES)
                error:SetCompilerErrorType(errorType)
                error:SetErrorMessage("Cannot assign to " 
                    + variable:GetName() + " because the generic does not match.")
                manager:Add(error)
            end
        end

        //No error is needed here because we've already caught it 
        //under other circumstances.
        if right2 = undefined
            return now
        end

        TypeCheckResult result = checker:Check(field:GetType(), right2:GetType(), undefined, true) 
        CompilerError error = result:GetCompilerError(context:GetLocation())

        if error not= undefined
            manager:Add(error)
            return now
        end

        integer location = variable:GetBytecodeLocation()
        Type value = result:result
        QuorumOpcode qop = result:GetQuorumOpcode()
        AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
        if currentBlock = undefined
            assignment:SetIsInFieldBlock(true)
        end

        assignment:SetLocation(context:GetLocation())
        assignment:SetClass(currentClass)
        assignment:SetRightHandSide(right)
        assignment:SetImplicitCast(implicitCast)
        assignment:SetFieldHolder(fieldHolder)
        assignment:SetType(value)
        assignment:SetMethodWriter(methodWriter)
        assignment:SetVariable(variable)
        assignment:SetField(field)
        assignment:SetIsObjectField(true)

        if isInAction
            currentBlockOpcode:Add(assignment)
        else //add the opcode to the field calculator
            currentClassOpcode:AddField(assignment)
        end
    end

    action ExitParentAssignment(ParentAssignmentContext context) 
        text variableName = context:name
        QualifiedName parentName = context:parentName

        SymbolTable table = GetSymbolTable()
        CompilerErrorManager manager = GetCompilerErrorManager()
        TypeChecker checker = GetTypeChecker()

        Type resolvedType
        resolvedType:SetToObject(parentName:GetStaticKey())
        currentClass:ResolveType(context:GetLocation(), resolvedType, table, manager)
        
        hasParent = currentClass:HasParentClass(resolvedType:GetStaticKey())
        if not hasParent
            CompilerError error
            error:SetLocation(context:GetLocation())
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_PARENT)
            error:SetCompilerErrorType(t)
            text message = "Could not find the parent class " + resolvedType:GetStaticKey() + "."
            error:SetErrorMessage(message)
            manager:Add(error)
            return now
        end
        Class parentClass = currentClass:GetParentClass(resolvedType:GetStaticKey())
        Variable var = parentClass:GetVariable(variableName)
        if var = undefined
            CompilerError error
            error:SetLocation(context:GetLocation())
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_VARIABLE)
            error:SetCompilerErrorType(t)
            text message = "Could not find the variable " + variableName + " in class " + parentClass:GetStaticKey()
            error:SetErrorMessage(message)
            manager:Add(error)
            return now
        end

        if var not= undefined
            if var:IsConstant() //issue an error, this is not allowed.
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:CONSTANT_REASSIGNMENT)
                error:SetCompilerErrorType(errorType)
                error:SetErrorMessage("The variable " + var:GetName() + ", in the parent "
                    + parentClass:GetStaticKey() + " is a constant and cannot be modified.")
                manager:Add(error)
            end
            var:SetIsDefined(true)
        end

        Type left = var:GetType()
        
        QuorumOpcode right = opcodeStack:Pop()
        Operation assign
        assign:SetOperation(assign:EQUALS)

        if right = undefined //the system should have already output an error, so return
            return now
        end

        TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 
        CompilerError error = result:GetCompilerError(context:GetLocation())

        if error not= undefined
            manager:Add(error)
            return now
        end

        Type value = result:result
        QuorumOpcode qop = result:GetQuorumOpcode()
        AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
        if currentBlock = undefined
            assignment:SetIsInFieldBlock(true)
        end
        assignment:SetLocation(context:GetLocation())
        assignment:SetClass(currentClass)
        assignment:SetRightHandSide(right)
        assignment:SetType(value)
        assignment:SetMethodWriter(methodWriter)
        assignment:SetVariable(var)
        assignment:SetParentWithField(parentClass)

        if isInAction
            currentBlockOpcode:Add(assignment)
        else //add the opcode to the field calculator
            currentClassOpcode:AddField(assignment)
        end
    end

    action ExitNormalAssignment(NormalAssignmentContext context) 
        text name = context:name
        Variable variable = undefined
        if not isInAction
            variable = currentClass:GetVariable(name)
        else 
            variable = currentBlock:GetVariable(name)
        end

        if variable = undefined
            CompilerError error
            error:SetLocation(context:GetLocation())
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_VARIABLE)
            error:SetCompilerErrorType(t)
            text message = "I could not locate the variable " + name
            error:SetErrorMessage(message)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        boolean notDefined = false
        if not variable:IsDefined()
            notDefined = true
        end

        Location useLocation
        useLocation:SetLocation(context:variableLocation)
        variable:AddUseLocation(useLocation)
        variable:SetIsDefined(true)
        if isInAlwaysBlock
            variable:SetDefinedInAlwaysBlock(true)
        end

        Type left = variable:GetType()
        Location typeLocation = context:typeLocation
        typeLocation = typeLocation:CreateLocationCopy()
        variable:SetTypeLocation(typeLocation)

        if not left:IsPrimitive()
            SymbolTable table = me:GetSymbolTable()
            Class clazz = table:GetClass(left:GetStaticKey())
            if clazz not= undefined
                clazz:AddUseLocation(typeLocation:CreateLocationCopy())
            else 
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_CLASS)
                error:SetCompilerErrorType(t)
                text message = "I could not locate the class " + left:GetStaticKey()
                error:SetErrorMessage(message)
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end
        end

        QuorumOpcode right = undefined
        if context:hasRightHandSide = false
            Type typeOriginal = context:leftHandSide
            if typeOriginal = undefined
                return now
            end
            if typeOriginal:IsPrimitive()
                //Note: We need to investigate/run a study on whether this decision
                //matters or not. 

                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:NO_RIGHT_HAND_SIDE_ON_NORMAL_ASSIGNMENT)
                error:SetCompilerErrorType(t)
                text message = "I noticed that the variable " + variable:GetName()
                    + " has the declared type of " + left:GetStaticKey() 
                    + ", but the right hand side of the statement was blank." 
                if left:IsInteger()
                    message = message + " For example, you might try integer " + variable:GetName()
                        + " = 0"
                elseif left:IsBoolean()
                    message = message + " For example, you might try boolean " + variable:GetName()
                        + " = true"
                elseif left:IsNumber()
                    message = message + " For example, you might try number " + variable:GetName()
                        + " = 0.0"
                elseif left:IsText()
                    message = message + " For example, you might try text " + variable:GetName()
                        + " = " + message:GetDoubleQuote() + message:GetDoubleQuote()
                end

                error:SetErrorMessage(message)
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
            else 
                if left:IsMappedToGeneric()
                    //we can't allow this to be instantiated, throw an error
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    CompilerErrorType t
                    t:SetCurrentType(t:INSTANTIATE_GENERIC)
                    error:SetCompilerErrorType(t)
                    text message = "The variable " + name
                        +   " is a generic type. Because I cannot determine its " 
                        +   " type at compile time, I cannot instantiate it. If I did "
                        +   " not prevent this, your program could crash when you ran it."
                    error:SetErrorMessage(message)
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                end

                SymbolTable table = me:GetSymbolTable()
                Class clazz = table:GetClass(left:GetStaticKey())
                clazz:AddUseLocation(typeLocation:CreateLocationCopy())
                CreateObjectOpcode opcode
                opcode:SetLocation(context:GetLocation())
                opcode:SetMethodWriter(methodWriter)
                if clazz = undefined
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    CompilerErrorType t
                    t:SetCurrentType(t:MISSING_CLASS)
                    error:SetCompilerErrorType(t)
                    text message = "The class " + left:GetStaticKey() + " is either missing or I cannot find it."
                    error:SetErrorMessage(message)
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                end
                opcode:SetClass(clazz)

                //make sure we do not try and instantiate a class
                //that has blueprints
                if clazz:HasBlueprints()
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    CompilerErrorType t
                    t:SetCurrentType(t:INSTANTIATE_ABSTRACT)
                    error:SetCompilerErrorType(t)
                    text message = "Cannot Create Class with Blueprint: I noticed that the variable " + variable:GetName()
                    + " has the declared type of " + left:GetStaticKey() 
                    + ", but that class has blueprint actions, so I don't know how to create one." 

                    boolean first = false
                    integer numBlueprints = 0
                    Iterator<Action> it = clazz:GetVirtualTable()
                    text blue = ""
                    repeat while it:HasNext()
                        Action act = it:Next()
                        if act:IsBlueprint()
                            text sk = act:GetStaticKey()
                            if first
                                blue = blue + ", " + sk
                            else
                                blue = blue + sk
                            end
                            numBlueprints = numBlueprints + 1
                            first = true
                        end
                    end
                    
                    if numBlueprints > 1
                        message = message + " The blueprints missing are "
                    else
                        message = message + " The blueprint missing is "
                    end

                    message = message + blue + "."

                    error:SetErrorMessage(message)
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                end

                opcode:SetVariable(variable)

                if isInAction
                    currentBlockOpcode:Add(opcode)
                    return now
                else //add the opcode to the field calculator
                    currentClassOpcode:AddField(opcode)
                    return now
                end
                
            end
        end

        right = opcodeStack:Pop()


        Operation assign
        assign:SetOperation(assign:EQUALS)

        TypeChecker checker = GetTypeChecker()

        if right = undefined //the system should have already output an error, so return
            return now
        end

        TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 
        CompilerError error = result:GetCompilerError(context:GetLocation())

        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        integer location = variable:GetBytecodeLocation()
        Type value = result:result
        AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
        if currentBlock = undefined
            assignment:SetIsInFieldBlock(true)
        end
        if notDefined
            assignment:SetIsNewAssignment(true)
        end
        assignment:SetLocation(context:GetLocation())
        assignment:SetClass(currentClass)
        assignment:SetRightHandSide(right)
        assignment:SetType(value)
        assignment:SetMethodWriter(methodWriter)
        assignment:SetVariable(variable)

        if isInAction
            currentBlockOpcode:Add(assignment)
        else //add the opcode to the field calculator
            currentClassOpcode:AddField(assignment)
        end
    end

    action EnterNoTypeAssignment(NoTypeAssignmentContext context) 
    end

    action ExitNoTypeAssignment(NoTypeAssignmentContext context) 
        text name = context:name
        Variable variable = undefined
        TypeChecker checker = GetTypeChecker()

        if context:hasMe or context:isField or not isInAction
            variable = currentClass:GetVariable(name)
        else 
            variable = currentBlock:GetVariable(name)
        end

        if variable not= undefined
            if variable:IsConstant() //issue an error, this is not allowed.
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:CONSTANT_REASSIGNMENT)
                error:SetCompilerErrorType(errorType)
                error:SetErrorMessage("The variable " + variable:GetName() 
                    + ", is a constant and cannot be modified.")
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
            end
        else 
            CompilerError error
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:MISSING_VARIABLE)
            error:SetCompilerErrorType(errorType)
            error:SetErrorMessage("Could not find the variable "
                + "variable " + name + ".")
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        boolean notDefined = false
        if not variable:IsDefined()
            notDefined = true
        end

        Location useLocation
        useLocation:SetLocation(context:variableLocation)
        variable:AddUseLocation(useLocation)
        variable:SetIsDefined(true)
        Type left = variable:GetType()

        QuorumOpcode right = opcodeStack:Pop()
        if left = undefined //if the type is undefined, it might be possible to infer it
            InferenceResult infer = checker:CanInfer(right)
            if infer:canInfer //hey awesome, that was easy!
                Type rightType = right:GetType()
                rightType = rightType:Copy()
                left = rightType
                variable:SetType(left)
            else
                CompilerError error
                error:SetLocation(variable)
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:VARIABLE_INFERENCE)
                error:SetCompilerErrorType(errorType)
                if right not= undefined
                    Type otherType = right:GetType()
                    if otherType not= undefined
                        error:SetErrorMessage("Will not infer the type of the " + 
                            "right hand side of this expression automatically. To " +
                            " fix this, change the declaration to " + otherType:GetStaticKeyWithGenerics() + 
                            " " + variable:GetName() + ".")
                    else 
                        error:SetErrorMessage("Will not infer the type of the " + 
                            "right hand side of this expression assigning to the " +
                            " variable " + variable:GetName() + ".")
                    end
                    
                end

                if right = undefined
                    error:SetErrorMessage("Will not infer the type of the " + 
                        "right hand side of this expression automatically, as the right hand side of this type is undefined.")
                end

                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end
        end

        Operation assign
        assign:SetOperation(assign:EQUALS)

        if right = undefined
            return now
        end
        TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 

        if result:errorType = undefined
            integer location = variable:GetBytecodeLocation()
            Type value = result:result
            AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
            if currentBlock = undefined
                assignment:SetIsInFieldBlock(true)
            end
            if notDefined
                assignment:SetIsNewAssignment(true)
            end
            assignment:SetLocation(context:GetLocation())
            assignment:SetClass(currentClass)
            assignment:SetRightHandSide(right)
            assignment:SetType(value)
            assignment:SetMethodWriter(methodWriter)
            assignment:SetVariable(variable)
            if not isInAction
                currentClassOpcode:AddField(assignment)
            else
                currentBlockOpcode:Add(assignment)
            end
        else 
            CompilerError error = result:GetCompilerError(context:GetLocation())
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end
    end
    
    action EnterVariableSoloFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = context:hasMe
        Array<ActionCallOpcode> stack
        actionCallStacks:Add(me:currentActionStack, stack)
        currentActionStack = currentActionStack + 1

        text object = context:objectName
        if not (object = undefined)
            ActionCallContext ac
            ac:SetLocation(context:objectLocation)
            ac:isActionCall = false
            ac:name = object
            EnterActionCall(ac)
            ExitActionCall(ac)
        end
    end

    private action ComputeInitialParameters(integer size, ActionCallOpcode actionCall)
        Array<QuorumOpcode> parametersBackward
        repeat size times
            QuorumOpcode param = opcodeStack:Pop()
            parametersBackward:Add(param)
        end

        Array<Type> parameters
        Array<QuorumOpcode> parameterOpcodes
        i = size - 1
        repeat size times
            QuorumOpcode op = parametersBackward:Get(i)
            if op = undefined
                return now
            end
            parameters:Add(op:GetType())
            parameterOpcodes:Add(op)
            i = i - 1
        end

        actionCall:SetParameters(parameterOpcodes)
        actionCall:SetParameterTypes(parameters)
    end

    action ExitVariableSoloFunctionCall(VariableFunctionCallContext context)
        Array<ActionCallOpcode> stack = actionCallStacks:RemoveKey(me:currentActionStack - 1)
        currentActionStack = currentActionStack - 1

        ChainedActionCallOpcode ops
        ops:SetMethodWriter(methodWriter)
        ops:SetLocation(context:GetLocation())
        ops:SetIsSoloCall(true)
        Iterator<ActionCallOpcode> it = stack:GetIterator()
        repeat while it:HasNext()
            ActionCallOpcode op = it:Next()
            if currentBlock = undefined
                op:SetIsInFieldBlock(true)
            end
            ops:Add(op)
        end

        //if the stack is empty, no valid action calls were created,
        //likely due to a compiler error somewhere else, which would 
        //have already been thrown. As such, ignore the call
        //and don't add it to the block.
        if stack:IsEmpty()
            return now
        end

        //since this is a solo call, there is no assignment statement.
        //thus, if there's a return type, we need to pop it off the stack.
        ActionCallOpcode op = stack:GetFromEnd()
        Type returnType = op:GetType()
        if returnType not= undefined
            if not returnType:IsVoid()
                ops:SetPopReturn(true)
                
                if currentBlock not= undefined
                    //now add an editor hint to the system so we can auto-generate
                    //the left hand side for the user if they so choose
                    AddReturnTypeHint hint
                    hint:SetLocation(context:GetLocation())
                    text val = returnType:GetNameWithMappedGenerics()
                    text defaultNameChoice = currentBlock:GetNewVariableInBlock("value")
                    hint:SetCode(val + " " + defaultNameChoice + " = ")
                    Location opLocation = op:GetLocation()
                    hint:SetStartOffset(context:GetLocation():GetIndex())
                    hint:SetEndOffset(context:GetLocation():GetIndex())
                    hint:SetDisplayName("Assign return value to new variable")
                    CompilerErrorManager errors = GetCompilerErrorManager()
                    errors:Add(hint)
                end
            end
            
        end
        currentBlockOpcode:Add(ops)
    end

    action FinishActionResolution(ActionCallOpcode actionCall, ActionCallResolution resolved)
        if resolved not= undefined and resolved:isResolved
            actionCall:SetActionCallResolution(resolved)
            actionCall:SetIsActionCall(true)
            actionCall:SetCallingClass(currentClass)
            actionCall:SetActionCallResolution(resolved)

            Action act = resolved:resolvedAction
            Class classToMakeCallOn = resolved:classToMakeCallOn
            if classToMakeCallOn:GetStaticKey() not= currentClass:GetStaticKey()
                and act:IsPrivate()
                //this action is private and in another class.
                CompilerError error
                error:SetLocation(actionCall:GetLocation())
                error:SetErrorMessage("The action call " + act:GetName()
                    + "is private"
                    + ". It cannot be used from class "
                    + currentClass:GetStaticKey() + " unless " + act:GetName() + " is made public.")
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:ACCESS_ERROR)
                error:SetCompilerErrorType(errorType)
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end
            
            actionCall:SetParameters(ComputeFinalParameters(actionCall:GetParameters(), resolved:converter))
            Type returnType = act:GetReturnType()
            if not actionCall:GetPushOnMe() //if it's a me call, it doesn't matter
                if returnType:IsMappedToGeneric() //it is mapped to a generic, so find the variable it is mapped to
                    Type t = resolved:typeToMakeCallOn
                    Class c = resolved:classToMakeCallOn

                    integer index = -1
                    Class parentClass = act:GetParentClass()
                    if parentClass:GetStaticKey() = c:GetStaticKey()
                        index = c:GetIndexOfGeneric(returnType:GetMappedGeneric())
                    else //this action must be defined in a parent. Map its generics separately
                        index = parentClass:GetIndexOfGeneric(returnType:GetMappedGeneric())
                        index = c:MapParentGenericToMe(parentClass:GetStaticKey(), index)
                    end
                    
                    if index not= -1
                        //first check that the index we are trying to reference
                        //actually exists. If it doesn't, bail.
                        if index >= t:GetNumberGenerics()
                            return now
                        end
                        Type left = t:GetGeneric(index)
                        TypeChecker checker = GetTypeChecker()
                        
                        //get the type of the thing. If it is a primitive
                        //it is stored type erased, but might look like a
                        //primitive, so get the object version
                        Type right
                        text boxedKey = left:ConvertToNonPrimitiveStaticKey()
                        right:SetToObject(boxedKey)

                        //since we know this is defined as a generic,
                        //it is equivalent to a cast
                        Operation op
                        op:SetOperation(op:CAST)
                        TypeCheckResult result = checker:Check(left, returnType, op, false)
                        if result:errorType = undefined
                            QuorumOpcode opcode = result:GetQuorumOpcode()
                            if opcode not= undefined
                                opcode:SetMethodWriter(methodWriter)
                                //this may be null or ignored
                                actionCall:SetAutoBoxOpcode(opcode)
                                actionCall:SetType(left)
                            end
                        else
                            CompilerErrorManager manager = GetCompilerErrorManager()
                            manager:Add(result:GetCompilerError(resolved:location))
                        end
                    else //this is an invalid generic, throw an error
                        

                    end
                else
                    //this variable isn't mapped to a generic, but it could
                    //be templated type itself that is mapped to a generic
                    //if it has generics in it, map them appropriately

                    if returnType:GetNumberGenerics() > 0
                        Type newReturn
                        newReturn:CopyFrom(returnType)
                        ResolveGenericType(newReturn, resolved:typeToMakeCallOn, resolved:classToMakeCallOn, act, resolved)
                        actionCall:SetType(newReturn)
                    end
                end
            end
        else
            CompilerError error = resolved:error 
            if error not= undefined
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
            end
        end
    end

    private action ResolveGenericType(Type returnType, Type typeToMakeCallOn, 
        Class classToMakeCallOn, Action act, ActionCallResolution resolved)
        if returnType:IsMappedToGeneric() //it is mapped to a generic, so find the variable it is mapped to
            Type t = typeToMakeCallOn
            Class c = classToMakeCallOn

            integer index = -1
            Class parentClass = act:GetParentClass()
            if parentClass:GetStaticKey() = c:GetStaticKey()
                index = c:GetIndexOfGeneric(returnType:GetMappedGeneric())
            else //this action must be defined in a parent. Map its generics separately
                index = parentClass:GetIndexOfGeneric(returnType:GetMappedGeneric())
                index = c:MapParentGenericToMe(parentClass:GetStaticKey(), index)
            end

            if index not= -1 and index < t:GetNumberGenerics()
                Type left = t:GetGeneric(index)
                
                returnType:CopyFrom(left)
                returnType:SetToObject(left:GetStaticKey())
            else //no index, this is an error
                CompilerErrorManager manager = GetCompilerErrorManager()
                CompilerError error
                error:SetLocation(act)
                CompilerErrorType t2
                t2:SetCurrentType(t2:INCOMPATIBLE_TYPES)
                error:SetCompilerErrorType(t2)
                text message = "Invalid Generic at index " + index
                error:SetErrorMessage(message)
                manager:Add(error)
                return now
            end
        else
            //this variable isn't mapped to a generic, but it could
            //be templated type itself that is mapped to a generic
            //if it has generics in it, map them appropriately
            if returnType:GetNumberGenerics() > 0
                Iterator<Type> generics = returnType:GetGenerics()
                repeat while generics:HasNext()
                    Type type = generics:Next()
                    ResolveGenericType(type, resolved:typeToMakeCallOn, resolved:classToMakeCallOn, act, resolved)
                end
            end
        end
    end

    action EnterVariableFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = context:hasMe
        Array<ActionCallOpcode> stack
        actionCallStacks:Add(me:currentActionStack, stack)
        currentActionStack = currentActionStack + 1
    end

    action ExitVariableFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = false
        Array<ActionCallOpcode> stack = actionCallStacks:RemoveKey(me:currentActionStack - 1)
        currentActionStack = currentActionStack - 1

        ChainedActionCallOpcode ops
        ops:SetLocation(context:GetLocation())
        Iterator<ActionCallOpcode> it = stack:GetIterator()
        repeat while it:HasNext()
            ActionCallOpcode op = it:Next()
            if currentBlock = undefined
                op:SetIsInFieldBlock(true)
            end
            ops:Add(op)
        end

        opcodeStack:Push(ops)
    end

    action EnterParentVariableSoloFunctionCall(ParentVariableFunctionCallContext context) 
        isNextVariableReferenceMe = context:hasMe
        Array<ActionCallOpcode> stack
        actionCallStacks:Add(me:currentActionStack, stack)
        currentActionStack = currentActionStack + 1

        parentCallStack:Push(context)
    end

    action ExitParentVariableSoloFunctionCall(ParentVariableFunctionCallContext context) 
        Array<ActionCallOpcode> stack = actionCallStacks:RemoveKey(me:currentActionStack - 1)
        currentActionStack = currentActionStack - 1

        ChainedActionCallOpcode ops
        ops:SetMethodWriter(methodWriter)
        ops:SetIsSoloCall(true)
        ops:SetLocation(context:GetLocation())
        Iterator<ActionCallOpcode> it = stack:GetIterator()
        repeat while it:HasNext()
            ActionCallOpcode op = it:Next()
            if currentBlock = undefined
                op:SetIsInFieldBlock(true)
            end
            ops:Add(op)
        end

        //since this is a solo call, there is no assignment statement.
        //thus, if there's a return type, we need to pop it off the stack.
        //if the stack is empty, then no valid action was found and an 
        //error has already been issued by the compiler, so don't generate a 
        //new one here.
        if not stack:IsEmpty()
            ActionCallOpcode op = stack:GetFromEnd()
            Type returnType = op:GetType()
            if returnType not= undefined
                if not returnType:IsVoid()
                    ops:SetPopReturn(true)

                    if currentBlock not= undefined
                        //now add an editor hint to the system so we can auto-generate
                        //the left hand side for the user if they so choose
                        AddReturnTypeHint hint
                        hint:SetLocation(context:GetLocation())
                        text val = returnType:GetNameWithMappedGenerics()
                        text defaultNameChoice = currentBlock:GetNewVariableInBlock("value")
                        hint:SetCode(val + " " + defaultNameChoice + " = ")
                        Location opLocation = op:GetLocation()
                        hint:SetStartOffset(context:GetLocation():GetIndex())
                        hint:SetEndOffset(context:GetLocation():GetIndex())
                        hint:SetDisplayName("Assign return value to new variable")
                        CompilerErrorManager errors = GetCompilerErrorManager()
                        errors:Add(hint)
                    end
                end
            end
            currentBlockOpcode:Add(ops)
        end
    end

    action EnterParentVariableFunctionCall(ParentVariableFunctionCallContext context)
        Location loc = context:GetLocation()
        isNextVariableReferenceMe = context:hasMe
        Array<ActionCallOpcode> stack
        actionCallStacks:Add(me:currentActionStack, stack)
        currentActionStack = currentActionStack + 1

        parentCallStack:Push(context)
    end

    private action AdaptToParentActionCall(ParentVariableFunctionCallContext context, ActionCallOpcode actionCall) returns ActionCallOpcode
        actionCall:SetIsParentCall(true)

        boolean hasMe = context:hasMe
        text variableName = context:variableName
        QualifiedName parentName = context:parentName
        
        Variable variable = undefined
        TypeChecker checker = GetTypeChecker()
        CompilerErrorManager manager = GetCompilerErrorManager()
        SymbolTable table = GetSymbolTable()

        boolean skipFieldVariable = variableName = undefined

        if not skipFieldVariable
            skipFieldVariable = variableName:IsEmpty()
        end

        if not skipFieldVariable //this parent call has a field variable
            if hasMe or not isInAction
                variable = currentClass:GetVariable(variableName)
            else 
                variable = currentBlock:GetVariable(variableName)
            end

            if variable = undefined
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_VARIABLE)
                error:SetCompilerErrorType(t)
                text message = "Could not find the variable " + variableName + "."
                error:SetErrorMessage(message)
                manager:Add(error)
                return undefined
            end

            Type resolvedType
            resolvedType:SetToObject(parentName:GetStaticKey())
            currentClass:ResolveType(context:GetLocation(), resolvedType, GetSymbolTable(), GetCompilerErrorManager())

            Type variableType = variable:GetType()
            //if this type is null, it means the variable was found, but it's type could not be determined.
            if variableType = undefined
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:VARIABLE_INFERENCE)
                error:SetCompilerErrorType(t)
                text message = "Found the variable " + variableName + ", but could not determine its type."
                error:SetErrorMessage(message)
                manager:Add(error)
                return undefined
            end

            key = variableType:GetStaticKey()

            actionCall:SetVariableToMakeParentCallOn(variable)


            //this can't be null, because resolution happened already. If it is
            //it's a compiler bug, not a user error.
            Class fieldClass = table:GetClass(key)

            hasParent = fieldClass:HasParentClass(resolvedType:GetStaticKey())
            if not hasParent
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_PARENT)
                error:SetCompilerErrorType(t)
                text message = "Could not find the parent class " + resolvedType:GetStaticKey() + "."
                error:SetErrorMessage(message)
                manager:Add(error)
                return undefined
            end
            actionCall:SetClassToMakeParentCallOn(fieldClass)
            Class parentClass = fieldClass:GetParentClass(resolvedType:GetStaticKey())
            actionCall:SetParentToCallOn(parentClass)
            Type type
            type:SetToObject(parentClass:GetStaticKey())
            actionCall:SetType(type)
            actionCall:SetCallingClass(currentClass)

            return actionCall
        else //this parent call does not have a field variable
            Type resolvedType
            resolvedType:SetToObject(parentName:GetStaticKey())
            currentClass:ResolveType(context:GetLocation(), resolvedType, GetSymbolTable(), GetCompilerErrorManager())

            Class parentClass = currentClass:GetParentClass(resolvedType:GetStaticKey())
            hasParent = currentClass:HasParentClass(resolvedType:GetStaticKey())
            if not hasParent
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_PARENT)
                error:SetCompilerErrorType(t)
                text message = "Could not find the parent class " + resolvedType:GetStaticKey() + "."
                error:SetErrorMessage(message)
                manager:Add(error)
                return undefined
            end

            actionCall:SetParentToCallOn(parentClass)
            return actionCall
        end
    end


    action ExitParentVariableFunctionCall(ParentVariableFunctionCallContext context)
        Array<ActionCallOpcode> stack = actionCallStacks:RemoveKey(me:currentActionStack - 1)
        currentActionStack = currentActionStack - 1

        ChainedActionCallOpcode ops
        ops:SetLocation(context:GetLocation())
        Iterator<ActionCallOpcode> it = stack:GetIterator()
        repeat while it:HasNext()
            ActionCallOpcode op = it:Next()
            if currentBlock = undefined
                op:SetIsInFieldBlock(true)
            end
            ops:Add(op)
        end

        opcodeStack:Push(ops)
    end

    action ExitActionExpressionList(ActionExpressionListContext context) 
        actionCallParameterStack:Push(context)
    end

    private action ComputeFinalParameters(Array<QuorumOpcode> parameterOpcodes, 
        Array<QuorumOpcode> conversions) returns Array<QuorumOpcode>
        //handle any casts, if there are any
        Array<QuorumOpcode> finalResolvedParameters
        integer next = 0
        repeat parameterOpcodes:GetSize() times
            QuorumOpcode previous = parameterOpcodes:Get(next)
            QuorumOpcode possibleCast = conversions:Get(next)
            if possibleCast not= undefined
                ExplicitCastOpcode caster = cast(ExplicitCastOpcode, possibleCast)
                caster:SetMethodWriter(methodWriter)
                caster:SetOpcodeToCast(previous)
                finalResolvedParameters:Add(caster)
            else //nothing to do with this opcode, just push it
                finalResolvedParameters:Add(previous)
            end
            next = next + 1
        end
        return finalResolvedParameters
    end

    action EnterInitialParentActionCall(ActionCallContext ctx) 
    end


    action ExitInitialParentActionCall(ActionCallContext ctx) 
        if not parentCallStack:IsEmpty()
            ParentVariableFunctionCallContext parentContext = parentCallStack:Peek()
            parentContext:pop = true
        end
        ExitActionCall(ctx)
    end

    action ExitActionCall(ActionCallContext context)
        ActionCallOpcode actionCall
        actionCall:SetLocation(context:GetLocation())
        actionCall:SetMethodWriter(methodWriter)

        if not parentCallStack:IsEmpty()
            ParentVariableFunctionCallContext parentContext = parentCallStack:Peek()
            if parentContext:pop = true
                parentCallStack:Pop()
                AdaptToParentActionCall(parentContext, actionCall)
            end
        end

        SymbolTable table = GetSymbolTable()

        if context:isActionCall //push the "this" pointer
            actionCall:SetIsActionCall(true)
            ActionExpressionListContext params =  actionCallParameterStack:Pop()
            size = params:size

            Class classToMakeCallOn = undefined
            boolean isPrimitive = false
            Array<ActionCallOpcode> stack = actionCallStacks:GetValue(currentActionStack - 1)

            Type calledType = undefined
            if stack:IsEmpty() //this is a solo call, push on this
                actionCall:SetPushOnMe(true)
                classToMakeCallOn = currentClass
            else //else we're making a call on a field, so get it off the stack and take a look
                ActionCallOpcode op = stack:GetFromEnd()
                Type t = op:GetType()
                calledType = t
                if t:IsPrimitive()
                    isPrimitive = true
                end

                text resolvedKey = t:ConvertToNonPrimitiveStaticKey()
                classToMakeCallOn = table:GetClass(resolvedKey)

                //I don't know why, but this fixes a Quorum 2 bug. 
                integer a = 4
                if classToMakeCallOn = undefined
                    CompilerError classNotFoundError
                    classNotFoundError:SetLocation(context:GetLocation())
                    classNotFoundError:SetErrorMessage("Could not find the class " + resolvedKey)
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:MISSING_CLASS)
                    classNotFoundError:SetCompilerErrorType(errorType)
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(classNotFoundError)
                    return now
                end
            end

            ComputeInitialParameters(size, actionCall)
            ActionCall call
            call:calledFrom = currentAction
            call:nameLocation = context:nameLocation:CreateLocationCopy()
            call:SetLocation(context:GetLocation())
            call:actualParameters = actionCall:GetParameterTypes()
            call:name = context:name
            call:checker = GetTypeChecker()
            call:table = GetSymbolTable()
            call:calledOnType = calledType
            call:opcode = actionCall

            ActionCallResolution resolved = classToMakeCallOn:ResolveAction(call)

            if not resolved:isResolved
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(resolved:error)
                return now
            end

            if isPrimitive //make sure the call is allowed and inform the writer
                Action act = resolved:resolvedAction
                
                text name = act:GetName()
                if name = "SetValue" or name = "SetValueNative" or name = "GetValue" or name = "GetValueNative"//these calls aren't allowed on primitives
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    error:SetErrorMessage("Found a call to the primitive calling the action " + name + ", but this cannot be called on a primitive.")
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:PRIMITIVE_INVALID_ACTION_CALL)
                    error:SetCompilerErrorType(errorType)
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                else
                    resolved:isCallOnPrimitive = true
                end
            end
            resolved:typeToMakeCallOn = calledType
            resolved:classToMakeCallOn = classToMakeCallOn
            resolved:callingClass = currentClass
            resolved:location = context:GetLocation()
            FinishActionResolution(actionCall, resolved)
        else //push the variable
            actionCall:SetIsActionCall(false)
            name = context:name
            Variable variable = undefined

            Array<ActionCallOpcode> stack = actionCallStacks:GetValue(currentActionStack - 1)

            if stack:IsEmpty() //This is the first call, so push on the me pointer
                if isNextVariableReferenceMe or not isInAction
                    variable = currentClass:GetVariable(name)
                elseif actionCall:IsParentCall()
                    Class parentClass = actionCall:GetParentToCallOn()

                    text callingName = ""
                    if parentClass not= undefined //it's not in the current class
                        variable = parentClass:GetVariable(name)
                        callingName = parentClass:GetStaticKey()
                    else
                        variable = currentClass:GetVariable(name)
                        callingName = currentClass:GetStaticKey()
                    end

                    if variable not= undefined and parentClass not= undefined 
                        //check to see if the variable is private
                        //if it is, this is ok, but only if the class we are
                        //grabbing from is a parent
                        if variable:IsPrivate() and not currentClass:HasParentClass(callingName)
                            CompilerError error
                            error:SetLocation(context:GetLocation())
                            error:SetErrorMessage("Found " + name 
                                + ", but it is private in the parent class "
                                + callingName + ".")
                            CompilerErrorType errorType
                            errorType:SetCurrentType(errorType:ACCESS_ERROR)
                            error:SetCompilerErrorType(errorType)
                            CompilerErrorManager manager = GetCompilerErrorManager()
                            manager:Add(error)
                            return now
                        end

                        if not variable:IsDefined()
                            CompilerError error
                            error:SetLocation(context:GetLocation())
                            error:SetErrorMessage("Found " + name + ", but it must be defined first.")
                            CompilerErrorType errorType
                            errorType:SetCurrentType(errorType:VARIABLE_INFERENCE)
                            error:SetCompilerErrorType(errorType)
                            CompilerErrorManager manager = GetCompilerErrorManager()
                            manager:Add(error)
                            return now
                        end
                    end
                    isNextVariableReferenceMe = false
                else 
                    variable = currentBlock:GetVariable(name)
                    isNextVariableReferenceMe = false
                end

                if variable not= undefined
                    Type type = variable:GetType()
                    //if this is null, a variable was used before it was assigned
                    //a type, and thus cannot be infered
                    if type = undefined
                        CompilerError error
                        error:SetLocation(context:GetLocation())
                        error:SetErrorMessage("Found " + name + ", but did not infer its type. Set its value before using it.")
                        CompilerErrorType errorType
                        errorType:SetCurrentType(errorType:MISSING_CLASS)
                        error:SetCompilerErrorType(errorType)
                        CompilerErrorManager manager = GetCompilerErrorManager()
                        manager:Add(error)
                        return now
                    end

                    //check if this variable has been defined.
                    //if it hasn't, it is an error
                    if not variable:IsDefined()
                        CompilerError error
                        error:SetLocation(context:GetLocation())
                        error:SetErrorMessage("Found " + name + ", but it must be defined first.")
                        CompilerErrorType errorType
                        errorType:SetCurrentType(errorType:VARIABLE_INFERENCE)
                        error:SetCompilerErrorType(errorType)
                        CompilerErrorManager manager = GetCompilerErrorManager()
                        manager:Add(error)
                        return now
                    end

                    actionCall:SetPushOnMe(true)
                    actionCall:SetCallerType(type)
                    actionCall:SetType(type)
                    actionCall:SetField(variable)
                    actionCall:SetFieldHolder(currentClass)
                    actionCall:SetCallingClass(currentClass)
                    Location useLocation
                    useLocation:SetLocation(context:GetLocation())
                    variable:AddUseLocation(useLocation)
                else
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    error:SetErrorMessage("Could not find the variable " + name)
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:MISSING_VARIABLE)
                    error:SetFile(GetFile())
                    error:SetCompilerErrorType(errorType)
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                end
            else //get the most recent type off the stack
                ActionCallOpcode code = stack:Get(stack:GetSize() - 1)
                
                Type type = code:GetType()
                if not type:IsPrimitive() //if it is, again previous phase will catch this
                    text staticKey = type:GetStaticKey()
                    Class clazz = table:GetClass(staticKey)
                    
                    //get a field.
                    Variable field = clazz:GetVariable(name)
                    if field not= undefined
                    
                        //if the field is in another class, make sure that it is public
                        if currentClass:GetStaticKey() not= clazz:GetStaticKey()
                           and field:IsPrivate() 
                           //we are trying to access a private member in another class, 
                           //throw a compiler error.
                            CompilerError error
                            error:SetLocation(context:GetLocation())
                            error:SetErrorMessage("Found a call to " + staticKey + ":" + name 
                                + ", which is private"
                                + ". It cannot be used from class "
                                + currentClass:GetStaticKey() + " unless " + name + " is made public.")
                            CompilerErrorType errorType
                            errorType:SetCurrentType(errorType:ACCESS_ERROR)
                            error:SetCompilerErrorType(errorType)
                            error:SetFile(GetFile())
                            CompilerErrorManager manager = GetCompilerErrorManager()
                            manager:Add(error)
                            return now
                        end

                        if not field:IsDefined()
                            CompilerError error
                            error:SetLocation(context:GetLocation())
                            error:SetErrorMessage("Found the variable " + name + ", but it must be defined first.")
                            CompilerErrorType errorType
                            errorType:SetCurrentType(errorType:VARIABLE_INFERENCE)
                            error:SetCompilerErrorType(errorType)
                            CompilerErrorManager manager = GetCompilerErrorManager()
                            manager:Add(error)
                            return now
                        end
                        Type fieldType = field:GetType()
                        actionCall:SetCallerType(fieldType)
                        actionCall:SetType(fieldType)
                        actionCall:SetIsField(true)
                        actionCall:SetField(field)
                        actionCall:SetFieldHolder(clazz)
                        actionCall:SetCallingClass(currentClass)
                        actionCall:SetChainedCall(true)
                        Location useLocation
                        useLocation:SetLocation(context:GetLocation())
                        field:AddUseLocation(useLocation)
                    else
                        CompilerError error
                        error:SetLocation(context:GetLocation())
                        error:SetErrorMessage("Could not find the variable " + name)
                        CompilerErrorType errorType
                        errorType:SetCurrentType(errorType:MISSING_CLASS)
                        error:SetCompilerErrorType(errorType)
                        error:SetFile(GetFile())
                        CompilerErrorManager manager = GetCompilerErrorManager()
                        manager:Add(error)
                        return now
                    end
                end
            end
        end

        Array<ActionCallOpcode> stack = actionCallStacks:GetValue(currentActionStack - 1)
        stack:Add(actionCall)
    end

    action ExitReturnStatement(ReturnContext context) 
        recentStatementWasReturn = true
        Type type = currentAction:GetReturnType()
        if type = undefined
            return now
        end

        if not type:IsVoid() //if this is not a void method, handle the return
            QuorumOpcode right = opcodeStack:Pop()

            Operation returnOp
            returnOp:SetOperation(returnOp:RETURN)

            TypeChecker checker = GetTypeChecker()
            if right = undefined
                return now
            end

            TypeCheckResult result = checker:Check(type, right:GetType(), returnOp) 
            CompilerError error = result:GetCompilerError(context:GetLocation())
            if error not= undefined
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end

            ReturnOpcode opcode = cast(ReturnOpcode, result:GetQuorumOpcode())
            opcode:SetLocation(context:GetLocation())
            opcode:SetReturnValue(right)
            opcode:SetMethodWriter(methodWriter)
            currentBlockOpcode:Add(opcode)
        else //if it is a void method, just do a normal return, but don't pop off the opcode stack
            //if it isn't a return now, throw a compiler error
            if not context:isReturnNow
                QuorumOpcode right = opcodeStack:Pop()
                TypeChecker checker = GetTypeChecker()
                Operation returnOp
                returnOp:SetOperation(returnOp:RETURN)
                if right = undefined
                    return now
                end

                TypeCheckResult result = checker:Check(type, right:GetType(), returnOp) 
                CompilerError error = result:GetCompilerError(context:GetLocation())
                if error not= undefined
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                end
            end
            ReturnOpcode opcode
            opcode:SetLocation(context:GetLocation())
            opcode:SetType(type)
            opcode:SetMethodWriter(methodWriter)
            currentBlockOpcode:Add(opcode)
        end
    end

    action ExitStatement(StatementContext context) 
        if recentStatementWasReturn
            currentBlock:SetReturnThisBlock(true)
            recentStatementWasReturn = false
        else
            HasAlreadyReturnedFromBlock(context:GetLocation())
        end
    end

    private action HasAlreadyReturnedFromBlock(Location location)
        if currentBlock:HasReturnThisBlock()
            //first check if we've already issued an error.
            //if we already have, there's no need to issue another one.
            //if we haven't, issue the error and then set the value in the block
            if not currentBlock:HasIssuedReturnError()
                CompilerError e
                e:SetErrorMessage("This statement would not execute, because we have already returned from the action.")
                CompilerErrorType t
                t:SetCurrentType(t:UNREACHABLE)
                e:SetCompilerErrorType(t)
                e:SetLocation(location)
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(e)
                currentBlock:SetIssuedReturnError(true)
            end
        end
    end

    action ExitCast(CastContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Peek()
        Operation op
        op:SetOperation(op:CAST)

        Type left = context:type //this has to be resolved
        if left = undefined
            return now //An error has already been issued.
        end
        currentClass:ResolveType(context:GetLocation(), left, GetSymbolTable(), GetCompilerErrorManager())

        if right = undefined
            return now
        end

        TypeCheckResult result = checker:Check(left, right:GetType(), op)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        ExplicitCastOpcode theCast = cast(ExplicitCastOpcode, result:GetQuorumOpcode())
        if theCast not= undefined
            theCast:SetLocation(context:GetLocation())
            theCast:SetMethodWriter(methodWriter)
            theCast:SetType(result:result)
            theCast:SetOpcodeToCast(opcodeStack:Pop())
            opcodeStack:Push(theCast)
        end
    end

    action ExitInequality(InequalityContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if context:isGreater
            add:SetOperation(add:GREATER)
        elseif context:isGreaterEquals
            add:SetOperation(add:GREATER_EQUALS)
        elseif context:isLess
            add:SetOperation(add:LESS)
        elseif context:isLessEquals
            add:SetOperation(add:LESS_EQUALS)
        end

        if left = undefined or right = undefined
            return now
        end
        
        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        ComparisonOpcode compare = cast(ComparisonOpcode, result:GetQuorumOpcode())
        compare:SetLocation(context:GetLocation())
        compare:SetMethodWriter(methodWriter)
        compare:SetType(value)
        compare:SetLeftOpcode(left)
        compare:SetRightOpcode(right)
        opcodeStack:Push(compare)
    end

    action ExitEquals (EqualsContext context)
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if context:equalsTo
            add:SetOperation(add:EQUALS)
        else
            add:SetOperation(add:NOT_EQUALS)
        end

        if left = undefined or right = undefined
            return now //An error has already been issued.
        end
        
        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        ComparisonOpcode compare = cast(ComparisonOpcode, result:GetQuorumOpcode())
        compare:SetLocation(context:GetLocation())
        compare:SetMethodWriter(methodWriter)
        compare:SetType(value)
        compare:SetLeftOpcode(left)
        compare:SetRightOpcode(right)
        opcodeStack:Push(compare)
    end

    action EnterAnd(AndOrContext context) end
    action ExitAnd(AndOrContext context) 
        DoAndOr(context)
    end

    action DoAndOr(AndOrContext context)
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation op
        if context:isAnd
            op:SetOperation(op:AND)
        else 
            op:SetOperation(op:OR)
        end

        if left = undefined or right = undefined
            return now //An error has already been issued.
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), op)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        BinaryAndOrOpcode binary
        binary:SetLocation(context:GetLocation())
        binary:isAnd = context:isAnd
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetOperation(op)
        binary:left = left
        binary:right = right

        if left is BinaryAndOrOpcode
            BinaryAndOrOpcode theAnd = cast(BinaryAndOrOpcode, left)
            theAnd:hasParent = true
            theAnd:opcodeParent = binary
            theAnd:isOnLeft = true
        end

        if right is BinaryAndOrOpcode
            BinaryAndOrOpcode theAnd = cast(BinaryAndOrOpcode, right)
            theAnd:hasParent = true
            theAnd:opcodeParent = binary
            theAnd:isOnLeft = false
        end
        opcodeStack:Push(binary)
    end

    action EnterOr(AndOrContext context) end
    action ExitOr(AndOrContext context)
        DoAndOr(context)
    end

    action ExitMultiplication(MultiplicationContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation op
        if context:isDivide
            op:SetOperation(op:DIVIDE)
        elseif context:isMultiply
            op:SetOperation(op:TIMES)
        else
            op:SetOperation(op:MODULUS)
        end

        if left = undefined or right = undefined
            return now //An error has already been issued.
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), op)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        BinaryOpcode binary = cast(BinaryOpcode, result:GetQuorumOpcode())
        binary:SetLocation(context:GetLocation())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetLeftOpcode(left)
        binary:SetRightOpcode(right)
        opcodeStack:Push(binary)
    end

    action ExitAddition(AdditionContext addition) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if addition:isPlus
            add:SetOperation(add:PLUS)
        else
            add:SetOperation(add:MINUS)
        end

        if left = undefined or right = undefined
            return now //An error has already been issued.
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        CompilerError error = result:GetCompilerError(addition:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        BinaryOpcode binary = cast(BinaryOpcode, result:GetQuorumOpcode())
        binary:SetLocation(addition:GetLocation())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetLeftOpcode(left)
        binary:SetRightOpcode(right)
        opcodeStack:Push(binary)
    end

    action ExitMinus(UnaryMinusContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode left = opcodeStack:Pop()

        Operation notOp
        notOp:SetOperation(notOp:MINUS)

        if left = undefined
            return now //An error has already been issued.
        end

        TypeCheckResult result = checker:Check(left:GetType(), notOp) 
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        NegateUnaryOpcode binary = cast(NegateUnaryOpcode, result:GetQuorumOpcode())
        binary:SetLocation(context:GetLocation())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetOpcode(left)
        opcodeStack:Push(binary)
    end

    action ExitNot(NotContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode left = opcodeStack:Pop()

        Operation notOp
        notOp:SetOperation(notOp:NOT)

        if left = undefined
            return now //An error has already been issued.
        end

        TypeCheckResult result = checker:Check(left:GetType(), notOp) 
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        FlipBooleanOpcode binary = cast(FlipBooleanOpcode, result:GetQuorumOpcode())
        binary:SetLocation(context:GetLocation())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetOpcode(left)
        opcodeStack:Push(binary)
    end

    action ExitMe(MeContext context) 
        MeOpcode opcode
        opcode:SetLocation(context:GetLocation())
        opcode:SetMethodWriter(methodWriter)
        opcode:SetThis(currentClass)
        opcodeStack:Push(opcode)
    end

    action ExitInput(InputContext context) 
        InputOpcode opcode
        opcode:SetLocation(context:GetLocation())
        opcode:SetMethodWriter(methodWriter)

        Type type
        type:SetToText()
        opcode:SetType(type)
        QuorumOpcode op = opcodeStack:Pop()

        if op = undefined
            return now
        end

        //check if it's either text or undefined
        Type returnedType = op:GetType()
        if not (returnedType:IsText() or returnedType:IsUndefined())
            CompilerError error
            error:SetLocation(context:GetLocation())
            error:SetErrorMessage("To use input, you can either pass nothing at all, text, or the value undefined.")
            CompilerErrorType t
            t:SetCurrentType(t:INCOMPATIBLE_TYPES)
            error:SetFile(GetFile())
            error:SetCompilerErrorType(t)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
        end

        //set it to the opcode
        opcode:SetOpcode(op)
        opcodeStack:Push(opcode)
    end

    action ExitInputNoParameters(InputContext context) 
        InputOpcode opcode
        opcode:SetLocation(context:GetLocation())
        opcode:SetMethodWriter(methodWriter)

        Type type
        type:SetToText()
        opcode:SetType(type)
        opcodeStack:Push(opcode)
    end

    action ExitUndefined(UndefinedContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetToUndefined()

        QuorumConstant const
        const:SetLocation(context:GetLocation())
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        opcodeStack:Push(const)
    end

    action ExitInteger(IntegerContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetIntegerConstant(context:value)

        QuorumConstant const
        const:SetLocation(context:GetLocation())
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:integerValue = context:value
        opcodeStack:Push(const)
    end
    
    action ExitText(TextContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetTextConstant(context:value)

        QuorumConstant const
        const:SetLocation(context:GetLocation())
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:textValue = context:value
        opcodeStack:Push(const)
    end

    action ExitBoolean(BooleanContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetBooleanConstant(context:value)

        QuorumConstant const
        const:SetLocation(context:GetLocation())
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:booleanValue = context:value
        opcodeStack:Push(const)
    end

    action ExitNumber(NumberContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetNumberConstant(context:value)

        QuorumConstant const
        const:SetLocation(context:GetLocation())
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:numberValue = context:value
        opcodeStack:Push(const)
    end
end