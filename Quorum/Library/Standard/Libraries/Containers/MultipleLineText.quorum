package Libraries.Containers

use Libraries.Containers.Array
use Libraries.System.Properties

/*
The MultipleLineText class is used to distribute text across multiple lines.
This is done for both efficiency and to make certain kinds of operations easier.
For example, inserting or deleting characters into very large strings of text
will be much more efficient in a MultipleLineText than in the base text type.

Attribute: Example

use Libraries.Containers.MultipleLineText

MultipleLineText multiLineText
multiLineText:Initialize("Hello world! ")

text extraText = "This is extra text."
multiLineText = multiLineText:Concatenate(extraText)

extraText = multiLineText:GetLineSeparator() + "This text is on a second line."
multiLineText = multiLineText:Concatenate(extraText)

output multiLineText:GetText()
output "The text contains " + multiLineText:GetLineCount() + " lines."

*/
class MultipleLineText 

    // The children nodes.
    MultipleLineText left = undefined
    MultipleLineText right = undefined

    // The total number of characters stored in the left sub-tree, or the length
    // of the characters in this node if it is a leaf.
    integer weight = 0

    // The total number of leaves stored in the left sub-tree, or 0 if this is
    // a leaf.
    integer leafWeight = 0

    // How many leaves are present in this MultipleLineText.
    integer leafCount = 1

    // How many nodes have to traversed through from here to reach the most
    // distant leaf accessible from this MultipleLineText.
    integer depth = 0

    // How many characters can be stored in a leaf. Must be consistent for all
    // nodes in the structure.
    number maxLeafSize = 0

    // An array storing values of the fibonacci sequence which have already
    // been calculated. This array is shared among all other ropes produced by
    // this rope, and is used for testing tree imbalances.
    Array<integer> fibonacciArray = undefined

    // The characters stored in this node - empty unless the node is a leaf.
    text characters = ""

    // The line separator being used across all nodes of the tree.
    text lineSeparator = ""

    on create
        lineSeparator = GetDefaultLineSeparator()
        maxLeafSize = maxLeafSize:GetPositiveInfinityValue()
    end

    /*
    The Initialize action constructs the MultipleLineText from a starting text value.
    The MultipleLineText will store the given value, which may be retrieved or modified
    using the MultipleLineText's other actions.

    Attribute: Parameter value The value to be stored in this MultipleLineText.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree
    tree:Initialize("Hello world! What a lovely day!")
    output tree:GetText()
    */
    action Initialize(text value)
        Initialize(value, maxLeafSize)
    end

    /*
    The Initialize action constructs the MultipleLineText from a starting text value.
    The MultipleLineText will store the given value, which may be retrieved or modified
    using the MultipleLineText's other actions. The provided integer parameter will be
    used to set the maximum size of each leaf, in characters.

    Attribute: Parameter value The value to be stored in this MultipleLineText.
    Attribute: Parameter leafSize How many characters should be stored in each leaf of the tree.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText defaultTree
    defaultTree:Initialize("Hello world! What a lovely day!")
    output "The default tree stores text in " + defaultTree:GetLeafSize() + " character chunks."

    MultipleLineText newTree
    newTree:Initialize("Hello world! What a lovely day!", 10)
    output "The new tree stores text in " + newTree:GetLeafSize() + " character chunks."
    */
    action Initialize(text value, number leafSize)
        Array<integer> fibonacci
        fibonacci:Add(1)
        fibonacci:Add(2)
        Initialize(value, leafSize, fibonacci, true)
    end

    private action Initialize(text value, number leafSize, Array<integer> fibonacci, boolean keepEmptyEndLine)
        maxLeafSize = leafSize
        fibonacciArray = fibonacci
        if TextFitsInLine(value)
            if (keepEmptyEndLine and value:EndsWith(lineSeparator))
                MultipleLineText leftChild
                MultipleLineText rightChild
                leftChild:Initialize(value, leafSize, fibonacci, false)
                rightChild:Initialize("", leafSize, fibonacci, false)
                SetChildren(leftChild, rightChild)
            else
                characters = value
                weight = value:GetSize()
                leafWeight = 0
                leafCount = 1
                depth = 0
            end
        else
            MultipleLineText leftChild
            MultipleLineText rightChild

            /* 
            Separate by width / line breaks, send to children.
            The left and right children are initialized by the first two
            values in the array. There must be at least two lines present in
            the array - if there wasn't enough content for two lines, we
            wouldn't have reached this point in the if/else structure.
            */
            Array<text> lines = SplitIntoLines(value)
            leftChild:Initialize(lines:RemoveFromFront(), leafSize, fibonacci, false)

            text secondLine = lines:RemoveFromFront()
            if lines:IsEmpty()
                rightChild:Initialize(secondLine, leafSize, fibonacci, keepEmptyEndLine)
            else
                rightChild:Initialize(secondLine, leafSize, fibonacci, false)
            end

            repeat while not lines:IsEmpty()
                MultipleLineText newNode
                newNode:Initialize(lines:RemoveFromFront(), leafSize, fibonacci, false)
                if (not keepEmptyEndLine) and lines:IsEmpty() and newNode:GetText():GetSize() = 0
                    // Don't add the last line if it's empty and we're not
                    // explicitly asked to keep it.
                else
                    rightChild = rightChild:Concatenate(newNode)
                end
            end

            SetChildren(leftChild, rightChild)
        end
    end

    private action TextFitsInLine(text value) returns boolean
        integer index = value:IndexOf(lineSeparator)
        if index not= -1 and index not= value:GetSize() - lineSeparator:GetSize()
            return false
        end

        // For monospaced fonts. This check differs for other conditions.
        return value:GetSize() <= maxLeafSize
    end

    private action SplitIntoLines(text value) returns Array<text>
        Array<text> lines = Split(value, lineSeparator)

        // Line wrapping will be handled here when it is supported.

        return lines
    end

    /*
    If both MultipleLineTexts are defined, they are set to be the left and right children.
    If one of the two MultipleLineTexts is not defined, this MultipleLineText is set to the values of
    the defined child. If neither is defined, this action does nothing.
    */
    private action SetChildren(MultipleLineText leftChild, MultipleLineText rightChild)
        if leftChild not= undefined 
            if rightChild not= undefined
                left = leftChild
                right = rightChild
                weight = left:GetSize()
                leafWeight = left:GetLineCount()
                leafCount = left:GetLineCount() + right:GetLineCount()
                fibonacciArray = left:GetFibonacciArray()
                SetDepth(left, right)
            else
                weight = leftChild:GetWeight()
                leafWeight = leftChild:GetLeafWeight()
                leafCount = leftChild:GetLineCount()
                characters = leftChild:GetCharacters()
                right = leftChild:GetRight()
                left = leftChild:GetLeft()
                fibonacciArray = leftChild:GetFibonacciArray()
                SetDepth(leftChild:GetLeft(), leftChild:GetRight())
            end
        elseif rightChild not= undefined
            weight = rightChild:GetWeight()
            leafWeight = rightChild:GetLeafWeight()
            leafCount = rightChild:GetLineCount()
            characters = rightChild:GetCharacters()
            left = rightChild:GetLeft()
            right = rightChild:GetRight()
            fibonacciArray = rightChild:GetFibonacciArray()
            SetDepth(rightChild:GetLeft(), rightChild:GetRight())
        end
    end

    private action SetDepth(MultipleLineText left, MultipleLineText right)
        integer max = 0
        if left not= undefined
            max = left:GetDepth() + 1
        end
        if right not= undefined and right:GetDepth() + 1 > max
            max = right:GetDepth() + 1
        end
        depth = max
    end

    private action GetLeft returns MultipleLineText
        return left
    end

    private action GetRight returns MultipleLineText
        return right
    end

    private action GetCharacters returns text
        return characters
    end

    private action GetWeight returns integer
        return weight
    end

    private action GetLeafWeight returns integer
        return leafWeight
    end

    private action GetDepth returns integer
        return depth
    end

    private action GetFibonacciArray returns Array<integer>
        return fibonacciArray
    end

    private action IsLeaf returns boolean
        return right = undefined and left = undefined
    end

    private action GetTextWidth(text value) returns number
        if value:Contains(lineSeparator)
            return maxLeafSize
        end

        // For monospaced fonts.
        return value:GetSize()
    end

    private action CharactersToBackfill(text target, text provider) returns integer
        integer counter = 0
        integer providerSize = provider:GetSize()
        // Revisit this later. TextFitsInLine checks the whole string when we
        // only need to check the most recent potential character addition.
        repeat while counter < providerSize
            target = target + provider:GetCharacter(counter)
            if TextFitsInLine(target)
                counter = counter + 1
            else
                return counter
            end
        end

        return counter
    end

    
    /*
    Ensures that the line at the given index contains as much content as
    possible by testing to see if some contents of the next line should be moved
    up. If this changes the contents of the next line, it may refill that one,
    which can cascade to possibly include all lines later in the text.
    */
    private action RefillLine(integer lineIndex) returns MultipleLineText
        // Don't attempt to refill the last line, or an invalidly large line index.
        if lineIndex >= GetLineCount() - 1
            return me
        end

        MultipleLineText refillingTree = GetLine(lineIndex)
        MultipleLineText providingTree = GetLine(lineIndex + 1)
        text refillText = refillingTree:GetText()
        text providingText = providingTree:GetText()

        integer toFill = CharactersToBackfill(refillText, providingText)
        if toFill = 0
            // If the providing text was empty somehow, delete the empty line and
            // continue. Most likely this occurs because the last line was empty
            // (without text wrapping, it's the only line legally allowed to be
            // empty).
            if providingText:IsEmpty()
                MultipleLineText result = RemoveFromLine(lineIndex + 1, 0)
                return result:RefillLine(lineIndex + 1)
            else
                return me
            end
        end

        integer startIndex = CharacterIndexFromLineIndex(lineIndex) + refillText:GetSize()

        MultipleLineText result = AppendToLine(lineIndex, providingText:GetSubtext(0, toFill))
        result = result:RemoveFromLine(lineIndex + 1, toFill)

        // Use an insertion to place it at the end of the correct leaf, then
        // remove the duplicate entry in the next leaf.
//        MultipleLineText result = Insert(startIndex, providingText:GetSubtext(0, toFill))
//        result = result:Delete(startIndex + toFill, startIndex + toFill * 2)

        // Repeat this action on the next line - if it needs readjusting, it'll
        // perform it. Otherwise, it just returns the tree.
        return result:RefillLine(lineIndex + 1)
    end

    /*
    Appends the given text to the end of the line at the given index.
    */
    private action AppendToLine(integer lineIndex, text value) returns MultipleLineText
        integer weight = GetLeafWeight()
        if IsLeaf()
            return RecursiveInsert(characters:GetSize(), value)
        elseif lineIndex >= weight
            MultipleLineText newRoot
            MultipleLineText newRight = right:AppendToLine(lineIndex - weight, value)
            newRoot:SetChildren(left, newRight)
            return newRoot
        else
            MultipleLineText newRoot
            MultipleLineText newLeft = left:AppendToLine(lineIndex, value)
            newRoot:SetChildren(newLeft, right)
            return newRoot
        end
    end

    /*
    Remove the specified number of characters from the beginning of the line.
    Doesn't preserve empty lines at the end of the MultipleLineText.
    */
    private action RemoveFromLine(integer lineIndex, integer count) returns MultipleLineText
        integer weight = GetLeafWeight()
        if IsLeaf()
            return RecursiveDelete(0, count, false)
        elseif lineIndex >= weight
            MultipleLineText newRoot
            MultipleLineText newRight = right:RemoveFromLine(lineIndex - weight, count)
            newRoot:SetChildren(left, newRight)
            return newRoot
        else
            MultipleLineText newRoot
            MultipleLineText newLeft = left:RemoveFromLine(lineIndex, count)
            newRoot:SetChildren(newLeft, right)
            return newRoot
        end
    end

    /* 
    A custom implementation of the text Split action that doesn't remove the
    delimiter characters - each entry in the returned array will include the
    delimiter as the last character, except for the final entry. If the text
    being split ends with a delimiter, a final entry containing the empty string
    will be inserted.
    */
    private action Split(text splitter, text delimiter) returns Array<text>
        // TODO: Rewrite this. it is horrid. There are much more clever ways to do this.

	Array<text> results
	integer pos = 0
	integer length = splitter:GetSize()
	Text delim
        delim:SetValue(delimiter)
	integer delimLength = delim:GetSize()
	text newString = ""

	repeat while pos < length
            // If this doesn't start the delimiter, add it to the new string.
            if splitter:GetCharacter(pos) not= delim:GetCharacter(0)
                newString = newString + splitter:GetCharacter(pos)
                pos = pos + 1
            else
                // Matches start of delimiter. Keep track and bail if we don't match the delimiter
                text tmpString = ""
                integer delimPos = 0
                text currentChar = splitter:GetCharacter(pos)
                text currentDelimChar = delim:GetCharacter(0)

                // As long as the values read continue to match the delimiter...
                repeat while delimPos < delimLength and currentChar = currentDelimChar and pos < length
                    tmpString = tmpString + splitter:GetCharacter(pos)
                    delimPos = delimPos + 1 // keep going through delimiter
                    pos = pos + 1 // and keep moving ahead in main string
                    
                    if pos < length
                        currentChar = splitter:GetCharacter(pos)
                    end

                    if delimPos < delimLength
                        currentDelimChar = delim:GetCharacter(delimPos)
                    end
                end

                // Whether or not it's a delimiter, we add it to the end of the
                // current string. This results in always preserving delimiters
                // at the end of strings.
                newString = newString + tmpString

                if delimPos = delimLength
                    // Delimiter hit. Store the result.
                    results:Add(newString)
                    newString = ""  
                end
            end
	end

        // Add the last string to the results.
        results:Add(newString)

        return results
    end

    /*
    Returns the i-th Fibonacci number. Previously calculated results are
    memoized in an Array that is shared between all related MultipleLineText nodes.
    */
    private action GetFibonacciNumber(integer i) returns integer
        if i < fibonacciArray:GetSize()
            return fibonacciArray:Get(i)
        else
            integer index = fibonacciArray:GetSize() - 1
            repeat while index < i
                fibonacciArray:Add(fibonacciArray:Get(index) + fibonacciArray:Get(index - 1))
                index = index + 1
            end

            return fibonacciArray:Get(i)
        end
    end

    /*
    This action retrieves a character at the given index from the tree.

    Attribute: Parameter index The index to retrieve a character from.
    Attribute: Returns A single character located at the given index.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree
    tree:Initialize("Hello world!")
    text character = tree:GetCharacter(1)
    output "The character at index 1 is '" + character + "'."
    */
    action GetCharacter(integer index) returns text
        integer weight = GetWeight()
        if index >= weight
            return right:GetCharacter(index - weight) 
        elseif left not= undefined
            return left:GetCharacter(index)
        else
            return characters:GetCharacter(index)
        end
    end

    /*

    */
    action GetLine(integer index) returns MultipleLineText
        integer weight = GetLeafWeight()
        if IsLeaf()
            return me
        elseif index >= weight
            return right:GetLine(index - weight) 
        else
            return left:GetLine(index)
        end
    end

    /*
    This action gets the index of the line which contains the character at the 
    given character index position in the text.
    */
    action LineIndexFromCharacterIndex(integer index) returns integer
        integer weight = GetWeight()
        if index >= weight
            if right not= undefined
                return right:LineIndexFromCharacterIndex(index - weight) + GetLeafWeight()
            else
                return 0
            end
        elseif left not= undefined
            return left:LineIndexFromCharacterIndex(index)
        else
            return 0
        end
    end

    /*
    This action gets the index of the first character in the line at the given
    line index.
    */
    action CharacterIndexFromLineIndex(integer index) returns integer
        integer weight = GetLeafWeight()
        if IsLeaf()
            return 0
        elseif index >= weight
            return right:CharacterIndexFromLineIndex(index - weight) + GetWeight()
        else
            return left:CharacterIndexFromLineIndex(index)
        end
    end

    /*
    The Concatenate action creates a new MultipleLineText where the provided tree is
    appended to the end of this tree. All text in the parameter tree will appear
    after the text from this tree inside the returned value. This tree will not
    change as a result of this action.

    Attribute: Parameter textTree The tree to append to the end of this tree.
    Attribute: Returns A new MultipleLineText which contains the concatenation of the two trees.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree1
    tree1:Initialize("Hello ")

    MultipleLineText tree2
    tree2:Initialize("world!")

    MultipleLineText result = tree1:Concatenate(tree2)
    output result:GetText()
    */
    action Concatenate(MultipleLineText textTree) returns MultipleLineText
        MultipleLineText newRoot

        /* 
        Directly reusing this node is fine so long as MultipleLineTexts don't store
        a reference to their parent. If they do store such a reference, then
        a new copy needs to be made because the parent will change due to
        this operation.
        */
        newRoot:SetChildren(me, textTree)

        // Check if tree needs to be rebalanced before returning.
        if newRoot:NeedsBalancing()
            newRoot = newRoot:Balance()
        end

        return newRoot
    end

    /*
    The Concatenate action creates a new MultipleLineText where the provided text is
    appended to the end of this tree's text. This tree will not change as a 
    result of this action.

    Attribute: Parameter value The text to append onto the end of this tree's text.
    Attribute: Returns A new MultipleLineText which contains the concatenation of this tree's text and the parameter text.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree
    tree:Initialize("Hello ")

    MultipleLineText result = tree:Concatenate("world!")
    output result:GetText()
    */
    action Concatenate(text value) returns MultipleLineText
        
        MultipleLineText result = RecursiveConcatenate(value)

        if value:EndsWith(lineSeparator)
            // Manually insert a blank line at the end of the tree.
            MultipleLineText newLine
            newLine:Initialize("", maxLeafSize, fibonacciArray, false)
            
            result = result:Concatenate(newLine)
        end

        return result
    end

    private action RecursiveConcatenate(Text value) returns MultipleLineText
        if IsLeaf()
            MultipleLineText newTree
            newTree:Initialize(characters + value:GetValue(), maxLeafSize, fibonacciArray, false)
            return newTree
        else
            MultipleLineText newRight = right:RecursiveConcatenate(value)
            MultipleLineText newTree
            newTree:SetChildren(left, newRight)
            return newTree
        end
    end

    /*
    This action returns true is the tree is imbalanced, or false if it is
    considered balanced. This is typically handled automatically by the tree
    itself.

    Attribute: Returns Whether or not the tree is currently imbalanced.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree
    tree:Initialize("Hello world!")
    boolean shouldRebalance = tree:NeedsBalancing()
    output "shouldRebalance is " + shouldRebalance

    if shouldRebalance
        tree:Balance()
    end
    */
    action NeedsBalancing returns boolean
        return GetLineCount() < GetFibonacciNumber(GetDepth())
    end

    /*
    This action will create a new MultipleLineText containing the balanced contents of
    this tree. This is typically handled automatically by the tree itself
    during other operations which return new MultipleLineTexts.

    Attribute: Returns A new MultipleLineText which is balanced and contains the same text as this MultipleLineText.

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree
    tree:Initialize("Hello world!")
    boolean shouldRebalance = tree:NeedsBalancing()
    output "shouldRebalance is " + shouldRebalance

    if shouldRebalance
        tree:Balance()
    end
    */
    action Balance returns MultipleLineText
        Array<MultipleLineText> trees
        RecursiveBalance(trees)
        
        MultipleLineText result = undefined
        MultipleLineText current = undefined

        integer counter = 0
        repeat while counter < trees:GetSize()
            current = trees:Get(counter)
            if current not= undefined
                if result not= undefined
                    result = current:Concatenate(result)
                else
                    result = current
                end
            end
            counter = counter + 1
        end

        return result
    end

    private action RecursiveBalance(Array<MultipleLineText> trees)
        if IsLeaf()
            AddTree(me, trees, 0)
        else
            left:RecursiveBalance(trees)
            right:RecursiveBalance(trees)
        end
    end

    private action AddTree(MultipleLineText tree, Array<MultipleLineText> trees, integer startIndex)
        integer counter = startIndex
        MultipleLineText progress = undefined
        MultipleLineText current = undefined
        repeat while GetFibonacciNumber(counter) <= tree:GetLineCount()
            if trees:GetSize() > counter
                current = trees:Get(counter)
                if current not= undefined
                    if progress = undefined
                        progress = current
                    else
                        progress = current:Concatenate(progress)
                    end
                    trees:Set(counter, undefined)
                end
            else
                // Increase the size of the array.
                trees:Add(undefined)
            end
            counter = counter + 1
        end

        // Correct the last increment to the counter by the loop, which iterates
        // it 1 past where we want it (the last index checked).
        counter = counter - 1

        if progress not= undefined
            // Reinsert the concatenated tree into the structure. This can
            // possibly cascade into further concatenations.
            AddTree(progress:Concatenate(tree), trees, counter)
        else
            // No tree was found at the final index, so place the tree there.
            trees:Set(counter, tree)
        end
    end

    /*
    The Insert action creates a new MultipleLineText and inserts the given text value 
    into the tree at the provided index. The character that was previously
    located at that index will be positioned behind the newly inserted text.
    This action creates a new MultipleLineText, and has no effect on this tree.

    Attribute: Parameter index The index to begin inserting text at in the new tree.
    Attribute: Parameter value The text to be inserted into the new tree.
    Attribute: Returns A new MultipleLineText containing the inserted text.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree
    tree:Initialize("Hello world!")

    MultipleLineText insertTree = tree:Insert(11, " of tomorrow")
    output insertTree:GetText()
    */
    action Insert(integer index, text value) returns MultipleLineText
        if index < 0
            alert("I can not insert text at a negative index. I was asked to insert at index " + index + ".")
        end
        integer length = GetSize()
        if index > length
            alert("I can not insert text at the given index because the index is too large. I was asked to insert at index " + index + 
                ", but the last available index to insert at is " + GetSize() + ".")
        end

        if index = length
            return Concatenate(value)
        end

        integer size = GetLineCount()
        integer line = LineIndexFromCharacterIndex(index)

        MultipleLineText newTree = RecursiveInsert(index, value)

        integer newSize = newTree:GetLineCount()
        line = line + (newSize - size)
        newTree = newTree:RefillLine(line)
    
        if newTree:NeedsBalancing()
            newTree = newTree:Balance()
        end
        return newTree
    end

    action SetLine(integer index, text value) returns MultipleLineText
        integer count = GetLineCount()
        integer charIndex = CharacterIndexFromLineIndex(index)
        MultipleLineText oldLine = GetLine(index)
        integer oldLeafSize = oldLine:GetSize()

        MultipleLineText deleted = undefined
        if index = count - 1
            deleted = Delete(charIndex, charIndex + oldLeafSize)
        else
            deleted = Delete(charIndex, charIndex + oldLeafSize - 1)
        end
        
        MultipleLineText newTree = deleted:Insert(charIndex, value)
        return newTree
    end

    /*
    Recursive call that handles insertion. Separated out from the "original"
    insert call so that the recursive call does not handle certain one-time
    checks (i.e. bound checking, tree balancing).
    */
    private action RecursiveInsert(integer index, text value) returns MultipleLineText
        if IsLeaf()
            text newText = ""
            if index > 0
                newText = characters:GetSubtext(0, index)
            end
            newText = newText + value
            if index < characters:GetSize()
                newText = newText + characters:GetSubtext(index, characters:GetSize())
            end

            MultipleLineText newTree
            newTree:Initialize(newText, maxLeafSize, fibonacciArray, false)
            return newTree
        else
            MultipleLineText newTree
            MultipleLineText leftChild = left
            MultipleLineText rightChild = right
            if index < weight
                leftChild = left:RecursiveInsert(index, value)
            else
                rightChild = right:RecursiveInsert(index - weight, value)
            end
            newTree:SetChildren(leftChild, rightChild)
            return newTree
        end
    end

    /*
    The Delete action creates a new MultipleLineText which is a copy of this tree, then
    deletes all characters between the two given indices. The first index is
    inclusive (the character at the first index will be deleted) and the second
    index is exclusive (the character at the second index is not deleted).
    This action creates a new MultipleLineText, and has no effect on this tree.

    Attribute: Parameter startIndex The beginning of the range of characters to delete. The character at this index is deleted.
    Attribute: Parameter endIndex The end of the range of characters to delete. A character at this index is not deleted.
    Attribute: Returns A new MultipleLineText containing this tree's text, minus the deleted portion.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree
    tree:Initialize("Hello world!")

    MultipleLineText deleteTree = tree:Delete(5, tree:GetSize() - 1)
    output deleteTree:GetText()
    */
    action Delete(integer startIndex, integer endIndex) returns MultipleLineText
        if startIndex < 0
            alert("I can not delete text at a negative index. I was asked to delete between indices " + startIndex + " and " + endIndex + ".")
        end
        if endIndex > GetSize()
            alert("I couldn't delete the text from this MultipleLineText because I was asked to remove more text than was available. I was asked to delete between indices "  
                + startIndex + " and " + endIndex + ", but there are only " + GetSize() + " characters available.")
        end
        MultipleLineText newTree = RecursiveDelete(startIndex, endIndex, true)
        if newTree = undefined
            MultipleLineText emptyTree
            emptyTree:Initialize("", maxLeafSize, fibonacciArray, false)
            return emptyTree
        else
            newTree = newTree:RefillLine(LineIndexFromCharacterIndex(startIndex))
            if newTree:NeedsBalancing()
                newTree = newTree:Balance()
            end
        end
        return newTree
    end

    /*
    Recursive call that handles deletion. Separated out from the "original"
    delete call so that the recursive call does not handle certain one-time
    checks (i.e. bound checking, tree balancing).

    The "rightTraversal" boolean indicates that the call stack for a particular
    given delete call only contains calls that traveled to the right. In other
    words, if a leaf receives this call and the boolean is true, it must be the
    last leaf in the tree (and therefore has special consideration that it must
    not declare the tree to be undefined if it is empty - an empty last line
    is considered valid).
    */
    private action RecursiveDelete(integer startIndex, integer endIndex, boolean rightTraversal) returns MultipleLineText
        MultipleLineText newTree

        if not IsLeaf()
            MultipleLineText leftChild = undefined
            MultipleLineText rightChild = undefined

            if left not= undefined and startIndex < weight
                leftChild = left:RecursiveDelete(startIndex, endIndex, false)
            else
                leftChild = left
            end
            if right not= undefined and endIndex > weight
                rightChild = right:RecursiveDelete(startIndex - weight, endIndex - weight, rightTraversal)
            else
                rightChild = right
            end

            if leftChild = undefined and rightChild = undefined
                return undefined
            end

            newTree:SetChildren(leftChild, rightChild)
        else
            integer characterSize = characters:GetSize()
            if startIndex <= 0 and endIndex >= characterSize
                if not rightTraversal
                    /*
                    If all characters are deleted, don't return a new MultipleLineText, just
                    return undefined (there should no longer be a leaf at this
                    position in the tree).
                    */
                    return undefined
                else
                    /*
                    If this is a leaf and rightTraversal = true, then this is
                    the last leaf in the tree. The last leaf in the tree is
                    allowed to be empty.
                    */
                    newTree:Initialize("", maxLeafSize, fibonacciArray, false)
                end
            else
                text newText = ""
                if startIndex > 0
                    newText = characters:GetSubtext(0, startIndex)
                end
                if endIndex < characterSize
                    newText = newText + characters:GetSubtext(endIndex, characterSize)
                end
                newTree:Initialize(newText, maxLeafSize, fibonacciArray, false)
            end
        end

        return newTree
    end

    /*
    This action returns the text between the two indices. The first index is
    inclusive (the character at the first index is part of the returned text)
    and the second index is exclusive (the character at the second index is not
    part of the returned text). 

    Attribute: Parameter startIndex The beginning of the range of characters to return. This index is included in the returned value.
    Attribute: Parameter endIndex The end of the range of characters to return. This index is not included in the returned value.
    Attribute: Returns The text between the two indices.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree
    tree:Initialize("Hello world!")
    output tree:GetText(1, 10)
    */
    action GetText(integer startIndex, integer endIndex) returns text
        if startIndex < 0
            alert("I can not find text at a negative index. I was asked to search between indices " + startIndex + " and " + endIndex + ".")
        end
        if endIndex > GetSize()
            alert("I couldn't return the text from this MultipleLineText because I was asked to provide more text than was available. I was asked to search between indices "  
                + startIndex + " and " + endIndex + ", but there are only " + GetSize() + " characters available to return.")
        end
        return RecursiveGetText(startIndex, endIndex)
    end

    /*
    Returns the text between the start and end indices, but performs no error
    checking. The original values provided must be valid - to guarantee valid
    original values, use GetText. This action may call itself using extreme
    values (i.e., negative indices or overly large indices), in which case all
    values are bounded to the legal values to retrieve characters from a leaf.
    */
    private action RecursiveGetText(integer startIndex, integer endIndex) returns text

        if IsLeaf()
            if startIndex < 0
                startIndex = 0
            end
            if endIndex > characters:GetSize()
                endIndex = characters:GetSize()
            end
            return characters:GetSubtext(startIndex, endIndex)
        end

        text value = ""
        if startIndex < weight
            value = left:RecursiveGetText(startIndex, endIndex)
            
            if endIndex > weight
                value = value + right:RecursiveGetText(startIndex - weight, endIndex - weight)
            end
        else
            value = right:RecursiveGetText(startIndex - weight, endIndex - weight)
        end

        return value
    end

    /*
    This action returns all of the text stored in the MultipleLineText.

    Attribute: Returns The text stored in this MultipleLineText.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree
    tree:Initialize("Hello world!")
    output tree:GetText()
    */
    action GetText returns text
        text leftText = ""
        text rightText = ""
        if IsLeaf()
            return characters
        end

        if left not= undefined
            leftText = left:GetText()
        end
        if right not= undefined
            rightText = right:GetText()
        end
        return leftText + characters + rightText
    end

    /*
    This action returns the length of the text stored in the MultipleLineText.

    Attribute: Returns The length of text in this MultipleLineText.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText tree
    tree:Initialize("Hello world!")
    output "The length of the text in the tree is " + tree:GetSize()
    */
    action GetSize returns integer
        if right not= undefined
            return GetWeight() + right:GetSize()
        end
        return GetWeight()
    end

    /*

    */
    action GetWidth returns number
        if IsLeaf()
            // For monospaced fonts.
            return characters:GetSize()
        else
            number leftWidth = left:GetWidth()
            number rightWidth = right:GetWidth()
            if leftWidth > rightWidth
                return leftWidth
            else
                return rightWidth
            end
        end
    end

    /*

    */
    action GetLineCount returns integer
        return leafCount
    end

    /*
    This action sets how many characters should be stored in each leaf of the
    MultipleLineText.

    Attribute: Parameter size How many characters to store in each leaf.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText defaultTree
    defaultTree:Initialize("Hello world! What a lovely day!")
    output "The default tree stores text in " + defaultTree:GetLeafSize() + " character chunks."

    MultipleLineText newTree
    newTree:SetLeafSize(10)
    newTree:Initialize("Hello world! What a lovely day!")
    output "The new tree stores text in " + newTree:GetLeafSize() + " character chunks."
    */
    action SetLeafSize(integer size)
        maxLeafSize = size
        if left not= undefined
            left:SetLeafSize(size)
        end
        if right not= undefined
            right:SetLeafSize(size)
        end
    end

    /*
    This action returns how many characters can be stored in each leaf of the
    MultipleLineText.

    Attribute: Returns How many characters can be stored in each leaf.

    Attribute: Example

    use Libraries.Containers.MultipleLineText

    MultipleLineText defaultTree
    defaultTree:Initialize("Hello world! What a lovely day!")
    output "The default tree stores text in " + defaultTree:GetLeafSize() + " character chunks."

    MultipleLineText newTree
    newTree:SetLeafSize(10)
    newTree:Initialize("Hello world! What a lovely day!")
    output "The new tree stores text in " + newTree:GetLeafSize() + " character chunks."
    */
    action GetLeafSize returns number
        return maxLeafSize
    end

    action DisableTextWrapping returns MultipleLineText
        maxLeafSize = maxLeafSize:GetPositiveInfinityValue()
        // TO-DO:
        // Change leaves if necessary, if not return me
        // Changing the leaf size / wrapping style means recreating nodes
        // (can't reuse any nodes because they all share the same values)
        return me
    end

    // TO-DO: Implement text wrapping
    
    /*

    */
    action GetLines returns Array<MultipleLineText>
        Array<MultipleLineText> array
        return GetLines(array)
    end

    /*

    */
    action GetLines(Array<MultipleLineText> array) returns Array<MultipleLineText>
        if IsLeaf()
            array:Add(me)
        else
            if left not= undefined
                left:GetLines(array)
            end
            if right not= undefined
                right:GetLines(array)
            end
        end
        return array
    end

    /*
    The GetLineSeparator action returns the text which is used to designate the
    end of a line in the MultipleLineText. By default, this is the same as the 
    value used by the operating system.

    Attribute: Returns The character(s) used to designate the end of a line.
    */
    action GetLineSeparator returns text
        return lineSeparator
    end

    /*
    The SetLineSeparator action sets which character(s) should be used to 
    signify the end of a line.

    Attribute: Parameter separator The character(s) to be used to mark the end of a line of text.
    */
    action SetLineSeparator(text separator)
        if IsLeaf()
            if characters:EndsWith(lineSeparator)
                text preText = ""
                if characters:GetSize() > lineSeparator:GetSize()
                    preText = characters:GetSubtext(0, characters:GetSize() - lineSeparator:GetSize())
                end
                characters = preText + separator
            end
        else
            left:SetLineSeparator(separator)
            right:SetLineSeparator(separator)
        end

        lineSeparator = separator
    end

    /*
    The GetDefaultLineSeparator action returns the default character(s) used by
    the MultipleLineText to signify the end of a line of text. This is the same 
    line separating characters that are used by the running operating system.

    Attribute: Returns The default characters used to indicate the end of a line of text.
    */
    action GetDefaultLineSeparator returns text
        text lineFeed = ""
        return lineFeed:GetLineFeed()
    end
end