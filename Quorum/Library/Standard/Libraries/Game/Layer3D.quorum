package Libraries.Game

use Libraries.Interface.Item
use Libraries.Interface.Item3D
use Libraries.Interface.Accessibility
use Libraries.Interface.Events.MouseEvent
use Libraries.Interface.Events.TouchEvent
use Libraries.Interface.Events.ResizeEvent
use Libraries.Interface.Events.MouseListener
use Libraries.Interface.Events.MouseMovementListener
use Libraries.Interface.Events.MouseWheelListener
use Libraries.Interface.Events.TouchListener
use Libraries.Interface.Events.CollisionEvent3D
use Libraries.Interface.Events.CollisionListener3D
use Libraries.Containers.Array
use Libraries.Containers.Iterator
use Libraries.Game.Graphics.Camera
use Libraries.Game.Graphics.PerspectiveCamera
use Libraries.Game.Graphics.GraphicsManager
use Libraries.Game.Graphics.Painter3D
use Libraries.Game.Graphics.Environment
use Libraries.Game.Graphics.Light
use Libraries.Game.Graphics.PointLight
use Libraries.Game.Graphics.DirectionalLight
use Libraries.Game.Graphics.AmbientLight
use Libraries.Game.Graphics.DirectionalLightsAttribute
use Libraries.Game.Graphics.PointLightsAttribute
use Libraries.Game.Graphics.Skybox
use Libraries.Game.Collision.CollisionManager3D
use Libraries.Game.Collision.CollisionEdge3D
use Libraries.Compute.Ray
use Libraries.Compute.Vector3
use Libraries.Compute.Matrix4
use Libraries.Game.Physics.CollisionGroup3D
use Libraries.Containers.Stack
use Libraries.Game.Collision.PhysicsPosition3D
use Libraries.Game.Physics.CollisionSolverInformation3D
use Libraries.Game.Physics.Joints.Joint3D
use Libraries.Game.Physics.Joints.JointEdge3D
use Libraries.Compute.Math
use Libraries.Compute.Quaternion
use Libraries.System.SystemHelper
use Libraries.Language.Errors.ConcurrencyError
use Libraries.Interface.Events.GestureListener
use Libraries.Interface.Events.GestureEvent

/*
The Layer3D class is used to manage a number of 3D objects, as well as manage
input. The Layer2D effectively consists of a 3D "world", where all objects added
to it exist in the same space and can interact with each other.

Attribute: Author William Allee

Attribute: Example

use Libraries.Game.Game
use Libraries.Game.Layer3D
use Libraries.Game.Graphics.Model
use Libraries.Game.Graphics.Color

class Main is Game

    action Main
        StartGame()
    end

    action CreateGame
        Color color

        Model box
        box:LoadBox(2, 2, 2, color:Maroon())
        box:SetPosition(-2, 0, 2)

        Model sphere
        sphere:LoadSphere(2, 2, 2, color:Teal())
        sphere:SetPosition(2, 0, 2)

        Layer3D layer
        layer:Add(box)
        layer:Add(sphere)
        AddLayer(layer)
    end

    action Update(number seconds)
    end
end
*/
class Layer3D is Layer

    Array<Item3D> items
    Array<MouseListener> mouseListeners
    Array<MouseMovementListener> mouseMovementListeners
    Array<MouseWheelListener> mouseWheelListeners
    Array<TouchListener> touchListeners
    Array<GestureListener> gestureListeners
    Array<Joint3D> joints
    Camera camera = undefined
    Painter3D painter
    Environment environment
    Skybox skybox = undefined
    GameStateManager manager
    SystemHelper systemHelper
    GraphicsManager graphics = undefined

    boolean newItemAdded = false

    CollisionManager3D collisionManager

    boolean physicsEnabled = false
    boolean automaticallyClearForces = true
    boolean warmStarting = true
    boolean continuousPhysics = false
    boolean subStepping = false
    boolean stepComplete = true
    boolean requireSimulation = false
    Math math

    number inverseDeltaTime0 = 0

    Vector3 gravity

    number physicsTimeStep = 1.0 / 60.0
    integer maxSubSteps = 1


    number localTime = 1.0 / 60.0
    /*
    This array is used when adding or removing Items to the game to find any
    lights in the children hierarchy that need to be added/removed from the
    environment at the same time. Since it will be reused often, the array
    should be emptied after each use.
    */
    Array<Light> lightGatheringArray
    /* This allows us to turn off collisions for the entire game. */
    private boolean collide = true

    /*
    This array is used when processing mouse or touch events. It stores the
    possible candidates for mouse and touch events. Since it will be reused
    often, it must be emptied after each use.
    */
    Array<Item3D> eventTargetArray
    Item3DDepthComparison depthSorter

    on create
        SetName("Layer3D")

        PerspectiveCamera cam
        camera = cam
        camera:SetPosition(0, 3, -5)
        camera:LookAt(0, 0, 0)
        camera:Update()
        SetViewport(0, 0, manager:GetGameDisplay():GetWidth(), manager:GetGameDisplay():GetHeight())
        painter:SetEnvironment(environment)
        painter:SetCamera(camera)

        graphics = manager:GetGameGraphics()
    end

    /* This allows us to know if collisions are on or off for the layer. */
    action IsColliding returns boolean
        return collide
    end

    /* This allows us to turn collisions on or off for the layer. */
    action SetColliding(boolean collide)
        me:collide = collide
    end

    /*
    This action ensures that the current thread is the same as the main GUI
    thread. Certain kinds of actions like adding or removing items should only
    be done on the GUI thread.

    If this code is being called from outside the GUI thread, it alerts a
    ConcurrencyException.
    */
    private action EnsureCorrectThread
        if (manager:GetApplication() is DesktopApplication) and (manager:GetMainThreadName() not= systemHelper:GetThreadName())
            ConcurrencyError error
            error:SetErrorMessage("I can only add or remove items from the Game on the main thread, but I was asked to do so on a different thread.")
            alert(error)
        end
    end

    /*
    This action will add an Item3D to this Layer. It will be updated along with
    the rest of the layer, and will be drawn on the screen (if it is visible and
    possible to draw the given Item3D). The Item3D will be added to the back of
    the layer's internal array of items.

    Attribute: Parameter item The Item3D to be added to the layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            // Item3D objects aren't visible, but can still be used for game logic.
            Item3D area
            area:SetWidth(5)
            area:SetHeight(5)
            area:SetDepth(5)
            area:SetPosition(0, 10, 0)

            // Models inherit from Item3D, so they can be added too.
            Model cylinder
            Color color
            cylinder:LoadCylinder(2, 4, 2, color:Orange())
            cylinder:SetPosition(0, 0, 3)

            Layer3D layer
            layer:Add(area)
            layer:Add(cylinder)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end
    */
    action Add(Item3D item)
        EnsureCorrectThread()

        item:SetLayer(me)
        items:Add(item)
        EnableItemLighting(item)
        newItemAdded = true

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Add(item)
        end
    end

    /*
    This action will add an Item3D to this Layer's array of items at the index
    location. It will be updated along with the rest of the layer, and will be 
    drawn on the screen (if it is visible and possible to draw the given Item3D).

    Attribute: Parameter index The index to store the item at in the layer's array of items.
    Attribute: Parameter item The Item3D to be added to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            // Item3D objects aren't visible, but can still be used for game logic.
            Item3D area
            area:SetDimensions(5, 5, 5)
            area:SetPosition(0, 10, 10)

            // Models inherit from Item2D, so they can be added too.
            Model box
            Color color
            box:LoadBox(3, 3, 3, color:Green())
            box:SetPosition(0, 0, 2)

            Layer3D layer
            layer:Add(0, area)
            layer:Add(1, box)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end
    */
    action Add(integer index, Item3D item)
        EnsureCorrectThread()

        item:SetLayer(me)
        items:Add(index, item)
        newItemAdded = true

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Add(item)
        end
    end

    /*
    This action will add an Item3D to this layer's array of items at index 0. 
    It will be updated along with the rest of the layer, and will be drawn on 
    the screen (if it is visible and possible to draw the given Item3D). Adding
    an item to the front will cause it to be drawn and updated before other
    items in the layer, and other drawn items will appear to be on top of it.

    Attribute: Parameter item The item to add to the front of the layer's item array.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            // Item3D objects aren't visible, but can still be used for game logic.
            Item3D area
            area:SetDimensions(5, 5, 5)
            area:SetPosition(0, 0, 5)

            // Models inherit from Item3D, so they can be added too.
            Model cylinder
            Color color
            cylinder:LoadCylinder(3, 3, 3, color:Teal())
            cylinder:SetPosition(1, 0, 1)

            Layer3D layer
            layer:AddToFront(area)
            layer:AddToFront(cylinder)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end
    */
    action AddToFront(Item3D item)
        EnsureCorrectThread()

        item:SetLayer(me)
        items:AddToFront(item)
        newItemAdded = true

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Add(item)
        end
    end

    /*
    This action will clear all the items in this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color

            Model box
            box:LoadBox(2, 2, 2, color:Red())
            box:SetPosition(0, 0, 2)

            Layer3D layer
            layer:Add(box)
            AddLayer(layer)

            layer:Empty()
        end

        action Update(number seconds)
        end
    end
    */
    action Empty
        Iterator<Item3D> it = items:GetIterator()
        repeat while it:HasNext()
            Item3D body = it:Next()
            CollisionEdge3D edge = body:GetCollisionList()
            repeat while edge not= undefined
                CollisionEdge3D edge0 = edge
                edge = edge:GetNext()
                collisionManager:Destroy(edge0:GetCollision())
            end
            body:SetCollisionList(undefined)

            body:DestroyNodes(collisionManager:GetBroadphase())
            body:SetCollidable(false)
            body:SetLayer(undefined)
        end
        items:Empty()
    end

    /*
    This action will remove an Item3D from this layer. If the item was not a
    part of this layer, this action will have no effect.

    Attribute: Parameter item The item to remove from this layer.

    Attribute: Returns Whether or not the item was found and removed from the layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Orange())
            box:SetPosition(0, 0, 2)

            Layer3D layer
            layer:Add(box)
            AddLayer(layer)

            layer:Remove(box)
        end

        action Update(number seconds)
        end
    end
    */
    action Remove(Item3D item)
        EnsureCorrectThread()

        if IsColliding()
CollisionEdge3D edge = item:GetCollisionList()
        repeat while edge not= undefined
            CollisionEdge3D edge0 = edge
            edge = edge:GetNext()
            collisionManager:Destroy(edge0:GetCollision())
        end
        item:SetCollisionList(undefined)

        item:DestroyNodes(collisionManager:GetBroadphase())
        item:SetCollidable(false)
        end

        item:SetLayer(undefined)
        items:Remove(item)
        DisableItemLighting(item)

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Remove(item)
        end
    end

    /*
    This action will remove an Item3D at the index location from this layer's 
    array of items, and return the item that was removed.

    Attribute: Parameter index The index to remove an item from in this layer's array of items.

    Attribute: Returns The item that was removed from the item array in the layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model cube
            cube:LoadBox(3, 3, 3, color:Maroon())
            cube:SetPosition(0, 0, 2)

            Layer3D layer
            layer:Add(cube)
            AddLayer(layer)

            Item3D item = layer:RemoveAt(0)
        end

        action Update(number seconds)
        end
    end
    */
    action RemoveAt(integer index) returns Item3D
        EnsureCorrectThread()

        Item3D item = items:RemoveAt(index)

        if IsColliding()
CollisionEdge3D edge = item:GetCollisionList()
        repeat while edge not= undefined
            CollisionEdge3D edge0 = edge
            edge = edge:GetNext()
            collisionManager:Destroy(edge0:GetCollision())
        end
        item:SetCollisionList(undefined)

        item:DestroyNodes(collisionManager:GetBroadphase())
        item:SetCollidable(false)
            
        end
        
        item:SetLayer(undefined)

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Remove(item)
        end

        return item
    end 

    /*
    This action will remove an Item3D from the front of the array of items in
    this layer, and return the item that was removed. This is functionally the
    same as calling "RemoveAt(0)".

    Attribute: Returns The item that was removed from the front of the layer's item array.
    
    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model cylinder
            cylinder:LoadCylinder(2, 4, 2, color:Pink())
            cylinder:SetPosition(0, 0, 2)

            Layer3D layer
            layer:Add(cylinder)
            AddLayer(layer)

            Item3D item = layer:RemoveFromFront()
        end

        action Update(number seconds)
        end
    end
    */
    action RemoveFromFront returns Item3D
        EnsureCorrectThread()

        Item3D item = items:RemoveFromFront()

        if IsColliding()
CollisionEdge3D edge = item:GetCollisionList()
        repeat while edge not= undefined
            CollisionEdge3D edge0 = edge
            edge = edge:GetNext()
            collisionManager:Destroy(edge0:GetCollision())
        end
        item:SetCollisionList(undefined)

        item:DestroyNodes(collisionManager:GetBroadphase())
        item:SetCollidable(false)
        end
        

        item:SetLayer(undefined)

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Remove(item)
        end

        return item
    end

   /*
    This action will remove an Item3D from the end of the array of items in
    this layer, and return the item that was removed.

    Attribute: Returns The item that was removed from the end of the layer's item array.
    
    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model cylinder
            cylinder:LoadCylinder(2, 4, 2, color:Pink())
            cylinder:SetPosition(0, 0, 2)

            Layer3D layer
            layer:Add(cylinder)
            AddLayer(layer)

            Item3D item = layer:RemoveFromEnd()
        end

        action Update(number seconds)
        end
    end
    */
    action RemoveFromEnd returns Item3D
        EnsureCorrectThread()

        Item3D item = items:RemoveFromEnd()

        if IsColliding()
CollisionEdge3D edge = item:GetCollisionList()
        repeat while edge not= undefined
            CollisionEdge3D edge0 = edge
            edge = edge:GetNext()
            collisionManager:Destroy(edge0:GetCollision())
        end
        item:SetCollisionList(undefined)

        item:DestroyNodes(collisionManager:GetBroadphase())
        item:SetCollidable(false)
        end

        item:SetLayer(undefined)

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Remove(item)
        end

        return item
    end

    /*
    This action will get an Item3D stored in the layer at the given index in the
    layer's internal array of items.

    Attribute: Parameter index The index to retrieve an item from in the layer's array of items.

    Attribute: Returns The Item3D stored at the index in the array.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model sphere
            sphere:LoadSphere(3, 3, 3, color:White())
            sphere:SetPosition(0, 0, 2)

            Layer3D layer
            layer:Add(sphere)
            AddLayer(layer)

            Item3D item = layer:Get(0)
        end

        action Update(number seconds)
        end
    end
    */
    action Get(integer index) returns Item3D
        return items:Get(index)
    end

    /*
    This action will return the Item3D at the front of the layer's array of
    items. This is functionally the same as calling "Get(0)".

    Attribute: Returns The first item in the layer's array of items.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model cube
            cube:LoadBox(2, 2, 2, color:Yellow())
            cube:SetPosition(0, 0, 2)

            Layer3D layer
            layer:Add(cube)
            AddLayer(layer)

            Item3D item = layer:GetFromFront()
        end

        action Update(number seconds)
        end
    end
    */
    action GetFromFront returns Item3D
        return items:GetFromFront()
    end

    /*
    This action will return the item stored at the end of the layer's array of
    items.

    Attribute: Returns The last item in the layer's array of items.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model sphere
            sphere:LoadSphere(2, 2, 2, color:Green())
            sphere:SetPosition(0, 0, 2)

            Layer3D layer
            layer:Add(sphere)
            AddLayer(layer)

            Item3D item = layer:GetFromEnd()
        end

        action Update(number seconds)
        end
    end
    */
    action GetFromEnd returns Item3D
        return items:GetFromEnd()
    end

    /*
    This action will return an iterator of all the Item3D's stored inside this
    layer's array of items.

    Attribute: Returns An iterator containing all Item3D's stored in this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D
    use Libraries.Containers.Iterator

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Item3D item1
            Item3D item2
            Item3D item3

            Layer3D layer
            layer:Add(item1)
            layer:Add(item2)
            layer:Add(item3)
            AddLayer(layer)

            Iterator<Item3D> itemIterator = layer:GetIterator()
        end

        action Update(number seconds)
        end
    end
    */
    action GetIterator returns Iterator<Item3D>
        return items:GetIterator()
    end

    /*
    This action will return the number of items that have been added to this
    layer.

    Attribute: Returns The number of items stored in this layer's array of items.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Item3D item1
            Item3D item2
            Item3D item3

            Layer3D layer
            layer:Add(item1)
            layer:Add(item2)
            layer:Add(item3)
            AddLayer(layer)

            integer size = layer:GetSize()
            output "There are " + size + " items stored in the layer."
        end

        action Update(number seconds)
        end
    end
    */
    action GetSize returns integer
        return items:GetSize()
    end

    /*
    This action will return false if there are items stored in this layer's array
    of items, or true if there are none.

    Attribute: Returns Whether or not any items are stored in this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Item3D item1
            Item3D item2
            Item3D item3

            Layer3D layer
            boolean empty = layer:IsEmpty()
            output "IsEmpty() returned " + empty

            layer:Add(item1)
            layer:Add(item2)
            layer:Add(item3)

            empty = layer:IsEmpty()
            output "After adding items, IsEmpty() returns " + empty

            AddLayer(layer)            
        end

        action Update(number seconds)
        end
    end
    */
    action IsEmpty returns boolean
        return items:IsEmpty()
    end

    /*
    This action will set the value of the given index in the layer's array of 
    items to be the given Item3D. The previous value will be overwritten. If the
    index does not exist in the array (e.g., the given index is larger than the 
    number of items stored in this layer), an error will be thrown.

    Attribute: Parameter index What index to set inside the layer's array of items.
    Attribute: Parameter item The item to store at the given index in the array.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Item3D

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Item3D item1
            Item3D item2
            Item3D item3

            Layer3D layer
            layer:Add(item1)
            layer:Add(item2)
            layer:Set(1, item3)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end

    */
    action Set(integer index, Item3D item)
        /*
        Before overwriting the old data in the array, we want to make sure that
        any lights in the item's hierarchy are removed from the environment.
        */
        Item3D oldItem = items:Get(index)
        if oldItem not= undefined
            item:SetLayer(undefined)
            DisableItemLighting(oldItem)

            Accessibility accessibility = manager:GetAccessibility()
            if accessibility not= undefined
                accessibility:Remove(item)
            end
        end

        items:Set(index, item)

        /*
        We now also add the new item's lighting data to the environment.
        */
        if item not= undefined
            item:SetLayer(me)
            newItemAdded = true
            EnableItemLighting(item)

            Accessibility accessibility = manager:GetAccessibility()
            if accessibility not= undefined
                accessibility:Add(item)
            end
        end
    end

    /*
    This action will enable lighting for the given Item3D (if it is a light)
    and any of its children (if they are lights). This action is called
    automatically by the Layer when adding or removing items. Most users will
    never need to use this action directly.
    */
    action EnableItemLighting(Item3D item)
        // Find all lights in the item's children hierarchy.
        item:GetLights(lightGatheringArray)

        // Add all found lights to the environment.
        environment:Add(lightGatheringArray)

        // Empty the array after, to allow for re-use.
        lightGatheringArray:Empty()
    end

    /*
    This action will disable lighting for the given Item3D (if it is a light)
    and any of its children (if they are lights). This action is called
    automatically by the Layer when adding or removing items. Most users will
    never need to use this action directly.
    */
    action DisableItemLighting(Item3D item)
        // Find all lights in the item's children hierarchy.
        item:GetLights(lightGatheringArray)

        // Remove all found lights from the environment.
        environment:Remove(lightGatheringArray)

        // Empty the array after, to allow for re-use.
        lightGatheringArray:Empty()
    end

    /*
    This action will update all of the items contained within this Layer. The
    given number of seconds will be passed to each updated item. This is
    automatically called by the Game class as needed. Most users will never need
    to use this action directly.
    */
    action Update(number seconds)
        integer counter = 0
        repeat items:GetSize() times
            items:Get(counter):UpdateAll(seconds)
            counter = counter + 1
        end
    end

    /*
    This action will draw all items in this Layer on the screen (if they can be
    drawn and they aren't hidden). If the Layer is currently hidden, then this
    action will do nothing. This is automatically called by the Game class as 
    needed. Most users will never need to use this action directly.
    */
    action Draw
        if not IsShowing()
            return now
        end
        
        camera:Update()

        if (GetViewportX() not= graphics:GetViewportX() or GetViewportY() not= graphics:GetViewportY()
            or GetViewportWidth() not= graphics:GetViewportWidth() or GetViewportHeight() not= graphics:GetViewportHeight())

            graphics:SetViewport(GetViewportX(), GetViewportY(), GetViewportWidth(), GetViewportHeight())
        end

        painter:Begin()

        integer counter = 0
        repeat items:GetSize() times
            items:Get(counter):Draw(painter)
            counter = counter + 1
        end

        painter:End()
    end

    /*
    This action will set the camera being used by this Layer. The camera is used
    to determine what will be drawn on the screen. Objects will be drawn on the
    screen as they are seen by the Layer's set camera.

    Attribute: Parameter cam The camera that this layer should use.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.PerspectiveCamera

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            PerspectiveCamera camera
            Layer3D layer
            layer:SetCamera(camera)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end

    */
    action SetCamera(Camera cam)
        camera = cam
        painter:SetCamera(camera)
    end

    /*
    This action will return the camera being used by this Layer. The camera is used
    to determine what will be drawn on the screen. Objects will be drawn on the
    screen as they are seen by the Layer's set camera.

    Attribute: Returns The camera currently being used by this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Camera

    class Main is Game

        Camera layerCamera = undefined

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layerCamera = layer:GetCamera()
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end
    */
    action GetCamera returns Camera
        return camera
    end

    /*
    This action will notify mouse listeners that are a part of this layer of the
    given mouse event. This is called automatically by the Game engine as 
    needed. Most users will never need to use this action directly.

    Attribute: Parameter event The MouseEvent to send to the MouseListeners.
    Attribute: Returns The Item which intercepted the event, or undefined if no Item received the event.
    */
    action ProcessMouseEvent(MouseEvent event) returns Item
        Ray ray = camera:GetPickRay(camera:GetWidth() - event:GetX(), event:GetY())
        Vector3 origin = ray:GetOrigin()

        integer counter = 0
        Item3D temp = undefined
        Item result = undefined

        /*
        TO-DO: This array of all items is regenerated for each mouse event
        processed. It would be more efficient to maintain this array
        independently of this action.
        */
        Array<Item3D> allItems
        repeat items:GetSize() times
            GetChildrenHierarchy(items:Get(counter), allItems)
            counter = counter + 1
        end
        counter = 0

        repeat allItems:GetSize() times
            temp = allItems:Get(counter)
            if RayIntersectsItem(ray, temp)
                eventTargetArray:Add(temp)
            end

            counter = counter + 1
        end

        boolean processing = true

        if eventTargetArray:GetSize() not= 0
            depthSorter:SetOrigin(origin)
            eventTargetArray:Sort(depthSorter)
            counter = 0
            repeat while processing and counter < eventTargetArray:GetSize()
                event:SetSource(eventTargetArray:Get(counter))
                eventTargetArray:Get(counter):ProcessMouseEvent(event)
                processing = not event:WasEventHandled()
                if event:WasEventHandled()
                    result = eventTargetArray:Get(counter)
                end
                counter = counter + 1
            end

            eventTargetArray:Empty()
        end

        if processing
            if event:eventType = event:MOVED_MOUSE
                if mouseMovementListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat mouseMovementListeners:GetSize() times
                        mouseMovementListeners:Get(counter):MovedMouse(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:DRAGGED_MOUSE
                if mouseMovementListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat mouseMovementListeners:GetSize() times
                        mouseMovementListeners:Get(counter):DraggedMouse(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:CLICKED_MOUSE
                if mouseListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat mouseListeners:GetSize() times
                        mouseListeners:Get(counter):ClickedMouse(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:RELEASED_MOUSE
                if mouseListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat mouseListeners:GetSize() times
                        mouseListeners:Get(counter):ReleasedMouse(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:SCROLLED_MOUSE
                if mouseWheelListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat mouseWheelListeners:GetSize() times
                        mouseWheelListeners:Get(counter):ScrolledMouse(event)
                        counter = counter + 1
                    end
                end
            end
        end

        if event:GetSource() not= undefined and event:eventType = event:CLICKED_MOUSE
            event:GetSource():Focus()
        end

        return result
    end

    /*
    This action finds an Item on this layer which is present at the given coordinates
    and will respond to at least one of the given InputSets.
    */
    action GetItemWithInput(number x, number y, Array<InputSet> inputValues) returns Item
        Ray ray = camera:GetPickRay(camera:GetWidth() - x, y)
        Vector3 origin = ray:GetOrigin()

        integer counter = 0
        Game game = manager:GetGame()

        /*
        TO-DO: This array of all items is regenerated for each mouse event
        processed. It would be more efficient to maintain this array
        independently of this action.
        */
        Array<Item3D> allItems
        repeat items:GetSize() times
            GetChildrenHierarchy(items:Get(counter), allItems)
            counter = counter + 1
        end
        counter = 0

        repeat allItems:GetSize() times
            Item3D temp = allItems:Get(counter)
            if RayIntersectsItem(ray, temp)
                eventTargetArray:Add(temp)
            end

            counter = counter + 1
        end

        if eventTargetArray:GetSize() not= 0
            depthSorter:SetOrigin(origin)
            eventTargetArray:Sort(depthSorter)
            counter = 0
            repeat while counter < eventTargetArray:GetSize()
                Item3D item = eventTargetArray:Get(counter)
                InputTable table = game:GetInputTable(item:GetInputGroup())
                if table not= undefined
                    integer i = 0
                    repeat while i < inputValues:GetSize()
                        if table:HasKey(inputValues:Get(i))
                            return item
                        end
                        i = i + 1
                    end
                end
                counter = counter + 1
            end

            eventTargetArray:Empty()
        end

        return undefined
    end

    /*
    This action will notify touch listeners that are a part of this layer of the
    given touch event. This is called automatically by the Game engine as 
    needed. Most users will never need to use this action directly.

    Attribute: Parameter event The TouchEvent to send to the TouchListeners.
    */
    action ProcessTouchEvent(TouchEvent event) returns Item
        if event:GetX() < GetViewportX() or (event:GetX() > GetViewportX() + GetViewportWidth())
            or event:GetY() < GetViewportY() or (event:GetY() > GetViewportY() + GetViewportHeight())
            
            return undefined
        end

        Ray ray = camera:GetPickRay(camera:GetWidth() - event:GetX(), event:GetY())
        Vector3 origin = ray:GetOrigin()

        integer counter = 0
        Item3D temp = undefined
        Item result = undefined

        /*
        TO-DO: This array of all items is regenerated for each mouse event
        processed. It would be more efficient to maintain this array
        independently of this action.
        */
        Array<Item3D> allItems
        repeat items:GetSize() times
            GetChildrenHierarchy(items:Get(counter), allItems)
            counter = counter + 1
        end
        counter = 0

        repeat allItems:GetSize() times
            temp = allItems:Get(counter)
            if RayIntersectsItem(ray, temp)
                eventTargetArray:Add(temp)
            end

            counter = counter + 1
        end

        boolean processing = true

        if eventTargetArray:GetSize() not= 0
            depthSorter:SetOrigin(origin)
            eventTargetArray:Sort(depthSorter)
            counter = 0
            repeat while processing and counter < eventTargetArray:GetSize()
                event:SetSource(eventTargetArray:Get(counter))
                eventTargetArray:Get(counter):ProcessTouchEvent(event)
                processing = not event:WasEventHandled()
                if event:WasEventHandled()
                    result = eventTargetArray:Get(counter)
                end
                counter = counter + 1
            end

            eventTargetArray:Empty()
        end

        if processing

            if event:eventType = event:MOVED or event:eventType = event:STATIONARY
                if touchListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat touchListeners:GetSize() times
                        touchListeners:Get(counter):ContinuedTouch(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:BEGAN
                if touchListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat touchListeners:GetSize() times
                        touchListeners:Get(counter):BeganTouch(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:ENDED or event:eventType = event:CANCELLED
                if touchListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat touchListeners:GetSize() times
                        touchListeners:Get(counter):EndedTouch(event)
                        counter = counter + 1
                    end
                end

            end

        end

        if event:GetSource() not= undefined and event:eventType = event:BEGAN
            event:GetSource():Focus()
        end

        return result
    end

    /*
    This action will notify gesture listeners that are a part of this layer of the
    given gesture event. This is called automatically by the Game engine as 
    needed. Most users will never need to use this action directly.

    Attribute: Parameter event The GestureEvent to send to the GestureListeners.
    */
    action ProcessGestureEvent(GestureEvent event) returns Item
        if event:GetX() < GetViewportX() or (event:GetX() > GetViewportX() + GetViewportWidth())
            or event:GetY() < GetViewportY() or (event:GetY() > GetViewportY() + GetViewportHeight())
            
            return undefined
        end

        Ray ray = camera:GetPickRay(camera:GetWidth() - event:GetX(), event:GetY())
        Vector3 origin = ray:GetOrigin()

        integer counter = 0
        Item3D temp = undefined
        Item result = undefined

        /*
        TO-DO: This array of all items is regenerated for each mouse event
        processed. It would be more efficient to maintain this array
        independently of this action.
        */
        Array<Item3D> allItems
        repeat items:GetSize() times
            GetChildrenHierarchy(items:Get(counter), allItems)
            counter = counter + 1
        end
        counter = 0

        repeat allItems:GetSize() times
            temp = allItems:Get(counter)
            if RayIntersectsItem(ray, temp)
                eventTargetArray:Add(temp)
            end

            counter = counter + 1
        end

        boolean processing = true

        if eventTargetArray:GetSize() not= 0
            depthSorter:SetOrigin(origin)
            eventTargetArray:Sort(depthSorter)
            counter = 0
            repeat while processing and counter < eventTargetArray:GetSize()
                event:SetSource(eventTargetArray:Get(counter))
                eventTargetArray:Get(counter):ProcessGestureEvent(event)
                processing = not event:WasEventHandled()
                if event:WasEventHandled()
                    result = eventTargetArray:Get(counter)
                end
                counter = counter + 1
            end

            eventTargetArray:Empty()
        end

        if processing and gestureListeners:IsEmpty() = false
            counter = 0
            event:SetEventHandled(true)

            if event:eventType = event:SINGLE_TAP
                repeat gestureListeners:GetSize() times
                    gestureListeners:Get(counter):OnSingleTap(event)
                    counter = counter + 1
                end
            elseif event:eventType = event:DOUBLE_TAP
                repeat gestureListeners:GetSize() times
                    gestureListeners:Get(counter):OnDoubleTap(event)
                    counter = counter + 1
                end
            elseif event:eventType = event:SWIPE
                repeat gestureListeners:GetSize() times
                    gestureListeners:Get(counter):OnSwipe(event)
                    counter = counter + 1
                end
            elseif event:eventType = event:PAN
                repeat gestureListeners:GetSize() times
                    gestureListeners:Get(counter):OnPan(event)
                    counter = counter + 1
                end
            elseif event:eventType = event:LONG_PRESS
                if event:timingCode = event:BEGIN
                    repeat gestureListeners:GetSize() times
                        gestureListeners:Get(counter):OnLongPressBegin(event)
                        counter = counter + 1
                    end
                elseif event:timingCode = event:FINISH
                    repeat gestureListeners:GetSize() times
                        gestureListeners:Get(counter):OnLongPressEnd(event)
                        counter = counter + 1
                    end
                end
            elseif event:eventType = event:PINCH
                if event:timingCode = event:BEGIN
                    repeat gestureListeners:GetSize() times
                        gestureListeners:Get(counter):OnPinchBegin(event)
                        counter = counter + 1
                    end
                elseif event:timingCode = event:CONTINUE
                    repeat gestureListeners:GetSize() times
                        gestureListeners:Get(counter):OnPinchContinue(event)
                        counter = counter + 1
                    end
                elseif event:timingCode = event:FINISH
                    repeat gestureListeners:GetSize() times
                        gestureListeners:Get(counter):OnPinchEnd(event)
                        counter = counter + 1
                    end
                end
            end
        end

        return result
    end

    /*
    This action recursively finds all children in the hierarchy of the given
    Item3D. The found items are appended to the provided array. The provided
    Item3D is also automatically added to the array.
    */
    private action GetChildrenHierarchy(Item3D item, Array<Item3D> array)
        array:Add(item)
        integer counter = 0
        repeat item:GetItemCount() times
            GetChildrenHierarchy(item:GetItem(counter), array)
            counter = counter + 1
        end
    end

    /*
    This action will test if the given ray intersects with an Item3D. This
    intersection is tested using the base, axis-aligned dimensions of the item.
    It will not properly reflect changes made due to scaling or rotation, and
    assumes the Item is a box-like shape.
    */
    private action RayIntersectsItem(Ray ray, Item3D item) returns boolean
        number divX = 1.0 / ray:GetDirection():GetX()
        number divY = 1.0 / ray:GetDirection():GetY()
        number divZ = 1.0 / ray:GetDirection():GetZ()

        number minX = ((item:GetGlobalX() - item:GetWidth() * 0.5) - ray:GetOrigin():GetX()) * divX
        number maxX = ((item:GetGlobalX() + item:GetWidth() * 0.5) - ray:GetOrigin():GetX()) * divX
        
        if minX > maxX
            number temp = minX
            minX = maxX
            maxX = temp
        end

        number minY = ((item:GetGlobalY() - item:GetHeight() * 0.5) - ray:GetOrigin():GetY()) * divY
        number maxY = ((item:GetGlobalY() + item:GetHeight() * 0.5) - ray:GetOrigin():GetY()) * divY

        if minY > maxY
            number temp = minY
            minY = maxY
            maxY = temp
        end

        number minZ = ((item:GetGlobalZ() - item:GetDepth() * 0.5) - ray:GetOrigin():GetZ()) * divZ
        number maxZ = ((item:GetGlobalZ() + item:GetDepth() * 0.5) - ray:GetOrigin():GetZ()) * divZ

        if minZ > maxZ
            number temp = minZ
            minZ = maxZ
            maxZ = temp
        end

        number min = minX
        if minY > min
            min = minY
        end
        if minZ > min
            min = minZ
        end

        number max = maxX
        if maxY < max
            max = maxY
        end
        if maxZ < max
            max = maxZ
        end

        return max >= 0 and max >= min
    end

    /*
    This action will add a MouseListener to the layer. When the layer receives a
    mouse event, it will first try to find the topmost item which can handle the
    event. If the event is not handled, then all MouseListeners in the layer 
    will receive the event.

    Attribute: Parameter listener The MouseListener to add to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Events.MouseListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseListener.
        MouseListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layer:AddMouseListener(myListener)
            AddLayer(layer)
        end

        action Update(number seconds)
        end

    end
    */
    action AddMouseListener(MouseListener listener)
        mouseListeners:Add(listener)
    end

    /*
    This action will add a MouseMovementListener to the layer. When the layer
    receives a mouse event, it will first try to find the topmost item which can
    handle the event. If the event is not handled, then all 
    MouseMovementListeners in the layer will receive the event.

    Attribute: Parameter listener The MouseMovementListener to add to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Events.MouseMovementListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseMovementListener.
        MouseMovementListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layer:AddMouseMovementListener(myListener)
            AddLayer(layer)
        end

        action Update(number seconds)
        end

    end
    */
    action AddMouseMovementListener(MouseMovementListener listener)
        mouseMovementListeners:Add(listener)
    end

    /*
    This action will add a MouseWheelListener to the layer. When the layer
    receives a mouse event, it will first try to find the topmost item which can
    handle the event. If the event is not handled, then all 
    MouseWheelListeners in the layer will receive the event.

    Attribute: Parameter listener The MouseWheelListener to add to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Events.MouseWheelListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseWheelListener.
        MouseWheelListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layer:AddMouseWheelListener(myListener)
            AddLayer(layer)
        end

        action Update(number seconds)
        end

    end
    */
    action AddMouseWheelListener(MouseWheelListener listener)
        mouseWheelListeners:Add(listener)
    end

    /*
    This action will add a TouchListener to the layer. When the layer
    receives a touch event, it will first try to find the topmost item which can
    handle the event. If the event is not handled, then all 
    TouchListeners in the layer will receive the event.

    Attribute: Parameter listener The TouchListener to add to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Events.TouchListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from TouchListener.
        TouchListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layer:AddTouchListener(myListener)
            AddLayer(layer)
        end

        action Update(number seconds)
        end

    end
    */
    action AddTouchListener(TouchListener listener)
        touchListeners:Add(listener)
    end
    
    /*
    This action will remove a MouseListener from the layer. The listener will no
    longer receive events from the layer. If the given MouseListener is not on
    the layer before calling this action, then this action will have no effect.

    Attribute: Parameter listener The MouseListener to remove from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Events.MouseListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseListener.
        MouseListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layer:AddMouseListener(myListener)
            AddLayer(layer)

            layer:RemoveMouseListener(listener)
        end

        action Update(number seconds)
        end

    end
    */
    action RemoveMouseListener(MouseListener listener)
        mouseListeners:Remove(listener)
    end

    /*
    This action will remove a MouseMovementListener from the layer. The listener
    will no longer receive events from the layer. If the given 
    MouseMovementListener is not on the layer before calling this action, then 
    this action will have no effect.

    Attribute: Parameter listener The MouseMovementListener to remove from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Events.MouseMovementListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseMovementListener.
        MouseMovementListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layer:AddMouseMovementListener(myListener)
            AddLayer(layer)

            layer:RemoveMouseMovementListener(listener)
        end

        action Update(number seconds)
        end

    end
    */
    action RemoveMouseMovementListener(MouseMovementListener listener)
        mouseMovementListeners:Remove(listener)
    end

    /*
    This action will remove a MouseWheelListener from the layer. The listener 
    will no longer receive events from the layer. If the given 
    MouseWheelListener is not on the layer before calling this action, then this
    action will have no effect.

    Attribute: Parameter listener The MouseWheelListener to remove from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Events.MouseWheelListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseWheelListener.
        MouseWheelListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layer:AddMouseWheelListener(myListener)
            AddLayer(layer)

            layer:RemoveMouseWheelListener(listener)
        end

        action Update(number seconds)
        end

    end
    */
    action RemoveMouseWheelListener(MouseWheelListener listener)
        mouseWheelListeners:Remove(listener)
    end

    /*
    This action will remove a TouchListener from the layer. The listener will no
    longer receive events from the layer. If the given TouchListener is not on
    the layer before calling this action, then this action will have no effect.

    Attribute: Parameter listener The TouchListener to remove from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Events.TouchListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from TouchListener.
        TouchListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layer:AddTouchListener(myListener)
            AddLayer(layer)

            layer:RemoveTouchListener(listener)
        end

        action Update(number seconds)
        end

    end
    */
    action RemoveTouchListener(TouchListener listener)
        touchListeners:Remove(listener)
    end

    /*
    This action will add a GestureListener to the layer. When the layer
    receives a gesture event, it will first try to find the topmost item which can
    handle the event. If the event is not handled, then all 
    GestureListeners in the layer will receive the event.

    Attribute: Parameter listener The GestureListener to add to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Events.GestureListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from GestureListener.
        GestureListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layer:AddGestureListener(myListener)
            AddLayer(layer)
        end

        action Update(number seconds)
        end

    end

    */
    action AddGestureListener(GestureListener listener)
        gestureListeners:Add(listener)
    end

    /*
    This action will remove a GestureListener from the layer. The listener will no
    longer receive events from the layer. If the given GestureListener is not on
    the layer before calling this action, then this action will have no effect.

    Attribute: Parameter listener The GestureListener to remove from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Interface.Events.GestureListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from GestureListener.
        GestureListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer3D layer
            layer:AddGestureListener(myListener)
            AddLayer(layer)

            layer:RemoveGestureListener(myListener)
        end

        action Update(number seconds)
        end

    end

    */
    action RemoveGestureListener(GestureListener listener)
        gestureListeners:Remove(listener)
    end

    /*
    This action will add the given light to the Layer3D. It will be used during
    lighting of all objects on the layer.

    Attribute: Parameter light The DirectionalLight to add to this Layer3D.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.DirectionalLight
    use Libraries.Game.Graphics.AmbientLight

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            DirectionalLight light
            light:SetColor(0.8, 0.8, 0.8, 1)
            light:SetDirection(-1, -0.5, 1)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end
    */
    action Add(DirectionalLight light)
        EnsureCorrectThread()

        environment:Add(light)
    end
    
    /*
    This action will add a PointLight to the Layer3D. The Layer3D will treat it
    as an Item3D (respecting its position and updating it each frame) as well as
    using it to light up the scene.

    Attribute: Parameter light The PointLight to be added to the Layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.PointLight
    use Libraries.Game.Graphics.AmbientLight

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            PointLight light
            light:SetColor(0.8, 0.8, 0.8, 1)
            light:SetPosition(6, 3, 0)
            light:SetIntensity(8)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end
    */
    action Add(PointLight light)
        Add(cast(Item3D, light))
    end

    /*
    This action will remove the given DirectionalLight from the Layer3D.

    Attribute: Parameter light The DirectionalLight to remove from this Layer3D.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.DirectionalLight
    use Libraries.Game.Graphics.AmbientLight

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            DirectionalLight light
            light:SetColor(0.8, 0.8, 0.8, 1)
            light:SetDirection(-1, -0.5, 1)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)

            layer:Remove(light)
        end

        action Update(number seconds)
        end
    end
    */
    action Remove(DirectionalLight light)
        EnsureCorrectThread()

        environment:Remove(light)
    end

    /*
    This action will remove the given PointLight from the Layer3D. It will no
    longer be part of the item hierarchy of this Layer, and will no longer
    provide lighting in the scene.

    Attribute: Parameter light The PointLight to be removed from the Layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.PointLight
    use Libraries.Game.Graphics.AmbientLight

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            PointLight light
            light:SetColor(0.8, 0.8, 0.8, 1)
            light:SetPosition(6, 3, 0)
            light:SetIntensity(8)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)

            layer:Remove(light)
        end

        action Update(number seconds)
        end
    end
    */
    action Remove(PointLight light)
        Remove(cast(Item3D, light))
    end

    /*
    This action will set the ambient lighting present in this Layer. If the
    layer already had ambient lighting, it will be overwritten.

    Attribute: Parameter light The AmbientLight to use on this Layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.DirectionalLight
    use Libraries.Game.Graphics.AmbientLight

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            DirectionalLight light
            light:SetColor(0.8, 0.8, 0.8, 1)
            light:SetDirection(-1, -0.5, 1)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end
    */
    action SetAmbientLight(AmbientLight light)
        EnsureCorrectThread()

        environment:Add(light)
    end

    /*
    This action will remove all ambient lighting from the Layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.DirectionalLight
    use Libraries.Game.Graphics.AmbientLight

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            DirectionalLight light
            light:SetColor(0.8, 0.8, 0.8, 1)
            light:SetDirection(-1, -0.5, 1)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)

            layer:RemoveAmbientLight()
        end

        action Update(number seconds)
        end
    end
    */
    action RemoveAmbientLight
        EnsureCorrectThread()

        environment:RemoveAmbientLight()
    end
    
    /*
    This action will return the AmbientLight being used on this Layer3D. If the 
    scene doesn't have any ambient lighting, then this action will return undefined.

    Attribute: Returns The AmbientLight used in the Layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.DirectionalLight
    use Libraries.Game.Graphics.AmbientLight

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            DirectionalLight light
            light:SetColor(0.8, 0.8, 0.8, 1)
            light:SetDirection(-1, -0.5, 1)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)

            AmbientLight returnedLight = layer:GetAmbientLight()
        end

        action Update(number seconds)
        end
    end
    */
    action GetAmbientLight returns AmbientLight
        return environment:GetAmbientLight()
    end

    // TO-DO: Fill out this comment
    /*

    */
    action GetEnvironment returns Environment
        return environment
    end

    /*
    This action will get an iterator containing all of the DirectionalLights
    stored inside this layer.

    Attribute: Returns An iterator containing each of the DirectionalLights added to this Layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.DirectionalLight
    use Libraries.Game.Graphics.AmbientLight
    use Libraries.Containers.Iterator

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            DirectionalLight light
            light:SetColor(0.8, 0.8, 0.8, 1)
            light:SetDirection(-1, -0.5, 1)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)

            Iterator<DirectionalLight> lights = layer:GetDirectionalLights()
        end

        action Update(number seconds)
        end
    end
    */
    action GetDirectionalLights returns Iterator<DirectionalLight>
        DirectionalLightsAttribute temp
        DirectionalLightsAttribute dlAttribute = (cast(DirectionalLightsAttribute, environment:GetAttribute(temp:GetDirectionalLightsValue())))
        if dlAttribute not= undefined
            return dlAttribute:lights:GetIterator()
        else
            return temp:lights:GetIterator()
        end
    end

    /*
    This action will get an iterator containing all of the PointLights
    stored inside this layer.

    Attribute: Returns An Iterator containing each of the PointLights that have been added to this Layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.PointLight
    use Libraries.Game.Graphics.AmbientLight
    use Libraries.Containers.Iterator

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            PointLight light
            light:SetColor(0.8, 0.8, 0.8, 1)
            light:SetPosition(6, 3, 0)
            light:SetIntensity(8)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)

            Iterator<PointLight> lights = layer:GetPointLights()
        end

        action Update(number seconds)
        end
    end
    */
    action GetPointLights returns Iterator<PointLight>
        PointLightsAttribute temp
        PointLightsAttribute plAttribute = (cast(PointLightsAttribute, environment:GetAttribute(temp:GetPointLightsValue())))
        if plAttribute not= undefined
            return plAttribute:lights:GetIterator()
        else
            return temp:lights:GetIterator()
        end
    end

    /*
    This action will return a directional light stored at the given index in the
    Layer's array of directional lights. Each type of light stored in the Layer
    is kept in a separate array from other types. If there are no directional
    lights added to this layer, or if the index is out of bounds, this action
    will produce an error.

    Attribute: Parameter index The index to retrieve from the DirectionalLight array in the Layer.

    Attribute: Returns The DirectionalLight stored at the given index in this Layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.DirectionalLight
    use Libraries.Game.Graphics.AmbientLight

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            DirectionalLight light1
            light1:SetColor(0.8, 0.8, 0.8, 1)
            light1:SetDirection(1, 0, 1.1)

            DirectionalLight light2
            light2:SetColor(0.8, 0.8, 0.8, 1)
            light2:SetDirection(0, -1, 0)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light1)
            layer:Add(light2)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)

            // This will retrieve light1, because it was added to the Layer first.
            DirectionalLight returnedLight = layer:GetDirectionalLight(0)
        end

        action Update(number seconds)
        end
    end
    */
    action GetDirectionalLight(integer index) returns DirectionalLight
        DirectionalLightsAttribute dlAttribute
        dlAttribute = (cast(DirectionalLightsAttribute, environment:GetAttribute(dlAttribute:GetDirectionalLightsValue())))
        if dlAttribute = undefined
            alert("You asked me to retrieve a directional light, but there are none added to this Layer!")
        end

        return dlAttribute:lights:Get(index)
    end

    /*
    This action will return a point light stored at the given index in the
    Layer's array of point lights. Each type of light stored in the Layer
    is kept in a separate array from other types. If there are no directional
    lights added to this layer, or if the index is out of bounds, this action
    will produce an error.

    Attribute: Parameter index The index to retrieve from the PointLight array in the Layer.

    Attribute: Returns The PointLight stored at the given index in this Layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Model
    use Libraries.Game.Graphics.Color
    use Libraries.Game.Graphics.PointLight
    use Libraries.Game.Graphics.AmbientLight

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Color color
            Model box
            box:LoadBox(2, 2, 2, color:Green())
            box:SetPosition(4, 0, 2)

            PointLight light1
            light1:SetColor(0.8, 0.8, 0.8, 1)
            light1:SetPosition(6, 3, 0)
            light1:SetIntensity(8)

            PointLight light2
            light2:SetColor(0.8, 0.8, 0.8, 1)
            light2:SetPosition(2, 3, 0)
            light2:SetIntensity(8)

            AmbientLight ambient
            ambient:SetColor(0.4, 0.4, 0.4, 1)

            Layer3D layer
            layer:Add(box)
            layer:Add(light1)
            layer:Add(light2)
            layer:SetAmbientLight(ambient)
            AddLayer(layer)

            // This will retrieve light1, because it was added to the Layer first.
            PointLight returnedLight = layer:GetPointLight(0)
        end

        action Update(number seconds)
        end
    end
    */
    action GetPointLight(integer index) returns PointLight
        PointLightsAttribute plAttribute
        plAttribute = (cast(PointLightsAttribute, environment:GetAttribute(plAttribute:GetPointLightsValue())))
        if plAttribute = undefined
            alert("You asked me to retrieve a point light, but there are none added to this Layer!")
        end

        return plAttribute:lights:Get(index)
    end

    /*
    AddCollisionListener will add a collision listener to this layer. The
    collision listener will be notified of collisions occuring on this layer, 
    and is responsible for managing the collision events.
    */
    action AddCollisionListener(CollisionListener3D listener)
        collisionManager:AddCollisionListener(listener)
    end

    /*
    RemoveCollisionListener removes a collision listener to this layer. The
    collision listener will no longer be notified of collision events occurring
    on this layer. If the given listener is not a part of this layer, then this
    action will have no effect.
    */
    action RemoveCollisionListener(CollisionListener3D listener)
        collisionManager:RemoveCollisionListener(listener)
    end
    /*
    This action gets the list of items on this layer that are colliding and
    returns it as an array.
    */
    action GetCollisionList returns CollisionEvent3D
        return collisionManager:GetCollisionList()
    end

    /*
    This action gets the collision manager for this object which is responsible
    for managing the collisions between all colliding items on this layer.
    */
    action GetCollisionManager returns CollisionManager3D
        return collisionManager
    end

    /*
    This action triggers collision detection for this layer during a frame in
    the Game engine. This action will automatically be called by the Game class
    as necessary. Most users should never need to use this action directly.
    */
    action TestForCollisions(number seconds)
        if not collide
            return now
        end
        if newItemAdded
            collisionManager:FindNewCollisions()
            newItemAdded = false
        end

        collisionManager:Collide()

        if physicsEnabled
            StepPhysics(seconds)
            SetScreenPositionsFromPhysicsPositions()
        end

        integer i = 0
        repeat while i < items:GetSize()
            Item3D item = items:Get(i)
            item:SynchronizeNodes()

            i = i + 1
        end

        collisionManager:FindNewCollisions()
    end

    /*
    This action indicates that the layer has received a new item that it must
    manage during collision detection. This is automatically called by the Game
    engine as necessary, and most users should never need to use this action
    directly.
    */
    action SetNewItemAdded(boolean flag)
        newItemAdded = flag
    end

    /*
    This action sets the Skybox that should be used by this Layer3D. The given
    Skybox will be rendered behind all other items in the layer. If the given
    parameter is undefined, the Layer will not render a skybox. By default, the
    skybox is undefined.

    Attribute: Parameter box The Skybox to render on this layer, or undefined to not use a Skybox.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Skybox

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            // Assuming we have 6 image files, "Sky-Right.png", "Sky-Left.png", etc.
            Skybox skybox
            skybox:Load("Sky-Right.png", "Sky-Left.png", "Sky-Up.png", "Sky-Down.png", "Sky-Forward.png", "Sky-Back.png")

            Layer3D layer = GetCurrentLayer3D()
            layer:SetSkybox(skybox)
        end
    end
    */
    action SetSkybox(Skybox box)
        skybox = box
        painter:SetSkybox(box)
    end

    /*
    This action sets the Skybox that should be used by this Layer3D. The given
    Skybox will be rendered behind all other items in the layer. If the given
    parameter is undefined, the Layer will not render a skybox. By default, the
    skybox is undefined.

    Attribute: Parameter box The Skybox to render on this layer, or undefined to not use a Skybox.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer3D
    use Libraries.Game.Graphics.Skybox

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            // Assuming we have 6 image files, "Sky-Right.png", "Sky-Left.png", etc.
            Skybox skybox
            skybox:Load("Sky-Right.png", "Sky-Left.png", "Sky-Up.png", "Sky-Down.png", "Sky-Forward.png", "Sky-Back.png")

            Layer3D layer = GetCurrentLayer3D()
            layer:SetSkybox(skybox)

            Skybox layerBox = layer:GetSkybox()
        end
    end
    */
    action GetSkybox returns Skybox
        return skybox
    end

    action EnablePhysics(boolean flag)
        physicsEnabled = flag
    end

    action PhysicsEnabled returns boolean
        return physicsEnabled
    end

    action SetGravity(number x, number y, number z)
        gravity:Set(x, y, z)
    end

    action SetGravity(Vector3 gravity)
        me:gravity:Set(gravity)
    end

    action GetGravity returns Vector3
        return gravity
    end

    action SetAutomaticallyClearForces(boolean flag)
        automaticallyClearForces = flag
    end

    action AutomaticallyClearForces returns boolean
        return automaticallyClearForces
    end

    action SetWarmStarting(boolean flag)
        warmStarting = flag
    end

    action IsWarmStarting returns boolean
        return warmStarting
    end

    action SetContinuousPhysics(boolean flag)
        continuousPhysics = flag
    end

    action IsContinuousPhysics returns boolean
        return continuousPhysics
    end

    action RequireSimulation(boolean flag)
        if requireSimulation = flag
            return now
        end

        requireSimulation = flag
        if requireSimulation
            integer i = 0
            repeat items:GetSize() times
                Item3D item = items:Get(i)
                item:Simulate(true)
                i = i + 1
            end
        end
    end

    action IsSimulationRequired returns boolean
        return requireSimulation
    end

    action SetSubStepping(boolean flag)
        subStepping = flag
    end

    action IsSubStepping returns boolean
        return subStepping
    end

    action ClearForces
        integer i = 0
        repeat items:GetSize() times
            Item3D body = items:Get(i)
            if body:IsPhysicsEnabled()
                body:GetForce():SetZero()
                body:GetTorque():SetZero()
            end
            i = i + 1
        end
    end

    action StepPhysics(number seconds)
        integer numSimulationSubsteps = 0
        integer maxSubSteps = me:maxSubSteps
        number fixedTimeStep = physicsTimeStep

        if maxSubSteps not= 0
            localTime = localTime + seconds
            if localTime >= fixedTimeStep
                numSimulationSubsteps = cast(integer, localTime / fixedTimeStep)
                localTime = localTime - (numSimulationSubsteps * fixedTimeStep)
            end
        else
            fixedTimeStep = seconds
            localTime = seconds
            if math:AbsoluteValue(seconds) < 0.00000011920928955078125
                numSimulationSubsteps = 0
                maxSubSteps = 0
            else
                numSimulationSubsteps = 1
                maxSubSteps = 1
            end
        end

        if numSimulationSubsteps not= 0
            integer clampedSimulationSteps = numSimulationSubsteps
            if numSimulationSubsteps > maxSubSteps
                clampedSimulationSteps = maxSubSteps
            end

            integer i = 0
            repeat while i < clampedSimulationSteps
                SolvePhysics(fixedTimeStep)
                SynchronizeTransforms()
                i = i + 1
            end
        end

        if automaticallyClearForces
            ClearForces()
        end
    end

    private action PredictUnconstrainedMotion(number seconds)
        PhysicsPosition3D temp

        integer i = 0
        repeat items:GetSize() times
            Item3D item = items:Get(i)
            if item:IsPhysicsEnabled()
                if item:IsResponsive() and item:IsSimulated()
                    temp:Set(item:GetInterpolationWorldTransform())
                    item:IntegrateVelocities(seconds)
                    item:ApplyDamping(seconds)
                    item:PredictIntegratedTransform(seconds, temp)
                end
            end
            i = i + 1
        end
    end

    CollisionGroup3D island
    Stack<Item3D> stack
    CollisionSolverInformation3D solverInfo

    action SolvePhysics(number seconds)
        solverInfo:SetTimeStep(seconds)
        island:SetSolverInformation(solverInfo)

        integer i = 0
        repeat items:GetSize() times
            Item3D body = items:Get(i)
            if body:IsPhysicsEnabled()
                body:SetCollisionGroupFlag(false)
            end
            body:GetCollisionTransform():Set(body:GetCollisionTransform())
            i = i + 1
        end

        CollisionEvent3D collision = collisionManager:GetCollisionList()
        repeat until collision = undefined
            collision:SetInCollisionGroup(false)
            collision = collision:GetNext()
        end

        i = 0
        repeat joints:GetSize() times
            Joint3D joint = joints:Get(i)
            joint:SetInCollisionGroup(false)
            i = i + 1
        end

        i = 0
        repeat items:GetSize() times
            
            Item3D seed = items:Get(i)
            if not seed:IsPhysicsEnabled()
                // continue with loop -- this item does not need physics solved
            elseif seed:GetCollisionGroupFlag()
                // continue with loop -- this item has already had physics solved
            elseif not seed:IsSimulated()
                // continue with loop -- this item is not currently being simulated
            elseif seed:IsUnmovable()
                // continue with loop -- this item is unmovable and cannot start off a collision group
            else
                island:Empty()
                stack:Empty()
                stack:Push(seed)
                seed:SetCollisionGroupFlag(true)

                repeat while not stack:IsEmpty()
                    Item3D body = stack:Pop()
                    island:Add(body)

                    body:Simulate(true)

                    if body:IsUnmovable()
                        // continue -- don't look for colliding items with unmovable items
                        // to add to a collision group -- this keeps collision groups small
                        // and faster to solve -- the items colliding with an unmovable
                        // item will be a part of a separate collision group
                    else
                        CollisionEdge3D edge = body:GetCollisionList()
                        repeat while edge not= undefined
                            CollisionEvent3D collision1 = edge:GetCollision()
                            if collision1:InCollisionGroup()
                                // continue with group -- the collision has already been
                                // accounted for in the collision group
                            elseif not collision1:IsEnabled() or not collision1:IsTouching() or not collision1:HasPhysicsResponse()
                                // continue with group -- this collision is not currently
                                // colliding (close, may collide in a few frames) or this
                                // collision has been disalbed from producing a physics
                                // response
                            else
                                boolean physicsA = collision1:GetItemA():IsPhysicsEnabled()
                                boolean physicsB = collision1:GetItemB():IsPhysicsEnabled()
                                boolean sensor = not physicsA or not physicsB

                                if sensor
                                    // continue with group -- one or both items
                                    // does not have physics enabled
                                else
                                    island:Add(collision1)
                                    collision1:SetInCollisionGroup(true)

                                    Item3D other = edge:GetOther()
                                    if other:GetCollisionGroupFlag()
                                        // continue with group -- the other item
                                        // is already in this group
                                    else
                                        stack:Push(other)
                                        other:SetCollisionGroupFlag(true)
                                    end
                                end
                            end
                            edge = edge:GetNext()
                        end

                        JointEdge3D jointEdge = body:GetJointList()  //gets the joints that are associated with the current body, starting with the first joint
                        //output "currently finding the collision and joints for item " + body:GetDescription()
                        repeat while jointEdge not= undefined
                            Joint3D joint = jointEdge:GetJoint()  
                            if joint:InCollisionGroup()
                                //output "found a joint that has already been set"
                                // continue with group -- the joint has already been
                                // accounted for in the collision group
                            else
                                Item3D other = jointEdge:GetOther()

                                island:Add(joint)
                                //output "Added a joint to CollisionGroup3D"
                                joint:SetInCollisionGroup(true)

                                if other:GetCollisionGroupFlag()
                                    // continue with group -- the other item is
                                    // already in the group
                                else
                                    stack:Push(other)
                                    other:SetCollisionGroupFlag(true)
                                end
                            end

                            jointEdge = jointEdge:GetNext()
                        end

                        integer k = 0
                        repeat body:GetItemCount() times
                            Item3D child = body:GetItem(k)
                            if child:GetCollisionGroupFlag()
                                // continue with group -- the child item is
                                // already in the group
                            else
                                stack:Push(child)
                                child:SetCollisionGroupFlag(true)
                            end
                            k = k + 1
                        end
                    end
                end

                island:Solve(seconds, gravity, requireSimulation)

                integer j = 0
                repeat island:GetItemCount() times
                    Item3D body = island:GetItem(j)
                    if body:IsUnmovable()
                        body:SetCollisionGroupFlag(false)
                    end
                    j = j + 1
                end
            end
            i = i + 1
        end

        IntegrateTransforms(seconds)

        i = 0
        repeat items:GetSize() times
            Item3D body = items:Get(i)
            if not body:IsPhysicsEnabled() 
                // do nothing -- physics is not enabled for this item
            elseif (not body:GetCollisionGroupFlag()) and body:GetResponsiveness() not= body:GetPhysicsProperties():UNMOVABLE
                // do nothing -- this item was never a part of a physics group
            elseif body:GetResponsiveness() = body:GetPhysicsProperties():UNMOVABLE and not body:HasMoved()
                // do nothing -- this item is unmovable so synchronizing its nodes
                // is not necessary
            else
                body:SynchronizeNodes()
                body:SetHasMoved(false)
            end
            i = i + 1
        end

        collisionManager:FindNewCollisions()
    end

    action SynchronizeTransforms
        PhysicsPosition3D predictedTransform

        integer i = 0
        repeat items:GetSize() times
            Item3D body = items:Get(i)
            if body:IsPhysicsEnabled() and body:IsResponsive()
                PhysicsPosition3D curTrans
                curTrans:Set(body:GetInterpolationWorldTransform())
                Vector3 linvel
                linvel:Set(body:GetInterpolatedLinearVelocity())
                Vector3 angvel
                angvel:Set(body:GetInterpolatedAngularVelocity())
                number timestep = localTime * body:GetTimeOfImpact()
                
                predictedTransform:GetOrigin():Set(linvel):Scale(timestep):Add(curTrans:GetOrigin())
                Vector3 axis
                number fangle = angvel:Length()

                if fangle * timestep > 0.5 * math:pi / 2
                    fangle = (0.5 * math:pi / 2) / timestep
                end

                if fangle < 0.001
                    axis:Set(angvel):Scale(0.5 * timestep - (timestep * timestep * timestep) * (0.020833333333) * fangle * fangle)
                else
                    axis:Set(angvel):Scale(math:Sine(0.5 * fangle * timestep) / fangle)
                end
                Quaternion dorn
                dorn:Set(axis:GetX(), axis:GetY(), axis:GetZ(), math:Cosine(fangle * timestep * 0.5))
                Quaternion orn0
                orn0:Set(curTrans:GetRotation())

                Quaternion predictedOrn
                predictedOrn:Set(dorn):Multiply(orn0)
                predictedOrn:Normalize()
                predictedTransform:SetRotation(predictedOrn)

                body:GetCollisionTransform():Set(predictedTransform)
            end

             i = i + 1
        end
    end

    action ApplyGravity
        integer i = 0
        repeat while i < items:GetSize()
            Item3D item = items:Get(i)
            if item:IsPhysicsEnabled()
                if item:IsSimulated()
                    if item:IsResponsive()
                        Vector3 force
                        force:Set(gravity):Scale(1.0 / item:GetInverseMass())
                        item:ApplyForceToCenter(force)
                    end
                end
            end
            i = i + 1
        end
    end

    action SaveKinematicState(number timeStep)
        integer i = 0
        repeat while i < items:GetSize()
            Item3D item = items:Get(i)
            if item:IsPhysicsEnabled()
                if item:IsSimulated()
                    if item:IsResponsive()
                        item:SaveKinematicState(timeStep)
                    end
                end
            end

            i = i + 1
        end
    end

    action IntegrateTransforms(number timeStep)
        Vector3 temp
        PhysicsPosition3D tempTrans

        PhysicsPosition3D predictedTransform

        integer i = 0
        repeat while i < items:GetSize()
            Item3D item = items:Get(i)
            if item:IsPhysicsEnabled()
                item:SetTimeOfImpact(1)

                if item:IsSimulated() and item:IsResponsive()
                    item:PredictIntegratedTransform(timeStep, predictedTransform)
                    temp:Set(predictedTransform:GetOrigin())
                    tempTrans:Set(item:GetCollisionTransform())
                    temp:Subtract(tempTrans:GetOrigin())
                    number squareMotion = temp:LengthSquared()

                    //Continuous Collision Detection stuff for later...

                    item:ProceedToTransform(predictedTransform)
                end
            end

            i = i + 1
        end
    end

    action SetScreenPositionsFromPhysicsPositions
        integer i = 0
        repeat while i < items:GetSize()
            Item3D item = items:Get(i)
            if item:IsPhysicsEnabled()
                item:SetScreenPositionFromPhysicsPosition()
            end

            i = i + 1
        end
    end

    action AddJoint(Joint3D joint)
        joints:Add(joint)

        joint:GetEdgeA():SetJoint(joint)    //add this joint to the beginning of the linked list for itemA
        joint:GetEdgeA():SetOther(joint:GetItemB())
        joint:GetEdgeA():SetPrevious(undefined)
        joint:GetEdgeA():SetNext(joint:GetItemA():GetJointList())
        if joint:GetItemA():GetJointList() not= undefined
            joint:GetItemA():GetJointList():SetPrevious(joint:GetEdgeA())
        end
        joint:GetItemA():SetJointList(joint:GetEdgeA())

        joint:GetEdgeB():SetJoint(joint)
        joint:GetEdgeB():SetOther(joint:GetItemA())
        joint:GetEdgeB():SetPrevious(undefined)
        joint:GetEdgeB():SetNext(joint:GetItemB():GetJointList())
        if joint:GetItemB():GetJointList() not= undefined
            joint:GetItemB():GetJointList():SetPrevious(joint:GetEdgeB())
        end
        joint:GetItemB():SetJointList(joint:GetEdgeB())

        //TODO: Collision filtering?
    end

    action RemoveJoint(Joint3D joint)
        joints:Remove(joint)

        Item3D itemA = joint:GetItemA()
        Item3D itemB = joint:GetItemB()

        itemA:Simulate(true)
        itemB:Simulate(true)

        if joint:GetEdgeA():GetPrevious() not= undefined
            joint:GetEdgeA():GetPrevious():SetNext(joint:GetEdgeA():GetNext())
        end

        if joint:GetEdgeA():GetNext() not= undefined
            joint:GetEdgeA():GetNext():SetPrevious(joint:GetEdgeA():GetPrevious())
        end

        if joint:GetEdgeA() = itemA:GetJointList()
            itemA:SetJointList(joint:GetEdgeA():GetNext())
        end

        joint:GetEdgeA():SetPrevious(undefined)
        joint:GetEdgeA():SetNext(undefined)

        if joint:GetEdgeB():GetPrevious() not= undefined
            joint:GetEdgeB():GetPrevious():SetNext(joint:GetEdgeB():GetNext())
        end

        if joint:GetEdgeB():GetNext() not= undefined
            joint:GetEdgeB():GetNext():SetPrevious(joint:GetEdgeB():GetPrevious())
        end

        if joint:GetEdgeB() = itemB:GetJointList()
            itemB:SetJointList(joint:GetEdgeB():GetNext())
        end

        joint:GetEdgeB():SetPrevious(undefined)
        joint:GetEdgeB():SetNext(undefined)

        //TODO: collision filtering?
    end

    action Resize(ResizeEvent event)
        integer width = event:GetWidth()
        integer height = event:GetHeight()

        if GetViewportX() = 0 and GetViewportY() = 0 and GetViewportWidth() = camera:GetWidth() and GetViewportHeight() = camera:GetHeight()
            SetViewport(0, 0, width, height)
        end

        camera:SetWidth(width)
        camera:SetHeight(height)

        camera:Update()

        // Resize items, if reasonable to do so, here.
    end

    /*
    This actions sets the viewport that will be used by this Layer, and adjusts
    the Layer's camera to match the dimensions of the viewport.
    */
    action SetViewportAndCamera(integer x, integer y, integer width, integer height)
        SetViewport(x, y, width, height)
        Camera camera = GetCamera()
        camera:SetSize(width, height)
    end
end
