package Libraries.Game.Graphics

use Libraries.Containers.Number32BitArray
use Libraries.Containers.Array
use Libraries.Game.Graphics.Color
use Libraries.Game.Graphics.TextureRegion
use Libraries.Game.Graphics.VertexAttribute
use Libraries.Game.Graphics.VertexAttributes
use Libraries.Game.Graphics.ModelData.MeshPart
use Libraries.Compute.Math
use Libraries.Compute.Matrix4
use Libraries.Compute.Matrix3
use Libraries.Compute.Vector3
use Libraries.Compute.Vector2
use Libraries.Compute.BitwiseOperations
use Libraries.Game.BoundingBox
use Libraries.Game.NumberUtilities
use Libraries.Containers.Integer32BitArray

class MeshBuilder 

    /*
    The POINTS value is one of the possible primitive type values. It is used to
    indicate that each vertex of the Mesh should be considered an individual
    point, separate from the other vertices.
    */
    public constant integer POINTS = 0

    /*
    The LINES value is one of the possible primitive type values. The Mesh will
    form lines using pairs of vertices.
    */
    public constant integer LINES = 1

    /*
    The TRIANGLES value is one of the possible primitive type values. The Mesh
    will form triangles from triplets of vertices.
    */
    public constant integer TRIANGLES = 4
    
    // An array used to temporarily store indices during operations.
    private Array<integer> tempIndices

    // An array used to temporarily store vertices during operations.
    private Array<number> tempVertices


    // A collection of temporary VertexSchematic objects used during operations.
    private VertexSchematic vertTemp1
    private VertexSchematic vertTemp2
    private VertexSchematic vertTemp3
    private VertexSchematic vertTemp4
    private VertexSchematic vertTemp5
    private VertexSchematic vertTemp6
    private VertexSchematic vertTemp7
    private VertexSchematic vertTemp8

    // A collection of Vector3 objects used during calculations.
    private Vector3 tempVector1
    private Vector3 tempVector2
    private Vector3 tempVector3
    private Vector3 tempVector4
    private Vector3 tempVector5
    private Vector3 tempVector6
    private Vector3 tempVector7
    private Vector3 tempVector8

    // A temporary Color object used during operations.
    private Color tempColor

    // The VertexAttributes of the mesh being constructed.
    private VertexAttributes attributes = undefined

    // The vertices of the mesh being constructed.
    private Array<number> vertices

    // The indices of the mesh being constructed.
    private Array<integer> indices

    // How many number components make up each vertex.
    private integer vertexSize = 0

    // The current vertex index, used for indexing.
    private integer vertexIndex = 0

    // The offset in the indices array when Begin() was called. Used to define a MeshPart.
    private integer indicesStart = 0

    // The count of number components in a vertex before the positional component.
    private integer positionOffset = 0

    // How many number components make up the position attribute.
    private integer positionSize = 0

    //The count of number components in a vertex before the normal component. If there is no normal, this will be -1.
    private integer normalOffset = -1

    // The count of number components in a vertex before the binormal component. If there is no binormal, this will be -1.
    private integer binormalOffset = -1

    // The count of number components in a vertex before the tangent component. If there is no tangent, this will be -1.
    private integer tangentOffset = -1

    // The count of number components in a vertex before the color component. If there is no color, this will be -1.
    private integer colorOffset = -1

    // How many number components make up the color attribute.
    private integer colorSize = 0

    // The count of number components in a vertex before the packed color component, or -1 if there is none.
    private integer colorPackedOffset = -1

    // The count of number components in a vertex before the texture coordinates, or -1 if there are none.
    private integer textureCoordinatesOffset = -1

    // The MeshPart currently under construction.
    private MeshPart part = undefined

    // The MeshParts created between calls to Begin() and End().
    private Array<MeshPart> parts

    // The color used if no vertex color is specified.
    private Color color

    // Whether or not a color has been specified for the vertices.
    private boolean hasColor = false

    // The current primitiveType being used to describe the mesh.
    private integer primitiveType = TRIANGLES

    // The last index which was used during Mesh construction.
    private integer lastIndex = -1

    // The UV range used for texture coordinates during construction.
    private number uOffset = 0
    private number uScale = 1
    private number vOffset = 0
    private number vScale = 1
    private boolean hasUVTransform = false
    private Array<number> vertex = undefined

    private boolean vertexTransformationEnabled = false
    private Matrix4 positionTransform
    private Matrix3 normalTransform
    private BoundingBox bounds

    private Math math
    private BitwiseOperations bits
    private NumberUtilities numberUtilities
    private Vector3 calcVector1
    private Vector3 calcVector2

    /*

        /** Begin building a mesh. Call {@link #part(String, int)} to start a {@link MeshPart}.
* @param attributes bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal
*           and TextureCoordinates is supported. *-
public void begin (final long attributes) {
begin(createAttributes(attributes), -1);
}

        /** Begin building a mesh.
* @param attributes bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal
*           and TextureCoordinates is supported. *-
public void begin (final long attributes, int primitiveType) {
begin(createAttributes(attributes), primitiveType);
}
    */

    /*
    This action informs the MeshBuilder to begin constructing a new mesh. If a
    mesh is already in construction, this will throw an error.
    */
    action Begin(VertexAttributes vAttributes)
        Begin(vAttributes, -1)
    end

    /*
    This action informs the MeshBuilder to begin constructing a new mesh. If a
    mesh is already in construction, this will throw an error. The
    VertexAttributes must contain at least a Position attribute, and can also
    contain Normal, Binormal, Tangent, ColorUnpacked, ColorPacked, or
    TextureCoordinates attributes. The type should be one of the primitive type
    constants in the MeshBuilder: POINTS, LINES, or TRIANGLES.
    */
    action Begin(VertexAttributes vAttributes, integer type)
        if attributes not= undefined
            alert("I can't begin building a new Mesh because there is already one under construction!")
        end

        attributes = vAttributes
        vertices:Empty()
        indices:Empty()
        parts:Empty()
        vertexIndex = 0
        lastIndex = -1
        indexStart = 0
        part = undefined
        vertexSize = attributes:vertexSize / 4

        if vertex = undefined or vertex:GetSize() < vertexSize
            Array<number> newVertexArray
            newVertexArray:SetSize(vertexSize)
            vertex = newVertexArray
        end

        VertexAttribute attribute = attributes:FindByUsage(attributes:POSITION)
        if attribute = undefined
            alert("I was told to construct a mesh without a Position attribute, but that attribute is required.")
        end
        positionOffset = attribute:offset / 4
        positionSize = attribute:componentCount

        attribute = attributes:FindByUsage(attributes:NORMAL)
        if attribute = undefined
            normalOffset = -1
        else
            normalOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:BINORMAL)
        if attribute = undefined
            binormalOffset = -1
        else
            binormalOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:TANGENT)
        if attribute = undefined
            tangentOffset = -1
        else
            tangentOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:COLOR_UNPACKED)
        if attribute = undefined
            colorOffset = -1
        else
            colorOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:COLOR_PACKED)
        if attribute = undefined
            colorPackedOffset = -1
        else
            colorPackedOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:TEXTURE_COORDINATES)
        if attribute = undefined
            textureCoordinatesOffset = -1
        else
            textureCoordinatesOffset = attribute:offset / 4
        end
        
        //SetColor(undefined)
        //SetUVRange(undefined)
        primitiveType = type
        bounds:Invalidate()
    end

    private action EndPart
        if part not= undefined
            /* The following lines of code set fields in the MeshPart that exist
            in libGDX, but that we do not currently use or have.

            part:center = bounds:GetCenter()
            part:halfExtents = bounds:GetDimensions():Scale(0.5)
            part:radius = part:halfExtents:Length()
            */
            bounds:Invalidate()
            part:indexOffset = indicesStart
            part:verticesCount = indices:GetSize() - indicesStart
            indicesStart = indices:GetSize()
            part = undefined
        end
    end

    /*
    This action will start constructing a new MeshPart for the Mesh. The new
    MeshPart will still not be usable until End() is called. This will reset
    any current color and vertex transformations.
    */
    action NewPart(text id, integer type) returns MeshPart
        if attributes = undefined
            alert("I can't begin constructing a new MeshPart if I'm not currently building a Mesh. Call Begin() before using NewPart().")
        end
        EndPart()

        MeshPart newPart
        part = newPart
        part:id = id
        primitiveType = type
        part:primitiveType = type
        parts:Add(part)

        SetColor(undefined)
        SetVertexTransform(undefined)
        SetUVRange(undefined)
        
        return part
    end
    
    /*
    This action will finish construction of the current Mesh, and then return it.
    */
    action End returns Mesh
        if attributes = undefined
            alert("I must begin constructing a Mesh before I can finish it - call Begin() first.")
        end

        Mesh newMesh
        newMesh:Load(true, vertices:GetSize() / vertexSize, indices:GetSize(), attributes)

        EndPart()
        
        Number32BitArray newVertices
        newVertices:SetSize(vertices:GetSize())
        integer i = 0
        repeat while i < vertices:GetSize()
            newVertices:Set(i, vertices:Get(i))
            i = i + 1
        end

        newMesh:SetVertices(newVertices)


        Integer32BitArray newIndices
        newIndices:SetSize(indices:GetSize())
        i = 0

        repeat while i < indices:GetSize()
            newIndices:Set(i, indices:Get(i))
            i = i + 1
        end
        newMesh:SetIndices(newIndices)

        integer counter = 0
        MeshPart meshPart = undefined
        repeat parts:GetSize() times
            meshPart = parts:Get(counter)
            meshPart:mesh = newMesh
            counter = counter + 1
        end
        parts:Empty()

        attributes = undefined
        vertices:Empty()
        indices:Empty()

        return newMesh
    end

    /*
    Empties the data being built up until now, including the vertices, indices,
    and all parts. Must be called between Begin() and End() to have any effect.
    This effectively discards all work done since the initial Begin(), but will
    not reset state such as UV region, color, or vertex transform.
    */
    action Empty
        vertices:Empty()
        indices:Empty()
        parts:Empty()
        vertexIndex = 0
        lastIndex = -1
        indicesStart = 0
        part = undefined
    end

    /*
    This action will return the amount of number components that makes up each
    vertex.
    */
    action GetVertexSize returns integer
        return vertexSize
    end

    /*
    This action returns the number of vertices that have been built so far for
    the current Mesh under construction. This will only return a valid result
    if used between calls to Begin() and End().
    */
    action GetVerticesCount returns number
        return vertices:GetSize() / vertexSize
    end

    /*
    This action will return a copy of all of the vertices built so far. This
    action must be called between Begin() and End() - otherwise, an error will
    be thrown.
    */
    action GetVertices returns Array<number>
        return vertices
    end

    /*
    This action will return the number of indices that has been built so far in
    the Mesh currently under construction. This is only valid between calls to
    Begin() and End().
    */
    action GetIndicesCount returns integer
        return indices:GetSize()
    end

    /*
    This action will return a copy of the indices that have been built so far.
    This action is only valid between calls to Begin() and End() - otherwise,
    this action will throw an error.
    */
    action GetIndices returns Array<integer>
        return indices
    end

    /*
    This action will return the attributes that were given for the current Mesh
    under construction. If there isn't a Mesh currently being built, this will
    be undefined.
    */
    action GetAttributes returns VertexAttributes
        return attributes
    end

    /*
    This action will return the MeshPart currently under construction by the
    MeshBuilder. If there isn't a MeshPart under construction, then this will be
    undefined.
    */
    action GetMeshPart returns MeshPart
        return part
    end

    /*
    This action will return the primitive type being used to define the geometry
    of the current Mesh under construction. The primitive type is an integer 
    value that represents an OpenGL constant, such as TRIANGLES.
    */
    action GetPrimitiveType returns integer
        return primitiveType
    end

    /*
    This action will set the color value of the vertices that are created during
    Mesh construction. The color is made of a red, green, blue, and alpha (or
    transparency) component.
    */
    action SetColor(number red, number green, number blue, number alpha)
        color:SetColor(red, green, blue, alpha)
        hasColor = not (red = 1.0 and green = 1.0 and blue = 1.0 and alpha = 1.0)
    end

    /*
    This action will set the color value of the vertices that are created during
    Mesh construction.
    */
    action SetColor(Color newColor)
        if newColor not= undefined
            color:SetColor(newColor:GetRed(), newColor:GetGreen(), newColor:GetBlue(), newColor:GetAlpha())
        else
            color:SetColor(1.0, 1.0, 1.0, 1.0)
        end

        hasColor = not (color:GetRed() = 1.0 and color:GetGreen() = 1.0 and color:GetBlue() = 1.0 and color:GetAlpha() = 1.0)
    end

    // TO-DO: Better clarify what this action does.
    /*
    This action will set the UV range that will be applied to the vertices of
    the Mesh under construction. The UV values are used to determine how a 
    texture should be mapped onto the Mesh.
    */
    action SetUVRange(number u1, number v1, number u2, number v2)
        uOffset = u1
        vOffset = v1
        uScale = u2 - u1
        vScale = v2 - v1
        number errorMargin = 0.000001
        hasUVTransform = not (math:AbsoluteValue(u1) < errorMargin
                          and math:AbsoluteValue(v1) < errorMargin
                          and math:AbsoluteValue(u2 - 1.0) < errorMargin
                          and math:AbsoluteValue(v2 - 1.0) < errorMargin)
    end

    // TO-DO: Better clarify what this action does.
    /*
    This action will set the UV range that will be applied to the vertices of
    the Mesh under construction. The UV values are used to determine how a 
    texture should be mapped onto the Mesh.
    */
    action SetUVRange(TextureRegion region)
        if region = undefined
            hasUVTransform = false
            uOffset = 0
            vOffset = 0
            uScale = 1
            vScale = 1
        else
            SetUVRange(region:GetLeftSide(), region:GetTopSide(), region:GetRightSide(), region:GetBottomSide())
        end
    end

    /*
    This action will return a new Matrix4 object containing a copy of the vertex
    transformation matrix that the current Mesh being built is using.
    */
    action GetVertexTransform returns Matrix4
        Matrix4 new
        new:Set(positionTransform)
        return new
    end

    /*
    This action will set the transformation matrix for the vertices of the Mesh
    that is under construction.
    */
    action SetVertexTransform(Matrix4 transform)
        if transform not= undefined
            vertexTransformationEnabled = true
            positionTransform:Set(transform)
            normalTransform:Set(transform):Inverse():Transpose()
        else
            vertexTransformationEnabled = false
            positionTransform:IdentityMatrix()
            normalTransform:IdentityMatrix()
        end
    end

    /*
    This action will return whether or not the Mesh under construction is
    currently using a Matrix4 to transform its vertices.
    */
    action IsVertexTransformationEnabled returns boolean
        return vertexTransformationEnabled
    end

    /*
    This action will set the MeshBuilder to allow for vertex transformation
    using a Matrix4 object.
    */
    action SetVertexTransformationEnabled(boolean enabled)
        vertexTransformationEnabled = enabled
    end

    /*
    This action will ensure that the current Mesh under construction will
    have enough room to store the given number of vertices, in addition to what
    it is currently storing.
    */
    action EnsureVertices(integer numVertices)
        vertices:SetMaxSize(vertices:GetSize() + numVertices * vertexSize)
    end

    /*
    This action will ensure that the current Mesh under construction will
    support all of its current indices, plus the given number of additional
    indices.
    */
    action EnsureIndices(integer numIndices)
        indices:SetMaxSize(indices:GetSize() + numIndices)
    end

    /*
    This action will guarantee that the Mesh under construction will have the
    proper number of indices to form the given number of triangles, based on
    what primitive type has already been set for the Mesh.
    */
    action EnsureTriangleIndices(integer numTriangles)
        if primitiveType = LINES
            EnsureIndices(6 * numTriangles)
        elseif primitiveType = TRIANGLES or primitiveType = POINTS
            EnsureIndices(3 * numTriangles)
        else
            alert("The MeshBuilder was given an invalid primitive type - the supported values are the POINTS, LINES, or TRIANGLES constants.")
        end
    end
  
    /*
    This action will guarantee that the Mesh under construction will have the
    proper number of indices to form the given number of rectangles, based on
    what primitive type has already been set for the Mesh.
    */
    action EnsureRectangleIndices(integer numRectangles)
        if primitiveType = POINTS
            EnsureIndices(4 * numRectangles)
        elseif primitiveType = LINES
            EnsureIndices(8 * numRectangles)
        elseif primitiveType = TRIANGLES
            EnsureIndices(6 * numRectangles)
        else
            alert("The MeshBuilder was given an invalid primitive type - the supported values are the POINTS, LINES, or TRIANGLES constants.")
        end
    end

    /*
    This action will return what the last index used was during the construction
    of a Mesh.
    */
    action GetLastIndex returns integer
        return lastIndex
    end
    
    private action TransformPosition(Array<number> values, integer offset, integer size, Matrix4 transform)
        if size > 2
            calcVector1:Set(values:Get(offset), values:Get(offset + 1), values:Get(offset + 2))
            calcVector1:Multiply(transform)
            values:Set(offset, calcVector1:GetX())
            values:Set(offset + 1, calcVector1:GetY())
            values:Set(offset + 2, calcVector1:GetZ())
        elseif size > 1
            calcVector1:Set(values:Get(offset), values:Get(offset + 1), 0)
            calcVector1:Multiply(transform)
            values:Set(offset, calcVector1:GetX())
            values:Set(offset + 1, calcVector1:GetY())
        else
            calcVector1:Set(values:Get(offset), 0, 0)
            calcVector1:Multiply(transform)
            values:Set(offset, calcVector1:GetX())
        end
    end

    private action TransformNormal(Array<number> values, integer offset, integer size, Matrix3 transform)
        if size > 2
            calcVector1:Set(values:Get(offset), values:Get(offset + 1), values:Get(offset + 2))
            calcVector1:Multiply(transform)
            calcVector1:Normalize()
            values:Set(offset, calcVector1:GetX())
            values:Set(offset + 1, calcVector1:GetY())
            values:Set(offset + 2, calcVector1:GetZ())
        elseif size > 1
            calcVector1:Set(values:Get(offset), values:Get(offset + 1), 0)
            calcVector1:Multiply(transform)
            calcVector1:Normalize()
            values:Set(offset, calcVector1:GetX())
            values:Set(offset + 1, calcVector1:GetY())
        else
            calcVector1:Set(values:Get(offset), 0, 0)
            calcVector1:Multiply(transform)
            calcVector1:Normalize()
            values:Set(offset, calcVector1:GetX())
        end
    end

    private action AddVertex(Array<number> values, integer offset)
        integer originalSize = vertices:GetSize()
        
        integer counter = 0
        repeat values:GetSize() times
            vertices:Add(values:Get(counter))
            counter = counter + 1
        end

        lastIndex = vertexIndex
        vertexIndex = vertexIndex + 1

        if vertexTransformationEnabled
            TransformPosition(vertices, originalSize + positionOffset, positionSize, positionTransform)
            
            if normalOffset >= 0
                TransformNormal(vertices, originalSize + normalOffset, 3, normalTransform)
            end

            if binormalOffset >= 0
                TransformNormal(vertices, originalSize + binormalOffset, 3, normalTransform)
            end

            if tangentOffset >= 0
                TransformNormal(vertices, originalSize + tangentOffset, 3, normalTransform)
            end
        end

        number x = vertices:Get(originalSize + positionOffset)
        number y = 0
        number z = 0
        if positionSize > 1
            y = vertices:Get(originalSize + positionOffset + 1)
            if positionSize > 2
                z = vertices:Get(originalSize + positionOffset + 2)
            end
        end
        bounds:Extend(x, y, z)

        if hasColor
            if colorOffset >= 0
                vertices:Set(originalSize + colorOffset, vertices:Get(originalSize + colorOffset) * color:GetRed())
                vertices:Set(originalSize + colorOffset + 1, vertices:Get(originalSize + colorOffset + 1) * color:GetGreen())
                vertices:Set(originalSize + colorOffset + 2, vertices:Get(originalSize + colorOffset + 2) * color:GetBlue())
                if colorSize > 3
                    vertices:Set(originalSize + colorOffset + 3, vertices:Get(originalSize + colorOffset + 3) * color:GetAlpha())
                end
            elseif colorPackedOffset >= 0
                tempColor:SetColorFromCode(numberUtilities:EncodeNumberAsInteger(vertices:Get(originalSize + colorPackedOffset)))
                tempColor:SetColor(tempColor:GetRed() * color:GetRed(), tempColor:GetGreen() * color:GetGreen(),
                    tempColor:GetBlue() * color:GetBlue(), tempColor:GetAlpha() * color:GetAlpha())

                vertices:Set(originalSize + colorPackedOffset, tempColor:EncodeColorAsNumber())
            end
        end

        if hasUVTransform and textureCoordinatesOffset >= 0
            vertices:Set(originalSize + textureCoordinatesOffset, uOffset + uScale * vertices:Get(originalSize + textureCoordinatesOffset))
            vertices:Set(originalSize + textureCoordinatesOffset + 1, vOffset + vScale * vertices:Get(originalSize + textureCoordinatesOffset + 1))
        end
    end

    /*
    This action will create a new vertex and add it to the Mesh currently under
    construction. The index of the newly created vertex will be returned.
    */
    action AddVertex(Vector3 pos, Vector3 norm, Color col, Vector2 uv) returns integer
        if vertexIndex = vertexIndex:GetMaximumValue()
            alert("I can't add another vertex to the mesh because I've already used the maximum possible.")
        end

        vertex:Set(positionOffset, pos:GetX())
        
        if positionSize > 1
            vertex:Set(positionOffset + 1, pos:GetY())
            if positionSize > 2
                vertex:Set(positionOffset + 2, pos:GetZ())
            end
        end

        if normalOffset >= 0
            if norm = undefined
                calcVector1:Set(pos):Normalize()
                vertex:Set(normalOffset, calcVector1:GetX())
                vertex:Set(normalOffset + 1, calcVector1:GetY())
                vertex:Set(normalOffset + 2, calcVector1:GetZ())
            else
                vertex:Set(normalOffset, norm:GetX())
                vertex:Set(normalOffset + 1, norm:GetY())
                vertex:Set(normalOffset + 2, norm:GetZ())
            end
        end

        if colorOffset >= 0
            if color = undefined
                vertex:Set(colorOffset, 1.0)
                vertex:Set(colorOffset + 1, 1.0)
                vertex:Set(colorOffset + 2, 1.0)
                if colorSize > 3
                    vertex:Set(colorOffset + 3, 1.0)
                end
            else
                vertex:Set(colorOffset, col:GetRed())
                vertex:Set(colorOffset + 1, col:GetGreen())
                vertex:Set(colorOffset + 2, col:GetBlue())
                if colorSize > 3
                    vertex:Set(colorOffset + 3, col:GetAlpha())
                end
            end
        elseif colorPackedOffset >= 0
            if col = undefined
                Color newColor = color:White()
                vertex:Set(colorPackedOffset, newColor:EncodeColorAsNumber())
            else
                vertex:Set(colorPackedOffset, col:EncodeColorAsNumber())
            end
        end

        if uv not= undefined and textureCoordinatesOffset >= 0
            vertex:Set(textureCoordinatesOffset, uv:GetX())
            vertex:Set(textureCoordinatesOffset + 1, uv:GetY())
        end

        AddVertex(vertex, 0)
        return lastIndex
    end

    /*
    This action will add the vertex described by the given VertexSchematic to
    the Mesh currently under construction. This action will return the index of
    the newly added vertex.
    */
    action AddVertex(VertexSchematic schematic) returns integer
        Vector3 position = undefined
        Vector3 normal = undefined
        Color color = undefined
        Vector2 uv = undefined

        if schematic:HasPosition()
            position = schematic:GetPosition()
        end

        if schematic:HasNormal()
            normal = schematic:GetNormal()
        end

        if schematic:HasColor()
            color = schematic:GetColor()
        end

        if schematic:HasTextureCoordinates()
            uv = schematic:GetTextureCoordinates()
        end

        return AddVertex(position, normal, color, uv)
    end

    /*
    This action will add a new index to the indices of the Mesh under
    construction. 
    */
    action AddIndex(integer value)
        indices:Add(value)
    end

    /*
    This action will create a new line between the two given indices in the Mesh
    under construction. This is only valid if the primitive type being used is
    LINES - otherwise, an error will be thrown.
    */
    action AddLine(integer index1, integer index2)
        if primitiveType not= LINES
            alert("I can't add a line to the Mesh because the primitive type used to define the Mesh is not LINES!")
        end

        EnsureIndices(2)
        indices:Add(index1)
        indices:Add(index2)
    end

    /*
    This action will add two new vertices to the current Mesh under
    construction, and then create a line between them. This is only valid if the
    primitive type being used is LINES - otherwise, an error will be thrown.
    */
    action AddLine(VertexSchematic point1, VertexSchematic point2)
        EnsureVertices(2)
        AddLine(AddVertex(point1), AddVertex(point2))
    end

    /*
    This action will add two new vertices to the current Mesh under
    construction, and then create a line between them. This is only valid if the
    primitive type being used is LINES - otherwise, an error will be thrown.
    */
    action AddLine(Vector3 point1, Vector3 point2)
        vertTemp1:Set(point1, undefined, undefined, undefined)
        vertTemp2:Set(point2, undefined, undefined, undefined)
        AddLine(vertTemp1, vertTemp2)
    end

    /*
    This action will add two new vertices to the current Mesh under
    construction, and then create a line between them. This is only valid if the
    primitive type being used is LINES - otherwise, an error will be thrown.
    */
    action AddLine(number x1, number y1, number z1, number x2, number y2, number z2)
        vertTemp1:Set(undefined, undefined, undefined, undefined):SetPosition(x1, y1, z1)
        vertTemp2:Set(undefined, undefined, undefined, undefined):SetPosition(x2, y2, z2)
        AddLine(vertTemp1, vertTemp2)
    end

    /*
    This action will add two new vertices to the current Mesh under
    construction, and then create a line between them. This is only valid if the
    primitive type being used is LINES - otherwise, an error will be thrown.
    */
    action AddLine(Vector3 point1, Color color1, Vector3 point2, Color color2)
        vertTemp1:Set(point1, undefined, color1, undefined)
        vertTemp2:Set(point2, undefined, color1, undefined)
        AddLine(vertTemp1, vertTemp2)
    end

    /*
    This action will create a new triangle between the three given indices in
    the Mesh under construction. This is only valid if the primitive type being
    used is either POINTS, LINES, or TRIANGLES. Otherwise, an error will be
    thrown.
    */
    action AddTriangle(integer index1, integer index2, integer index3)
        if primitiveType = TRIANGLES or primitiveType = POINTS
            EnsureIndices(3)
            indices:Add(index1)
            indices:Add(index2)
            indices:Add(index3)
        elseif primitiveType = LINES
            EnsureIndices(6)
            indices:Add(index1)
            indices:Add(index2)
            indices:Add(index2)
            indices:Add(index3)
            indices:Add(index3)
            indices:Add(index1)
        else
            alert("I was asked to add a triangle, but I can only do that if the primitive type I'm using is POINTS, LINES, or TRIANGLES.")
        end
    end

    /*
    This action will add three new vertices to the Mesh under construction, and
    create a triangle between them. The primitive type used must be POINTS,
    LINES, or TRIANGLES. Otherwise, an error will be thrown.
    */
    action AddTriangle(VertexSchematic point1, VertexSchematic point2, VertexSchematic point3)
        EnsureVertices(3)
        AddTriangle(AddVertex(point1), AddVertex(point2), AddVertex(point3))
    end

    /*
    This action will add three new vertices to the Mesh under construction, and
    create a triangle between them. The primitive type used must be POINTS,
    LINES, or TRIANGLES. Otherwise, an error will be thrown.
    */
    action AddTriangle(Vector3 point1, Vector3 point2, Vector3 point3)
        vertTemp1:Set(point1, undefined, undefined, undefined)
        vertTemp2:Set(point2, undefined, undefined, undefined)
        vertTemp3:Set(point3, undefined, undefined, undefined)
        AddTriangle(AddVertex(vertTemp1), AddVertex(vertTemp2), AddVertex(vertTemp3))
    end

    /*
    This action will add three new vertices to the Mesh under construction, and
    create a triangle between them. The primitive type used must be POINTS,
    LINES, or TRIANGLES. Otherwise, an error will be thrown.
    */
    action AddTriangle(Vector3 point1, Color color1, Vector3 point2, Color color2, Vector3 point3, Color color3)
        vertTemp1:Set(point1, undefined, color1, undefined)
        vertTemp2:Set(point2, undefined, color2, undefined)
        vertTemp3:Set(point3, undefined, color3, undefined)
        AddTriangle(AddVertex(vertTemp1), AddVertex(vertTemp2), AddVertex(vertTemp3))
    end

    /*
    This action will add a new Rectangle to the Mesh under construction, using
    the given indices to form the rectangle. The supported primitive types are
    POINTS, LINES, and TRIANGLES - any other primitive type will throw an error.
    */
    action BuildRectangle(integer corner00, integer corner10, integer corner11, integer corner01)
        if primitiveType = TRIANGLES
            EnsureIndices(6)
            indices:Add(corner00)
            indices:Add(corner10)
            indices:Add(corner11)
            indices:Add(corner11)
            indices:Add(corner01)
            indices:Add(corner00)
        elseif primitiveType = LINES
            EnsureIndices(8)
            indices:Add(corner00)
            indices:Add(corner10)
            indices:Add(corner10)
            indices:Add(corner11)
            indices:Add(corner11)
            indices:Add(corner01)
            indices:Add(corner01)
            indices:Add(corner00)
        elseif primitiveType = POINTS
            EnsureIndices(4)
            indices:Add(corner00)
            indices:Add(corner10)
            indices:Add(corner11)
            indices:Add(corner01)
        else
            alert("I was given an invalid primitive type for construction rectangles - the supported primitive types are POINTS, LINES, and TRIANGLES.")
        end
    end

    /*
    This action will add four new vertices to the Mesh under construction, and
    form a rectangle between them. The primitive type used must be POINTS,
    LINES, or TRIANGLES - otherwise, an error will be thrown.
    */
    action BuildRectangle(VertexSchematic corner00, VertexSchematic corner10, VertexSchematic corner11, VertexSchematic corner01)
        EnsureVertices(4)
        BuildRectangle(AddVertex(corner00), AddVertex(corner10), AddVertex(corner11), AddVertex(corner01))
    end

    /*
    This action will add four new vertices to the Mesh under construction, and
    form a rectangle between them. The primitive type used must be POINTS,
    LINES, or TRIANGLES - otherwise, an error will be thrown.
    */
    action BuildRectangle(Vector3 corner00, Vector3 corner10, Vector3 corner11, Vector3 corner01, Vector3 normal)
        vertTemp1:Set(corner00, normal, undefined, undefined)
        vertTemp1:SetTextureCoordinates(0, 1)
        vertTemp2:Set(corner10, normal, undefined, undefined)
        vertTemp2:SetTextureCoordinates(1, 1)
        vertTemp3:Set(corner11, normal, undefined, undefined)
        vertTemp3:SetTextureCoordinates(1, 0)
        vertTemp4:Set(corner01, normal, undefined, undefined)
        vertTemp4:SetTextureCoordinates(0, 0)
        BuildRectangle(vertTemp1, vertTemp2, vertTemp3, vertTemp4)
    end

    /*
    This action will add the geometry of an existing Mesh to the Mesh that is
    currently under construction by the MeshBuilder.
    */
//    action AddMesh(Mesh mesh)
//        AddMesh(mesh, 0, mesh:GetIndicesCount())
//    end

    /*
    This action will add an existing MeshPart to the Mesh that is currently
    under construction by the MeshBuilder.
    */
//    action AddMesh(MeshPart meshPart)
//        if meshPart:primitiveType not= primitiveType
//            alert("The primitive type of the MeshPart doesn't match the primitive type being used by the Mesh under construction.")
//        end
//
//        AddMesh(meshPart:mesh, meshPart:indexOffset, meshPart:verticesCount)
//    end

    /*
    This action will add an existing MeshPart to the Mesh that is currently
    under construction by the MeshBuilder.
    */
//    action AddMesh(Mesh mesh, integer indexOffset, integer numIndices)
//        if not attributes:Equals(mesh:GetVertexAttributes())
//            alert("The vertex attributes of the given Mesh do not match the vertex attributes of the Mesh under construction.")
//        end
//
//        if numIndices <= 0
//            return now
//        end
//
//        integer numberCount = mesh:GetVerticesCount() * vertexSize
//        tempVertices:Empty()
//        tempVertices:SetMaxSize(numberCount)
//        mesh:GetVertices(tempVertices)
//
//        tempIndices:Empty()
//        tempIndices:SetMaxSize(numIndices)
//        mesh:GetIndices(indexOffset, numIndices, tempIndices, 0)
//
//        AddMesh(tempVertices, tempIndices, 0, numIndices)
//    end

    /*
    This action will add the given vertex and index arrays to the geometry of
    the Mesh currently under construction by the MeshBuilder.
    */
//    action AddMesh(Array<number> vertices, Array<integer> indicies, integer indexOffset, integer numIndices)
//         if indicesMap = undefined
//              ...
//         else
//            indicesMap:Empty()
//            indicesMap:SetMaxSize(numIndices)
//         end
//
//        EnsureIndices(numIndices)
//        integer numVertices = vertices:GetSize() / vertexSize
//        if numVertices < numIndices
//            EnsureVertices(numVertices)
//        else
//            EnsureVertices(numIndices)
//        end
//
//        integer counter = 0
//        repeat numIndices times
//            integer sidx = indices:Get(indexOffset + counter)
//            integer didx = indicesMap:Get(sidx, -1)
//            if didx < 0
//                AddVertex(vertices, sidx * vertexSize)
//                didx = lastIndex
//                //indicesMap:Set(sidx, lastIndex)
//            end
//        
//            AddIndex(didx)
//            counter = counter + 1
//        end
//    end

    /*
    This action will add the given vertex and index arrays to the geometry of
    the Mesh currently under construction by the MeshBuilder.
    */
    action AddMesh(Array<number> vertices, Array<integer> indices)
        integer offset = lastIndex + 1

        integer numVertices = vertices:GetSize() / vertexSize
        EnsureVertices(numVertices)

        integer counter = 0
        repeat while counter < vertices:GetSize()
            AddVertex(vertices, counter)
            counter = counter + vertexSize
        end

        EnsureIndices(indices:GetSize())
        
        counter = 0
        repeat while counter < indices:GetSize()
            AddIndex(indices:Get(counter) + offset)
            counter = counter + 1
        end
    end

    /*
    This action will create a box using the 8 provided vertices.
    */
    action BuildBox(VertexSchematic corner000, VertexSchematic corner010, VertexSchematic corner100, VertexSchematic corner110,
                    VertexSchematic corner001, VertexSchematic corner011, VertexSchematic corner101, VertexSchematic corner111)
        
        EnsureVertices(8)
        integer i000 = AddVertex(corner000)
        integer i100 = AddVertex(corner100)
        integer i110 = AddVertex(corner110)
        integer i010 = AddVertex(corner010)
        integer i001 = AddVertex(corner001)
        integer i101 = AddVertex(corner101)
        integer i111 = AddVertex(corner111)
        integer i011 = AddVertex(corner011)

        if primitiveType = LINES
            EnsureIndices(24)
            BuildRectangle(i000, i100, i110, i010)
            BuildRectangle(i101, i001, i011, i111)
            EnsureIndices(8)
            indices:Add(i000)
            indices:Add(i001)
            indices:Add(i010)
            indices:Add(i011)
            indices:Add(i110)
            indices:Add(i111)
            indices:Add(i100)
            indices:Add(i101)
        elseif primitiveType = POINTS
            EnsureRectangleIndices(2)
            BuildRectangle(i000, i100, i110, i010)
            BuildRectangle(i101, i001, i011, i111)
        elseif primitiveType = TRIANGLES
            EnsureRectangleIndices(6)
            BuildRectangle(i000, i100, i110, i010)
            BuildRectangle(i101, i001, i011, i111)
            BuildRectangle(i000, i010, i011, i001)
            BuildRectangle(i101, i111, i110, i100)
            BuildRectangle(i101, i100, i000, i001)
            BuildRectangle(i110, i111, i011, i010)
        else
            alert("I did not recognize the primitive type used to construct the box - the valid values are POINTS, LINES, and TRIANGLES.")
        end
    end

    /*
    This action will create a box using the 8 provided vertices.
    */
    action BuildBox(Vector3 corner000, Vector3 corner010, Vector3 corner100, Vector3 corner110,
                    Vector3 corner001, Vector3 corner011, Vector3 corner101, Vector3 corner111)

        if (bits:And(attributes:GetMask(), (bits:Or(attributes:NORMAL, bits:Or(attributes:BINORMAL, bits:Or(attributes:TANGENT, attributes:TEXTURE_COORDINATES)))))) = 0
            vertTemp1:Set(corner000, undefined, undefined, undefined)
            vertTemp2:Set(corner010, undefined, undefined, undefined)
            vertTemp3:Set(corner100, undefined, undefined, undefined)
            vertTemp4:Set(corner110, undefined, undefined, undefined)
            vertTemp5:Set(corner001, undefined, undefined, undefined)
            vertTemp6:Set(corner011, undefined, undefined, undefined)
            vertTemp7:Set(corner101, undefined, undefined, undefined)
            vertTemp8:Set(corner111, undefined, undefined, undefined)
            BuildBox(vertTemp1, vertTemp2, vertTemp3, vertTemp4, vertTemp5, vertTemp6, vertTemp7, vertTemp8)
        else
            EnsureVertices(24)
            EnsureRectangleIndices(6)
            Vector3 norm = calcVector1:Set(corner000):LinearInterpolation(corner110, 0.5):Subtract(calcVector2:Set(corner001):LinearInterpolation(corner111, 0.5)):Normalize()
            BuildRectangle(corner000, corner010, corner110, corner100, norm)
            BuildRectangle(corner011, corner001, corner101, corner111, norm:Scale(-1))
            norm = calcVector1:Set(corner000):LinearInterpolation(corner101, 0.5):Subtract(calcVector2:Set(corner010):LinearInterpolation(corner111, 0.5)):Normalize()
            BuildRectangle(corner001, corner000, corner100, corner101, norm)
            BuildRectangle(corner010, corner011, corner111, corner110, norm:Scale(-1))
            norm = calcVector1:Set(corner000):LinearInterpolation(corner011, 0.5):Subtract(calcVector2:Set(corner100):LinearInterpolation(corner111, 0.5)):Normalize()
            BuildRectangle(corner001, corner011, corner010, corner000, norm)
            BuildRectangle(corner100, corner110, corner111, corner101, norm:Scale(-1))
        end
    end

    /*
    This action will build a box with the given width, height, and depth.
    */
    action BuildBox(number width, number height, number depth)
        BuildBox(0, 0, 0, width, height, depth)
    end

    /*
    This action will build a box at the provided coordinates with the given
    width, height, and depth.
    */
    action BuildBox(number x, number y, number z, number width, number height, number depth)
        number halfWidth = width * 0.5
        number halfHeight = height * 0.5
        number halfDepth = depth * 0.5
        number x0 = x - halfWidth
        number y0 = y - halfHeight
        number z0 = z - halfDepth
        number x1 = x + halfWidth
        number y1 = y + halfHeight
        number z1 = z + halfDepth

        BuildBox(tempVector1:Set(x0, y0, z0), tempVector2:Set(x0, y1, z0), tempVector3:Set(x1, y0, z0), tempVector4:Set(x1, y1, z0),
                 tempVector5:Set(x0, y0, z1), tempVector6:Set(x0, y1, z1), tempVector7:Set(x1, y0, z1), tempVector8:Set(x1, y1, z1))
    end

    action BuildPlane(number width, number depth, boolean doubleSided)
        BuildPlane(0, 0, 0, width, depth, doubleSided)
    end

    action BuildPlane(number x, number y, number z, number width, number depth, boolean doubleSided)
        number halfWidth = width * 0.5
        number halfDepth = depth * 0.5
        number x0 = x - halfWidth
        number z0 = z - halfDepth
        number x1 = x + halfWidth
        number z1 = z + halfDepth
        
        Vector3 corner00 = tempVector1:Set(x0, y, z0)
        Vector3 corner01 = tempVector2:Set(x0, y, z1)
        Vector3 corner11 = tempVector3:Set(x1, y, z1)
        Vector3 corner10 = tempVector4:Set(x1, y, z0)

        if (bits:And(attributes:GetMask(), (bits:Or(attributes:NORMAL, bits:Or(attributes:BINORMAL, bits:Or(attributes:TANGENT, attributes:TEXTURE_COORDINATES)))))) = 0
            vertTemp1:Set(corner00, undefined, undefined, undefined)
            vertTemp2:Set(corner01, undefined, undefined, undefined)
            vertTemp3:Set(corner10, undefined, undefined, undefined)
            vertTemp4:Set(corner11, undefined, undefined, undefined)
            BuildPlane(vertTemp1, vertTemp2, vertTemp3, vertTemp4, doubleSided)
        else
            if doubleSided
                EnsureVertices(8)
                EnsureRectangleIndices(2)
                Vector3 norm = calcVector1:Set(0, 1, 0)
                BuildRectangle(corner00, corner01, corner11, corner10, norm)
                norm = calcVector1:Set(0, -1, 0)
                BuildRectangle(corner10, corner11, corner01, corner00, norm)
            else
                EnsureVertices(4)
                EnsureRectangleIndices(1)
                Vector3 norm = calcVector1:Set(0, 1, 0)
                BuildRectangle(corner00, corner01, corner11, corner10, norm)
            end
        end
    end

    action BuildPlane(VertexSchematic corner00, VertexSchematic corner01, VertexSchematic corner10, VertexSchematic corner11, boolean doubleSided)
        
        EnsureVertices(4)
        integer i00 = AddVertex(corner00)
        integer i10 = AddVertex(corner10)
        integer i11 = AddVertex(corner11)
        integer i01 = AddVertex(corner01)

        if primitiveType = LINES or primitiveType = POINTS or primitiveType = TRIANGLES
            EnsureRectangleIndices(1)
            BuildRectangle(i00, i10, i11, i01)

            if doubleSided
                //BuildRectangle(i01, i11, i10, i00)
            end
        else
            alert("I did not recognize the primitive type used to construct the plane - the valid values are POINTS, LINES, and TRIANGLES.")
        end
    end

    /*
    This action will build a cylinder shape with the given width, height, and
    depth. The curve of the cylinder will be made using the provided number of
    divisions to approximate the curve using straight edges.
    */
    action BuildCylinder(number width, number height, number depth, integer divisions)
        BuildCylinder(width, height, depth, divisions, 0, 360)
    end

    /*
    This action will build a cylinder shape with the given width, height, and
    depth. The curve of the cylinder will be made using the provided number of
    divisions to form straight edges from the starting angle to the ending angle
    (in degrees).
    */
    action BuildCylinder(number width, number height, number depth, integer divisions, number angleFrom, number angleTo)
        BuildCylinder(width, height, depth, divisions, angleFrom, angleTo, true)
    end

    /*
    This action will build a cylinder shape with the given width, height, and
    depth. The curve of the cylinder will be made using the provided number of
    divisions to form straight edges from the starting angle to the ending angle
    (in degrees). If the provided boolean is true, the cylinder will be closed
    (the ends will be capped). Otherwise, the cylinder will be open (the ends
    will not be capped).
    */
    action BuildCylinder(number width, number height, number depth, integer divisions, number angleFrom, number angleTo, boolean close)
        number halfWidth = width * 0.5
        number halfHeight = height * 0.5
        number halfDepth = depth * 0.5
        number startAngle = math:DegreesToRadians(angleFrom)
        number step = math:DegreesToRadians(angleTo - angleFrom) / divisions
        number divisionStep = 1.0 / divisions
        number u = 0
        number angle = 0
        
        VertexSchematic current1 = vertTemp3
        current1:Set(undefined, undefined, undefined, undefined)
        current1:SetTextureCoordinates(0, 0)
        current1:SetPosition(0, 0, 0)
        current1:SetNormal(0, 1, 0)

        VertexSchematic current2 = vertTemp4
        current2:Set(undefined, undefined, undefined, undefined)
        current2:SetTextureCoordinates(0, 0)
        current2:SetPosition(0, 0, 0)
        current2:SetNormal(0, 1, 0)

        integer i1 = 0
        integer i2 = 0
        integer i3 = 0
        integer i4 = 0

        EnsureVertices(2 * (divisions + 1))
        EnsureRectangleIndices(divisions)

        integer counter = 0
        repeat while counter <= divisions
            angle = startAngle + step * counter
            u = 1.0 - divisionStep * counter
            current1:SetPosition(math:Cosine(angle) * halfWidth, 0, math:Sine(angle) * halfDepth)
            current1:SetNormal(tempVector8:Set(current1:GetPosition()):Normalize())
            current1:GetPosition():SetY(-halfHeight)
            current1:SetTextureCoordinates(u, 1)
            
            current2:SetPosition(current1:GetPosition():GetX(), halfHeight, current1:GetPosition():GetZ())
            current2:SetNormal(current1:GetNormal())
            current2:SetTextureCoordinates(u, 0)

            i2 = AddVertex(current1)
            i1 = AddVertex(current2)
            if counter not= 0
                BuildRectangle(i3, i1, i2, i4)
            end

            i4 = i2
            i3 = i1

            counter = counter + 1
        end

        if close
            BuildEllipse(width, depth, 0, 0, divisions, 0, halfHeight, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, angleFrom, angleTo)
            BuildEllipse(width, depth, 0, 0, divisions, 0, -halfHeight, 0, 0, -1, 0, -1, 0, 0, 0, 0, 1, 180.0 - angleTo, 180.0 - angleFrom)
        end
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, integer divisions, number centerX, number centerY, number centerZ, number normalX, number normalY, number normalZ)
        BuildEllipse(width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, 0, 360)
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, integer divisions, Vector3 center, Vector3 normal)
        BuildEllipse(width, height, divisions, center:GetX(), center:GetY(), center:GetZ(), normal:GetX(), normal:GetY(), normal:GetZ())
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, integer divisions, Vector3 center, Vector3 normal, Vector3 tangent, Vector3 binormal)
        BuildEllipse(width, height, divisions, center:GetX(), center:GetY(), center:GetZ(), normal:GetX(), normal:GetY(), normal:GetZ(),
            tangent:GetX(), tangent:GetY(), tangent:GetZ(), binormal:GetX(), binormal:GetY(), binormal:GetZ())
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, integer divisions, number centerX, number centerY, number centerZ, number normalX,
        number normalY, number normalZ, number tangentX, number tangentY, number tangentZ, number binormalX, number binormalY, number binormalZ)

        BuildEllipse(width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX, tangentY, tangentZ,
            binormalX, binormalY, binormalZ, 0, 360)
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, integer divisions, number centerX, number centerY, number centerZ, number normalX,
        number normalY, number normalZ, number angleFrom, number angleTo)

        BuildEllipse(width, height, 0, 0, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, angleFrom, angleTo)
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, integer divisions, Vector3 center, Vector3 normal, number angleFrom, number angleTo)
        BuildEllipse(width, height, 0, 0, divisions, center:GetX(), center:GetY(), center:GetZ(), normal:GetX(), normal:GetY(), normal:GetZ(), angleFrom, angleTo)
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, integer divisions, Vector3 center, Vector3 normal, Vector3 tangent, Vector3 binormal, number angleFrom, number angleTo)
        BuildEllipse(width, height, 0, 0, divisions, center:GetX(), center:GetY(), center:GetZ(), normal:GetX(), normal:GetY(), normal:GetZ(),
            tangent:GetX(), tangent:GetY(), tangent:GetZ(), binormal:GetX(), binormal:GetY(), binormal:GetZ(), angleFrom, angleTo)
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, integer divisions, number centerX, number centerY, number centerZ, number normalX, number normalY, number normalZ,
        number tangentX, number tangentY, number tangentZ, number binormalX, number binormalY, number binormalZ, number angleFrom, number angleTo)

        BuildEllipse(width, height, 0, 0, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX, tangentY,
            tangentZ, binormalX, binormalY, binormalZ, angleFrom, angleTo)
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, number innerWidth, number innerHeight, integer divisions, Vector3 center, Vector3 normal)
        BuildEllipse(width, height, innerWidth, innerHeight, divisions, center:GetX(), center:GetY(), center:GetZ(), normal:GetX(),
            normal:GetY(), normal:GetZ(), 0, 360)
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, number innerWidth, number innerHeight, integer divisions,
        number centerX, number centerY, number centerZ, number normalX, number normalY, number normalZ)

        BuildEllipse(width, height, innerWidth, innerHeight, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, 0, 360)
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, number innerWidth, number innerHeight, integer divisions, number centerX,
        number centerY, number centerZ, number normalX, number normalY, number normalZ, number angleFrom, number angleTo)

        tempVector1:Set(normalX, normalY, normalZ):CrossProduct(0, 0, 1)
        tempVector2:Set(normalX, normalY, normalZ):CrossProduct(0, 1, 0)

        if tempVector2:LengthSquared() > tempVector1:LengthSquared()
            tempVector1:Set(tempVector2)
        end

        tempVector2:Set(tempVector1:Normalize()):CrossProduct(normalX, normalY, normalZ):Normalize()
        
        BuildEllipse(width, height, innerWidth, innerHeight, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, 
            tempVector1:GetX(), tempVector1:GetY(), tempVector1:GetZ(), tempVector2:GetX(), tempVector2:GetY(), tempVector2:GetZ(), angleFrom, angleTo)
    end

    /*
    This action will add an ellipse to the geometry of the mesh that is under
    construction.
    */
    action BuildEllipse(number width, number height, number innerWidth, number innerHeight, integer divisions, number centerX,
        number centerY, number centerZ, number normalX, number normalY, number normalZ, number tangentX, number tangentY, number tangentZ,
        number binormalX, number binormalY, number binormalZ, number angleFrom, number angleTo)

        if innerWidth <= 0 or innerHeight <= 0
            EnsureVertices(divisions + 2)
            EnsureTriangleIndices(divisions)
        elseif innerWidth = width and innerHeight = height
            EnsureVertices(divisions + 1)
            EnsureIndices(divisions + 1)
            if primitiveType not= LINES
                alert("Because innerWidth = width and innerHeight = height, the only valid type of primitive is LINES, but I was set to use a different primitive type.")
            end
        else
            EnsureVertices((divisions + 1) * 2)
            EnsureRectangleIndices(divisions + 1)
        end

        number startAngle = math:DegreesToRadians(angleFrom)
        number step = math:DegreesToRadians(angleTo - angleFrom) / divisions
        Vector3 sxEx = tempVector1:Set(tangentX, tangentY, tangentZ):Scale(width * 0.5)
        Vector3 syEx = tempVector2:Set(binormalX, binormalY, binormalZ):Scale(height * 0.5)
        Vector3 sxIn = tempVector3:Set(tangentX, tangentY, tangentZ):Scale(innerWidth * 0.5)
        Vector3 syIn = tempVector4:Set(binormalX, binormalY, binormalZ):Scale(innerHeight * 0.5)

        VertexSchematic currIn = vertTemp3:Set(undefined, undefined, undefined, undefined)
        currIn:SetTextureCoordinates(0.5, 0.5)
        currIn:SetPosition(centerX, centerY, centerZ)
        currIn:SetNormal(normalX, normalY, normalZ)

        VertexSchematic currEx = vertTemp4:Set(undefined, undefined, undefined, undefined)
        currEx:SetTextureCoordinates(0.5, 0.5)
        currEx:SetPosition(centerX, centerY, centerZ)
        currEx:SetNormal(normalX, normalY, normalZ)

        integer center = AddVertex(currEx)
        number angle = 0
        number us = 0.5 * (innerWidth / width)
        number vs = 0.5 * (innerHeight / height)
        
        integer i1 = 0
        integer i2 = 0
        integer i3 = 0
        integer i4 = 0

        integer counter = 0
        repeat while counter <= divisions
            angle = startAngle + step * counter
            number x = math:Cosine(angle)
            number y = math:Sine(angle)
            
            currEx:SetPosition(centerX, centerY, centerZ)
            currEx:GetPosition():Add(sxEx:GetX() * x + syEx:GetX() * y, sxEx:GetY() * x + syEx:GetY() * y,
                sxEx:GetZ() * x + syEx:GetZ() * y)
            currEx:SetTextureCoordinates(0.5 + 0.5 * x, 0.5 + 0.5 * y)

            i1 = AddVertex(currEx)
            
            if innerWidth <= 0 or innerHeight <= 0
                if counter not= 0
                    AddTriangle(i1, i2, center)
                end
                i2 = i1
            elseif innerWidth = width and innerHeight = height
                if counter not= 0
                    AddLine(i1, i2)
                end
                i2 = i1
            else
                currIn:SetPosition(centerX, centerY, centerZ)
                currIn:GetPosition():Add(sxIn:GetX() * x + syIn:GetX() * y, sxIn:GetY() * x + syIn:GetY() * y,
                    sxIn:GetZ() * x + syIn:GetZ() * y)
                currIn:SetTextureCoordinates(0.5 + us * x, 0.5 + vs * y)

                i2 = i1
                i1 = AddVertex(currIn)

                if counter not= 0
                    BuildRectangle(i1, i2, i4, i3)
                end

                i4 = i2
                i3 = i1
            end

            counter = counter + 1
        end
    end

    /*
    This action will add a sphere to the geometry of the mesh under construction.
    */
    action BuildSphere(number width, number height, number depth, integer divisionsU, integer divisionsV)
        BuildSphere(width, height, depth, divisionsU, divisionsV, 0, 360, 0, 180)
    end

    /*
    This action will add a sphere to the geometry of the mesh under construction.
    */
    action BuildSphere(number width, number height, number depth, integer divisionsU,
     integer divisionsV, number angleUFrom, number angleUTo, number angleVFrom, number angleVTo)
        number halfWidth = width * 0.5
        number halfHeight = height * 0.5
        number halfDepth = depth * 0.5
        number auo = math:DegreesToRadians(angleUFrom)
        number stepU = (math:DegreesToRadians(angleUTo - angleUFrom)) / divisionsU
        number avo = math:DegreesToRadians(angleVFrom)
        number stepV = (math:DegreesToRadians(angleVTo - angleVFrom)) / divisionsV
        number us = 1.0 / divisionsU
        number vs = 1.0 / divisionsV
        number u = 0
        number v = 0
        number angleU = 0
        number angleV = 0
        VertexSchematic curr1 = vertTemp3:Set(undefined, undefined, undefined, undefined)
        curr1:SetTextureCoordinates(0, 0)
        curr1:SetPosition(0, 0, 0)
        curr1:SetNormal(0, 0, 0)

        integer s = divisionsU + 3
        Array<integer> tempIndices
        tempIndices:SetSize(s)
        integer tempOffset = 0

        EnsureVertices((divisionsV + 1) * (divisionsU + 1))
        EnsureRectangleIndices(divisionsU)

        integer iv = 0

        repeat while iv <= divisionsV
            angleV = avo + stepV * iv
            v = vs * iv
            number t = math:Sine(angleV)
            number h = math:Cosine(angleV) * halfHeight

            integer iu = 0
            repeat while iu <= divisionsU
                angleU = auo + stepU * iu
                u = 1.0 - us * iu

                curr1:GetPosition():Set(math:Cosine(angleU) * halfWidth * t, h, math:Sine(angleU) * halfDepth * t)
                curr1:GetNormal():Set(curr1:GetPosition()):Normalize()
                curr1:GetTextureCoordinates():Set(u, v)
                tempIndices:Set(tempOffset, AddVertex(curr1))

                integer o = tempOffset + s
                if ((iv > 0) and (iu > 0))
                    BuildRectangle(tempIndices:Get(tempOffset), tempIndices:Get((o - 1) mod s), tempIndices:Get((o - (divisionsU + 2)) mod s), tempIndices:Get((o - (divisionsU + 1)) mod s))
                end

                tempOffset = (tempOffset + 1) mod tempIndices:GetSize()
                iu = iu + 1
            end

            iv = iv + 1
        end

     end

end

/*

// TODO: The following methods are deprecated and will be removed in a future release
@Override
@Deprecated
public void patch (VertexInfo corner00, VertexInfo corner10, VertexInfo corner11, VertexInfo corner01, int divisionsU,
int divisionsV) {
PatchShapeBuilder.build(this, corner00, corner10, corner11, corner01, divisionsU, divisionsV);
}

@Override
@Deprecated
public void patch (Vector3 corner00, Vector3 corner10, Vector3 corner11, Vector3 corner01, Vector3 normal, int divisionsU,
int divisionsV) {
PatchShapeBuilder.build(this, corner00, corner10, corner11, corner01, normal, divisionsU, divisionsV);
}

@Override
@Deprecated
public void patch (float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11,
float x01, float y01, float z01, float normalX, float normalY, float normalZ, int divisionsU, int divisionsV) {
PatchShapeBuilder.build(this, x00, y00, z00, x10, y10, z10, x11, y11, z11, x01, y01, z01, normalX, normalY, normalZ, divisionsU, divisionsV);
}

@Override
@Deprecated
public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
float normalZ) {
EllipseShapeBuilder.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ);
}

@Override
@Deprecated
public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal) {
EllipseShapeBuilder.build(this, radius, divisions, center, normal);
}

@Override
@Deprecated
public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, final Vector3 tangent,
final Vector3 binormal) {
EllipseShapeBuilder.build(this, radius, divisions, center, normal, tangent, binormal);
}

@Override
@Deprecated
public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY, float binormalZ) {
EllipseShapeBuilder.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX,
tangentY, tangentZ, binormalX, binormalY, binormalZ);
}

@Override
@Deprecated
public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
float normalZ, float angleFrom, float angleTo) {
EllipseShapeBuilder
.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, angleFrom, angleTo);
}

@Override
@Deprecated
public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, float angleFrom, float angleTo) {
EllipseShapeBuilder.build(this, radius, divisions, center, normal, angleFrom, angleTo);
}

@Override
@Deprecated
public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, final Vector3 tangent,
final Vector3 binormal, float angleFrom, float angleTo) {
circle(radius, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z, tangent.x, tangent.y, tangent.z,
binormal.x, binormal.y, binormal.z, angleFrom, angleTo);
}

@Override
@Deprecated
public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY, float binormalZ,
float angleFrom, float angleTo) {
EllipseShapeBuilder.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX,
tangentY, tangentZ, binormalX, binormalY, binormalZ, angleFrom, angleTo);
}

@Override
@Deprecated
public void cone (float width, float height, float depth, int divisions) {
cone(width, height, depth, divisions, 0, 360);
}

@Override
@Deprecated
public void cone (float width, float height, float depth, int divisions, float angleFrom, float angleTo) {
ConeShapeBuilder.build(this, width, height, depth, divisions, angleFrom, angleTo);
}
@Override
@Deprecated
public void capsule (float radius, float height, int divisions) {
CapsuleShapeBuilder.build(this, radius, height, divisions);
}
@Override
@Deprecated
public void arrow (float x1, float y1, float z1, float x2, float y2, float z2, float capLength, float stemThickness,
int divisions) {
ArrowShapeBuilder.build(this, x1, y1, z1, x2, y2, z2, capLength, stemThickness, divisions);
}
*/