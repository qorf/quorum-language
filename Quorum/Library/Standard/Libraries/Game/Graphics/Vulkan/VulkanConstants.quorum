package Libraries.Game.Graphics.Vulkan

shared class VulkanConstants
    
    VulkanUtilities utilities
    
    // Constants representing common target Vulkan API versions. For other possible versions, see VulkanUtilities "ConvertToAPIVersionID" action.
    public constant integer API_VERSION_1_0_0 = utilities:ConvertToAPIVersionID(1, 0, 0)
    public constant integer API_VERSION_1_1_0 = utilities:ConvertToAPIVersionID(1, 1, 0)
    public constant integer DEFAULT_API_VERSION = API_VERSION_1_1_0

    // Values representing the engine information provided to Vulkan Instances when they're created under the hood.
    // These can be used to identify what engine is implementing Vulkan for hardware providers, such as driver manufacturers, if they choose to check.
    public constant text VULKAN_ENGINE_NAME = "Quorum"
    public constant integer VULKAN_ENGINE_VERSION = 1
    
    // Validation layer names. A platform might support some of these layers. If it does, it can use them for validation and error checking.
    public constant text KHRONOS_VALIDATION_LAYER = "VK_LAYER_KHRONOS_validation"
    public constant text LUNARG_STANDARD_VALIDATION_LAYER = "VK_LAYER_LUNARG_standard_validation"
    public constant text LUNARG_PARAMETER_VALIDATION_LAYER = "VK_LAYER_LUNARG_parameter_validation"
    public constant text LUNARG_OBJECT_TRACKER_VALIDATION_LAYER = "VK_LAYER_LUNARG_object_tracker"
    public constant text LUNARG_CORE_VALIDATION_LAYER = "VK_LAYER_LUNARG_core_validation"
    public constant text GOOGLE_THREADING_VALIDATION_LAYER = "VK_LAYER_GOOGLE_threading"
    public constant text GOOGLE_UNIQUE_OBJECTS_VALIDATION_LAYER = "VK_LAYER_GOOGLE_unique_objects"

    // Extension names. Used during the creation of VulkanInstances.
    public constant text DEBUG_UTILITIES_EXTENSION = "VK_EXT_debug_utils"
    public constant text MAC_PORTABILITY_EXTENSION = "VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME"
    public constant text MAC_PORTABILITY_SUBSET_EXTENSION = "VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME"
    
    // Flag bit values for defining the features of queue families. Needed while creating a physical device (to check which features it supports).
    public constant integer QUEUE_GRAPHICS_BIT = 1
    public constant integer QUEUE_COMPUTE_BIT = 2
    public constant integer QUEUE_TRANSFER_BIT = 4
    public constant integer QUEUE_SPARSE_BINDING_BIT = 8
    public constant integer QUEUE_PROTECTED_BIT = 16
    public constant integer QUEUE_VIDEO_DECODE_BIT = 32
    public constant integer QUEUE_VIDEO_ENCODE_BIT = 64
    public constant integer QUEUE_OPTICAL_FLOW_BIT = 256

    // An extension for devices and physical devices. Used to take graphics rendered to a swapchain and display them on the screen.
    public constant text SWAPCHAIN_EXTENSION = "VK_KHR_swapchain"

    // Constants representing types of physical devices. 
    public constant integer PHYSICAL_DEVICE_TYPE_OTHER = 0
    public constant integer PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1
    public constant integer PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2
    public constant integer PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3
    public constant integer PHYSICAL_DEVICE_TYPE_CPU = 4

    
    // Color formats. Used for Swapchain creation, among other things.
    public constant integer FORMAT_R8G8B8A8_SRGB = 43

    /*
    Constants for the color space, which describes the format the monitor expects colors in. This primarily comes in the form of SRGB or UNORM values.
    "UNORM" is normalized linear color space. Setting the value as UNORM means no transformation will be done. Monitors almost exclusively work in 
    the SRGB color space, though. This boils down to a concept known as "Gamma Correction." Using UNORM will typically result in aberrantly bright,
    uncorrected colors, so for most display applications, SRGB space is preferred.
    */
    public constant integer COLOR_SPACE_SRGB_NONLINEAR = 0

    // Constants used to describe how Vulkan Images will be used. These are bit flags, so they can be combined in a bitmask.
    public constant integer IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16

    // Constants used to describe how images in a swapchain can be shared across multiple swapchains.
    public constant integer SHARING_MODE_EXCLUSIVE = 0
    public constant integer SHARING_MODE_CONCURRENT = 1

    // Presentation modes for Swapchains. These control the timing of when rendered images are presented and how additional incoming images are stored.
    // These match the Vulkan present mode constants from Khronos. More info can be found here: https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html
    /*
    The FIFO (or First In, First Out) presentation mode will present the next available image when the monitor refreshes. This is the only mode required to be supported 
    by hardware according to the Vulkan spec. Because it aligns with the refresh rate of the monitor, the FIFO mode implies the use of vSync. Note that if the queue of 
    images is full, the application will block!
    */
    public constant integer PRESENT_MODE_FIFO = 2
    /*
    The Immediate presentation mode will display each image as soon as it's ready. This doesn't match the monitor refresh rate, so this can cause screen tearing. This
    mode implies vSync is off.
    */
    public constant integer PRESENT_MODE_IMMEDIATE = 0
    /*
    The Mailbox presentation mode is similar to FIFO in that it displays images during monitor refreshes, but unlike FIFO it will only queue 1 image at a time.
    If an image is already queued when a new one comes in, it'll overwrite the previous image in the queue, and no blocking occurs. This means Mailbox can provide
    vSync-like effects (display on monitor refresh and no screen tearing), but we don't have to block if the GPU is working faster than the display.
    */
    public constant integer PRESENT_MODE_MAILBOX = 1
    /*
    The FIFO Relaxed mode is an adjustment to the FIFO mode. Like FIFO, this mode stores images in a queue, which are presented during monitor refreshes. However, if
    a monitor refresh occurs and there's no available image, then the next image will be presented as soon as it becomes available. Essentially, this mode is FIFO that
    will try to play catch-up if it's needed -- FIFO if rendering is fast, and IMMEDIATE if it's slow.
    */
    public constant integer PRESENT_MODE_FIFO_RELAXED = 3

    /*
    Composite alpha values for the Swapchain dictate how transparency is calculated for the window. This does NOT impact transparency calculated inside the application,
    e.g. a sprite with transparency drawn on top of another sprite. Instead, a composite alpha value can be used to show things behind the window. For most applications,
    using the OPAQUE value is best, because it is the fastest option and we don't usually want to show the content behind the window.
    */
    public constant integer COMPOSITE_ALPHA_OPAQUE_BIT = 1

    /*
    Bitmask values used to indicate which aspects of an image are being accessed as part of an ImageView.
    */
    public constant integer IMAGE_ASPECT_COLOR_BIT = 1

    /*
    Type values for defining the structure and use of Images.
    */
    public constant integer VK_IMAGE_VIEW_TYPE_2D = 1
    
end