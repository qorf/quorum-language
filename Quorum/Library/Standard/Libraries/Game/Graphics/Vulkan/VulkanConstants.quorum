package Libraries.Game.Graphics.Vulkan

shared class VulkanConstants
    
    VulkanUtilities utilities
    
    // Constants representing common target Vulkan API versions. For other possible versions, see VulkanUtilities "ConvertToAPIVersionID" action.
    public constant integer API_VERSION_1_0_0 = utilities:ConvertToAPIVersionID(1, 0, 0)
    public constant integer API_VERSION_1_1_0 = utilities:ConvertToAPIVersionID(1, 1, 0)
    public constant integer DEFAULT_API_VERSION = API_VERSION_1_1_0

    // Values representing the engine information provided to Vulkan Instances when they're created under the hood.
    // These can be used to identify what engine is implementing Vulkan for hardware providers, such as driver manufacturers, if they choose to check.
    public constant text VULKAN_ENGINE_NAME = "Quorum"
    public constant integer VULKAN_ENGINE_VERSION = 1
    
    // Validation layer names. A platform might support some of these layers. If it does, it can use them for validation and error checking.
    public constant text KHRONOS_VALIDATION_LAYER = "VK_LAYER_KHRONOS_validation"
    public constant text LUNARG_STANDARD_VALIDATION_LAYER = "VK_LAYER_LUNARG_standard_validation"
    public constant text LUNARG_PARAMETER_VALIDATION_LAYER = "VK_LAYER_LUNARG_parameter_validation"
    public constant text LUNARG_OBJECT_TRACKER_VALIDATION_LAYER = "VK_LAYER_LUNARG_object_tracker"
    public constant text LUNARG_CORE_VALIDATION_LAYER = "VK_LAYER_LUNARG_core_validation"
    public constant text GOOGLE_THREADING_VALIDATION_LAYER = "VK_LAYER_GOOGLE_threading"
    public constant text GOOGLE_UNIQUE_OBJECTS_VALIDATION_LAYER = "VK_LAYER_GOOGLE_unique_objects"

    // Extension names. Used during the creation of VulkanInstances.
    public constant text DEBUG_UTILITIES_EXTENSION = "VK_EXT_debug_utils"
    public constant text MAC_PORTABILITY_EXTENSION = "VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME"
    public constant text MAC_PORTABILITY_SUBSET_EXTENSION = "VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME"
    
    // Flag bit values for defining the features of queue families. Needed while creating a physical device (to check which features it supports).
    public constant integer QUEUE_GRAPHICS_BIT = 1
    public constant integer QUEUE_COMPUTE_BIT = 2
    public constant integer QUEUE_TRANSFER_BIT = 4
    public constant integer QUEUE_SPARSE_BINDING_BIT = 8
    public constant integer QUEUE_PROTECTED_BIT = 16
    public constant integer QUEUE_VIDEO_DECODE_BIT = 32
    public constant integer QUEUE_VIDEO_ENCODE_BIT = 64
    public constant integer QUEUE_OPTICAL_FLOW_BIT = 256

    // An extension for devices and physical devices. Used to take graphics rendered to a swapchain and display them on the screen.
    public constant text SWAPCHAIN_EXTENSION = "VK_KHR_swapchain"

    // Constants representing types of physical devices. 
    public constant integer PHYSICAL_DEVICE_TYPE_OTHER = 0
    public constant integer PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1
    public constant integer PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2
    public constant integer PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3
    public constant integer PHYSICAL_DEVICE_TYPE_CPU = 4

    
    // Color formats. Used for Swapchain creation, among other things.
    public constant integer FORMAT_R8G8B8A8_SRGB = 43
    public constant integer FORMAT_B8G8R8A8_SRGB = 50

    /*
    Constants for the color space, which describes the format the monitor expects colors in. This primarily comes in the form of SRGB or UNORM values.
    "UNORM" is normalized linear color space. Setting the value as UNORM means no transformation will be done. Monitors almost exclusively work in 
    the SRGB color space, though. This boils down to a concept known as "Gamma Correction." Using UNORM will typically result in aberrantly bright,
    uncorrected colors, so for most display applications, SRGB space is preferred.
    */
    public constant integer COLOR_SPACE_SRGB_NONLINEAR = 0

    // Constants used to describe how Vulkan Images will be used. These are bit flags, so they can be combined in a bitmask.
    public constant integer IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16

    // Constants used to describe whether or not resources can be accessed simultaneously by multiple queue families or swapchains.
    public constant integer SHARING_MODE_EXCLUSIVE = 0
    public constant integer SHARING_MODE_CONCURRENT = 1

    // Presentation modes for Swapchains. These control the timing of when rendered images are presented and how additional incoming images are stored.
    // These match the Vulkan present mode constants from Khronos. More info can be found here: https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html
    /*
    The FIFO (or First In, First Out) presentation mode will present the next available image when the monitor refreshes. This is the only mode required to be supported 
    by hardware according to the Vulkan spec. Because it aligns with the refresh rate of the monitor, the FIFO mode implies the use of vSync. Note that if the queue of 
    images is full, the application will block!
    */
    public constant integer PRESENT_MODE_FIFO = 2
    /*
    The Immediate presentation mode will display each image as soon as it's ready. This doesn't match the monitor refresh rate, so this can cause screen tearing. This
    mode implies vSync is off.
    */
    public constant integer PRESENT_MODE_IMMEDIATE = 0
    /*
    The Mailbox presentation mode is similar to FIFO in that it displays images during monitor refreshes, but unlike FIFO it will only queue 1 image at a time.
    If an image is already queued when a new one comes in, it'll overwrite the previous image in the queue, and no blocking occurs. This means Mailbox can provide
    vSync-like effects (display on monitor refresh and no screen tearing), but we don't have to block if the GPU is working faster than the display.
    */
    public constant integer PRESENT_MODE_MAILBOX = 1
    /*
    The FIFO Relaxed mode is an adjustment to the FIFO mode. Like FIFO, this mode stores images in a queue, which are presented during monitor refreshes. However, if
    a monitor refresh occurs and there's no available image, then the next image will be presented as soon as it becomes available. Essentially, this mode is FIFO that
    will try to play catch-up if it's needed -- FIFO if rendering is fast, and IMMEDIATE if it's slow.
    */
    public constant integer PRESENT_MODE_FIFO_RELAXED = 3

    /*
    Composite alpha values for the Swapchain dictate how transparency is calculated for the window. This does NOT impact transparency calculated inside the application,
    e.g. a sprite with transparency drawn on top of another sprite. Instead, a composite alpha value can be used to show things behind the window. For most applications,
    using the OPAQUE value is best, because it is the fastest option and we don't usually want to show the content behind the window.
    */
    public constant integer COMPOSITE_ALPHA_OPAQUE_BIT = 1

    /*
    Bitmask values used to indicate which aspects of an image are being accessed as part of an ImageView.
    */
    public constant integer IMAGE_ASPECT_COLOR_BIT = 1

    /*
    Type values for defining the structure and use of Images.
    */
    public constant integer IMAGE_VIEW_TYPE_2D = 1

    /*
    Flags used during the creation of Command Pools.
    */
    public constant integer COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 2

    /*
    Sampling flags, used when defining color attachments, and also used for the Rasterization Sampling value of
    VulkanPipelineInfo. 1 bit of sampling is the most direct and simple way to sample color.
    Multiple bits are used for multisampling, which is typically used to perform anti-aliasing. 
    */
    public constant integer SAMPLE_COUNT_1_BIT = 1
    public constant integer SAMPLE_COUNT_2_BIT = 2
    public constant integer SAMPLE_COUNT_4_BIT = 4
    public constant integer SAMPLE_COUNT_8_BIT = 8
    public constant integer SAMPLE_COUNT_16_BIT = 16
    public constant integer SAMPLE_COUNT_32_BIT = 32
    public constant integer SAMPLE_COUNT_64_BIT = 64

    /*
    Constants for load and store operations for attachments. Load operations indicate what operations, if any, should be performed on the data in an attachment when it's loaded
    (i.e. first time using the attachment during a pass). Store operations indicate what operations should be done on the data once the pass is finished with the attachment.
    */
    public constant integer ATTACHMENT_STORE_OP_STORE = 0
    public constant integer ATTACHMENT_STORE_OP_DONT_CARE = 1
    public constant integer ATTACHMENT_LOAD_OP_LOAD = 0
    public constant integer ATTACHMENT_LOAD_OP_CLEAR = 1
    public constant integer ATTACHMENT_LOAD_OP_DONT_CARE = 2
    
    /*
    Constants representing image layouts. These describe the format of stored image data. 
    */
    public constant integer IMAGE_LAYOUT_UNDEFINED = 0
    public constant integer IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2
    public constant integer IMAGE_LAYOUT_PRESENT_SRC = 1000001002

    /*
    Constants used to bind to pipeline stages.
    */
    public constant integer PIPELINE_BIND_POINT_GRAPHICS = 0

    /*
    A constant value indicating that part of a subpass occurs outside of the regular Vulkan pipeline, such as work with the swapchain
    (because presentation occurs outside of the regular pipeline).
    */
    public constant integer SUBPASS_EXTERNAL = -1

    /*
    Bitmask constants for pipeline stages. Used in subpass dependencies to indicate what stages work begins and finishes in.
    */
    public constant integer PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1024

    /*
    Bitmask constants for access masks. Used for subpass dependencies.
    */
    public constant integer ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 256

    /*
    Constants used for the Input Rate value of VulkanVertexInputBindingDescription. These indicate that values are provided
    either per-vertex or per-instance while using a particular Pipeline.
    */
    public constant integer VERTEX_INPUT_RATE_VERTEX = 0
    public constant integer VERTEX_INPUT_RATE_INSTANCE = 1

    /*
    Constants for the Topology value of VulkanPipelineInfo. These represent different ways for vertices
    to be combined together into geometry.
    */
    public constant integer PRIMITIVE_TOPOLOGY_POINT_LIST = 0
    public constant integer PRIMITIVE_TOPOLOGY_LINE_LIST = 1
    public constant integer PRIMITIVE_TOPOLOGY_LINE_STRIP = 2
    public constant integer PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3
    public constant integer PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4
    public constant integer PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5
    public constant integer PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6
    public constant integer PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7
    public constant integer PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8
    public constant integer PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9
    public constant integer PRIMITIVE_TOPOLOGY_PATCH_LIST = 10

    /*
    Constants for the Polygon Mode value of VulkanPipelineInfo. These describe how polygons should be filled in,
    sketched, or otherwise rendered.
    */
    public constant integer POLYGON_MODE_FILL = 0
    public constant integer POLYGON_MODE_LINE = 1
    public constant integer POLYGON_MODE_POINT = 2
    public constant integer POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000

    /*
    Constants used for the Cull Mode value of VulkanPipelineInfo. These describe which polygons are culled during
    rendering based on their orientation, or in other words, which side(s) of a rendered model should be ignored.
    */
    public constant integer CULL_MODE_NONE = 0
    public constant integer CULL_MODE_FRONT_BIT = 1
    public constant integer CULL_MODE_BACK_BIT = 2
    public constant integer CULL_MODE_FRONT_AND_BACK = 3

    /*
    Constants used for the Front Face value of VulkanPipelineInfo. These are used to determine which way a polygon
    is facing, based on the order of the provided vertices, and which way they rotate about their center point.
    */
    public constant integer FRONT_FACE_COUNTER_CLOCKWISE = 0
    public constant integer FRONT_FACE_CLOCKWISE = 1

    /*
    Constants for color components.
    */
    public constant integer COLOR_COMPONENT_R_BIT = 1
    public constant integer COLOR_COMPONENT_G_BIT = 2
    public constant integer COLOR_COMPONENT_B_BIT = 4
    public constant integer COLOR_COMPONENT_A_BIT = 8

    /*
    Constants representing Shader stages. These are different the shader type values in the ShaderConstants, but they can be
    converted to and from using VulkanUtilities' "ShaderTypeToVulkanShaderStage" and "VulkanShaderStageToShaderType" actions.
    */
    public constant integer SHADER_STAGE_VERTEX_BIT = 1
    public constant integer SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2
    public constant integer SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4
    public constant integer SHADER_STAGE_GEOMETRY_BIT = 8
    public constant integer SHADER_STAGE_FRAGMENT_BIT = 16
    public constant integer SHADER_STAGE_COMPUTE_BIT = 32
    public constant integer SHADER_STAGE_ALL_GRAPHICS = 31
    public constant integer SHADER_STAGE_ALL = 2147483647

    /*
    These constants are used to indicate the "level" of a command buffer. Buffers can be either primary or secondary buffers.
    According to the Vulkan documentation, primary command buffers can execute secondary command buffers and are submitted to queues,
    while secondary command buffers can be executed by primary command buffers and are not directly submitted to queues.
    */
    public constant integer COMMAND_BUFFER_LEVEL_PRIMARY = 0
    public constant integer COMMAND_BUFFER_LEVEL_SECONDARY = 1

    /*
    Values indicating how a command buffer will be used.
    */
    public constant integer COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1
    public constant integer COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 2
    public constant integer COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 4

    /*
    Memory property bits, used when allocating memory (e.g. for VulkanBuffers).
    */
    public constant integer MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1
    public constant integer MEMORY_PROPERTY_HOST_VISIBLE_BIT = 2
    public constant integer MEMORY_PROPERTY_HOST_COHERENT_BIT = 4
    public constant integer MEMORY_PROPERTY_HOST_CACHED_BIT = 8
    public constant integer MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 16
    public constant integer MEMORY_PROPERTY_PROTECTED_BIT = 32
    public constant integer MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 64
    public constant integer MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 128
    public constant integer MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 256

    /*
    These constants indicate how VulkanBuffers are intended to be used. These can be combined with BitwiseOperations and sent
    as the "usageFlags" parameter when using VulkanBuffer's Create action.
    */    
    public constant integer BUFFER_USAGE_TRANSFER_SRC_BIT = 1
    public constant integer BUFFER_USAGE_TRANSFER_DST_BIT = 2
    public constant integer BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 4
    public constant integer BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 8
    public constant integer BUFFER_USAGE_UNIFORM_BUFFER_BIT = 16
    public constant integer BUFFER_USAGE_STORAGE_BUFFER_BIT = 32
    public constant integer BUFFER_USAGE_INDEX_BUFFER_BIT = 64
    public constant integer BUFFER_USAGE_VERTEX_BUFFER_BIT = 128
    public constant integer BUFFER_USAGE_INDIRECT_BUFFER_BIT = 256
    public constant integer BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 131072
    public constant integer BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 8192
    public constant integer BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 16384
    public constant integer BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 2048
    public constant integer BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 4096
    public constant integer BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 512
    public constant integer BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = 33554432
    public constant integer BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 524288
    public constant integer BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 1048576
    public constant integer BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 1024
    public constant integer BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 32768
    public constant integer BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 65536
    public constant integer BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 2097152
    public constant integer BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 4194304
    public constant integer BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 67108864
    public constant integer BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 8388608
    public constant integer BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 16777216
    public constant integer BUFFER_USAGE_RAY_TRACING_BIT_NV = BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR
    public constant integer BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
    public constant integer BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
    
    /*
    These constants represent how commands will be submitted to a VulkanCommandBuffer during a render pass.
    */
    public constant integer SUBPASS_CONTENTS_INLINE = 0
    public constant integer SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1
    public constant integer SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS = 1000451000

end