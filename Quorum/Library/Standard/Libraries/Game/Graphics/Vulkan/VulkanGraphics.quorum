package Libraries.Game.Graphics.Vulkan

use Libraries.Game.Graphics.GraphicsManager
use Libraries.Containers.Number32BitArray
use Libraries.Game.Graphics.Vulkan.Commands.all
use Libraries.Game.Graphics.Shaders.ShaderProgram
use Libraries.Game.GameStateManager
use Libraries.Game.DesktopApplication
use Libraries.Game.DesktopDisplay
use Libraries.Compute.BitwiseOperations
use Libraries.Containers.Array

class VulkanGraphics is GraphicsManager
    
    VulkanInstance instance = undefined
    VulkanPhysicalDevice physicalDevice = undefined
    VulkanDevice device = undefined
    VulkanSurface surface = undefined
    VulkanQueue graphicsQueue = undefined
    VulkanQueue presentationQueue = undefined
    VulkanSwapchain swapchain = undefined
    VulkanCommandPool commandPool = undefined
    VulkanRenderPass renderPass = undefined

    // Resources used to control rendering for each of the images of the swapchain.
    Array<VulkanCommandBuffer> renderCommandBuffers
    Array<VulkanFence> renderFences
    Array<VulkanFramebuffer> swapchainFramebuffers

    // Resources used for managing the timing of image usage from the swapchain.
    Array<VulkanSemaphore> imageAcquiredSemaphores
    Array<VulkanSemaphore> imageRenderCompleteSemaphores

    // Values used to indicate the current resources for the current frame of animation.
    integer currentSwapchainIndex = -1
    VulkanCommandBuffer currentRenderCommandBuffer = undefined
    VulkanFence currentRenderFence = undefined
    VulkanFramebuffer currentFramebuffer
    
    // The clear color, or in otherwords, the background color of the screen.
    VulkanClearValue clearValue

    on create
//        clearValue:SetColor(0.85, 0.85, 0.85, 1.0)
        clearValue:SetColor(0.85, 1.0, 0.85, 1.0)
    end
    
    /*
    This action constructs the necessary Vulkan resources to render using this VulkanGraphics. This will also create and setup the GameDisplay for the Game class,
    if there isn't already one setup, because access to the screen is needed for full VulkanGraphics setup.
    */
    action Initialize(VulkanOptions options) returns boolean
        VulkanInstance instance
        me:instance = instance
        
        instance:SetLogger(options:logger)
        boolean success = instance:CreateGraphicsInstance(options:applicationName, options:applicationVersion, options:apiVersion, options:useValidationLayers)

        output "Instance created, success = " + success
        if not success
            return false
        end

        VulkanPhysicalDevice physicalDevice
        me:physicalDevice = physicalDevice
        
        success = physicalDevice:CreateGraphicsDevice(instance)

        output "Physical device created, success = " + success
        if not success
            return false
        end

        VulkanDevice device
        me:device = device

        success = device:CreateGraphicsDevice(physicalDevice)

        output "Device created, success = " + success
        if not success
            return false
        end

        // Create a DesktopDisplay initialized for use with Vulkan, if we don't have one already.
        GameStateManager manager
        if manager:GetApplication() is DesktopApplication and manager:GetGameDisplay() = undefined
            DesktopDisplay display
            manager:SetGameDisplay(display)
            display:SetConfiguration(manager:GetGame():GetDesktopConfiguration())
            success = display:SetupDisplay(true)

            output "Created Vulkan Display, success = " + success
            if not success
                return false
            end
        else
            output "Display was already defined: " + (manager:GetGameDisplay() not= undefined)
        end

        VulkanSurface surface
        me:surface = surface
        success = surface:Create(instance, manager:GetGameDisplay())
       
        output "Created Vulkan Surface, success = " + success
        if not success
            return false
        end

        // Create the graphics queue. We need to check the device's queue families to see which one will do the work we want.
        // We'll need to compare against a bitmask for this.
        BitwiseOperations bits
        VulkanConstants constants

        integer i = 0
        repeat while i < device:GetQueueFamilyCount()
            VulkanQueueFamily family = device:GetQueueFamily(i)
            if bits:And(family:GetQueueFlags(), constants:QUEUE_GRAPHICS_BIT) not= 0
                VulkanQueue queue
                graphicsQueue = queue
                output "Selected queue " + i + " with flags = " + family:GetQueueFlags() + ", creating graphics queue..."
                // Create the queue using the device, the queue family, and indicate the first (or zero-th) queue in the family
                queue:Create(device, family, 0)
                i = device:GetQueueFamilyCount()
            end

            i = i + 1
        end

        output "Made graphics queue, success = " + (graphicsQueue not= undefined)
        if graphicsQueue = undefined
            return false
        end

        i = 0
        repeat while i < device:GetQueueFamilyCount()
            VulkanQueueFamily family = device:GetQueueFamily(i)
            if family:CanPresentToSurface(surface)
                // If the graphics queue we already have can also support presentation, use the same queue for both.
                if graphicsQueue:GetQueueFamily():GetQueueFamilyIndex() = i
                    output "Using already selected graphics queue at " + i + " for presentation."
                    presentationQueue = graphicsQueue
                else
                    VulkanQueue queue
                    presentationQueue = queue
                    output "Selected queue " + i + " with flags = " + family:GetQueueFlags() + ", creating presentation queue..."
                    // Create the queue using the device, the queue family, and indicate the first (or zero-th) queue in the family
                    queue:Create(device, family, 0)
                end
                i = device:GetQueueFamilyCount()
            end
            i = i + 1
        end

        output "Made presentation queue, success = " + (presentationQueue not= undefined)
        if presentationQueue = undefined
            return false
        end

        output "Creating Swapchain..."
        VulkanSwapchain swapchain
        me:swapchain = swapchain

        VulkanSwapchainInfo swapchainInfo = options:swapchainInfo
        if graphicsQueue not= presentationQueue
            Array<integer> queueFamilyIndices
            queueFamilyIndices:Add(graphicsQueue:GetQueueFamily():GetQueueFamilyIndex())
            queueFamilyIndices:Add(presentationQueue:GetQueueFamily():GetQueueFamilyIndex())
            swapchainInfo:SetQueueFamilyIndices(queueFamilyIndices)
        end

        success = swapchain:Create(device, surface, swapchainInfo)
        output "Made swapchain, success = " + success
        if not success
            return false
        end

        VulkanCommandPool commandPool
        me:commandPool = commandPool

        output "Creating command pool..."
        success = commandPool:Create(device, constants:COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT, graphicsQueue:GetQueueFamily():GetQueueFamilyIndex())
        output "Created command pool, success = " + success
        if not success
            return false
        end

        /*
        Create the RenderPass that will be used for the Framebuffers and Pipeline. This work will likely be moved into a Painter later.
        The RenderPass provided to the Framebuffers will indicate how rendering to the buffers will be performed. Pipelines using the
        Framebuffers must either exactly match the RenderPass, or be compatible with it. More details here:
        https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap8.html#renderpass-compatibility
        */
        VulkanAttachmentDescription outputColorAttachment
        outputColorAttachment:SetFormat(swapchainInfo:GetImageViewInfo():GetFormat())
        outputColorAttachment:SetSamples(constants:SAMPLE_COUNT_1_BIT)
        outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_CLEAR)
        outputColorAttachment:SetStoreOp(constants:ATTACHMENT_STORE_OP_STORE)
        outputColorAttachment:SetInitialLayout(constants:IMAGE_LAYOUT_UNDEFINED)
        outputColorAttachment:SetFinalLayout(constants:IMAGE_LAYOUT_PRESENT_SRC)

        Array<VulkanAttachmentDescription> attachmentDescriptions
        attachmentDescriptions:Add(outputColorAttachment)


        VulkanAttachmentReference outputColorReference
        outputColorReference:SetAttachmentIndex(0)
        outputColorReference:SetLayout(constants:IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)

        Array<VulkanAttachmentReference> attachmentReferences
        attachmentReferences:Add(outputColorReference)


        VulkanSubpassDescription subpass
        subpass:SetPipelineBindPoint(constants:PIPELINE_BIND_POINT_GRAPHICS)
        subpass:SetColorAttachments(attachmentReferences)

        Array<VulkanSubpassDescription> subpassDescriptions
        subpassDescriptions:Add(subpass)

        
        VulkanSubpassDependency dependency
        dependency:SetSourceSubpass(constants:SUBPASS_EXTERNAL)
        dependency:SetDestinationSubpass(0)
        dependency:SetSourceStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetDestinationStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetSourceAccessMask(0)
        dependency:SetDestinationAccessMask(constants:ACCESS_COLOR_ATTACHMENT_WRITE_BIT)

        Array<VulkanSubpassDependency> subpassDependencies
        subpassDependencies:Add(dependency)


        output "Creating RenderPass..."
        VulkanRenderPass renderPass
        me:renderPass = renderPass
        success = renderPass:Create(device, attachmentDescriptions, subpassDescriptions, subpassDependencies)
        output "Created RenderPass, success = " + success
        if not success
            return false
        end


        output "Creating FrameBuffers..."
        Array<VulkanFramebuffer> swapchainFramebuffers
        me:swapchainFramebuffers = swapchainFramebuffers
        i = 0
        repeat while i < swapchain:GetImageCount()
            VulkanImageView imageView = swapchain:GetImageView(i)
            Array<VulkanImageView> imageViewArray
            imageViewArray:Add(imageView)

            VulkanFramebuffer framebuffer
            success = framebuffer:Create(device, imageViewArray, renderPass)
            if not success
                output "Failed to create framebuffer!"
                return false
            end

            swapchainFramebuffers:Add(framebuffer)
            i = i + 1
        end
        output "Created FrameBuffers, success = " + success


        output "Creating render command buffers, semaphores, and fences..."
        i = 0
        repeat while i < swapchain:GetImageCount()
            VulkanCommandBuffer renderCommandBuffer
            success = renderCommandBuffer:Create(device, commandPool)
            if not success
                output "Failed to create render command buffer!"
                return false
            end
            renderCommandBuffers:Add(renderCommandBuffer)
            
            VulkanFence renderFence
            success = renderFence:Create(device, true)
            if not success
                output "Failed to create render fence!"
                return false
            end
            renderFences:Add(renderFence)

            VulkanSemaphore imageAcquiredSemaphore
            success = imageAcquiredSemaphore:Create(device)
            if not success
                return false
            end
            imageAcquiredSemaphores:Add(imageAcquiredSemaphore)
            
            VulkanSemaphore imageRenderCompleteSemaphore
            success = imageRenderCompleteSemaphore:Create(device)
            if not success
                output "Failed to create image rendering semaphore!"
                return false
            end
            imageRenderCompleteSemaphores:Add(imageRenderCompleteSemaphore)

            i = i + 1
        end

        output "Successfully created VulkanGraphics!"
        return true
    end

    /*
    This action gets the next image in the swapchain for use in the next frame of animation, clears
    the image, and prepares the frame's related resources (e.g. CommandBuffers and Fences).
    */
    action BeginNextFrame
        currentSwapchainIndex = (currentSwapchainIndex + 1) mod swapchain:GetImageCount()
        currentRenderCommandBuffer = renderCommandBuffers:Get(currentSwapchainIndex)
        currentRenderFence = renderFences:Get(currentSwapchainIndex)     
        currentFramebuffer = swapchainFramebuffers:Get(currentSwapchainIndex)   

        // Ensure that all work associated with this image has previously finished.
        currentRenderFence:Wait()

        // Make sure the next image in the swapchain is valid. Window resizing in particular can make the swapchain "out of date", in which case we'll need to regenerate it.
        if PrepareNextSwapchainImage(device, swapchain, imageAcquiredSemaphores:Get(currentSwapchainIndex)) = false
            RegenerateSwapchain()
        end

        // Reset the fence associated with this frame.
        currentRenderFence:Reset()

        // Reset the render command buffer. In this case, we'll instruct the command buffer not to release memory (it might reuse it, depending on local implementation, or just ditch it anyway)
        currentRenderCommandBuffer:Reset()


        // Ensure the screen clearing value is ready for use.
        if clearValue:IsDirty()
            clearValue:ResetDirtyFlag()
        end

        
        // Begin recording commands for our chosen command buffer.
        currentRenderCommandBuffer:BeginRecording()


        // Create the command to begin the render pass.
        BeginRenderPassCommand beginRenderPass
        beginRenderPass:SetRenderPass(renderPass)
        beginRenderPass:SetClearValue(clearValue)
        beginRenderPass:SetFramebuffer(currentFramebuffer)
        beginRenderPass:SetRenderArea(swapchain:GetImageWidth(), swapchain:GetImageHeight())
        currentRenderCommandBuffer:Record(beginRenderPass)

        // NEXT STEP: Bind pipeline command
//        BindPipelineCommand bindPipeline
//        bindPipeline:SetPipeline(pipeline)

        // Set viewport command
        // Setting the position to the height and the height to the negated height flips the Y axis of our viewport.
        SetViewportCommand setViewport
        setViewport:SetPosition(0, swapchain:GetImageHeight())
        setViewport:SetSize(swapchain:GetImageWidth(), -swapchain:GetImageHeight())
        currentRenderCommandBuffer:Record(setViewport)

        // Set scissor command
        SetScissorCommand setScissor
        setScissor:SetPosition(0, 0)
        setScissor:SetSize(swapchain:GetImageWidth(), swapchain:GetImageHeight())
        currentRenderCommandBuffer:Record(setScissor)

        // End the render pass.
        EndRenderPassCommand endRenderPass
        currentRenderCommandBuffer:Record(endRenderPass)

        // Stop recording commands.
        currentRenderCommandBuffer:EndRecording()


        // TO-DO: Recreating these arrays every frame is going to be an issue. Consider reusing them or making a pool for the SubmitInfo.
        VulkanSubmitInfo submitInfo
        Array<VulkanCommandBuffer> commandBuffers
        Array<VulkanSemaphore> signalSemaphores
        Array<VulkanSemaphore> waitSemaphores
        Array<integer> waitDestinationStageMasks

        VulkanConstants constants
        commandBuffers:Add(currentRenderCommandBuffer)
        signalSemaphores:Add(imageRenderCompleteSemaphores:Get(currentSwapchainIndex))
        waitSemaphores:Add(imageAcquiredSemaphores:Get(currentSwapchainIndex))
        waitDestinationStageMasks:Add(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        
        submitInfo:SetCommandBuffers(commandBuffers)
        submitInfo:SetSignalSemaphores(signalSemaphores)
        submitInfo:SetWaitSemaphores(waitSemaphores)
        submitInfo:SetWaitDestinationStageMasks(waitDestinationStageMasks)
        submitInfo:SetFence(currentRenderFence)

        graphicsQueue:SubmitCommands(submitInfo)

        // This will need to move in the future, but this can be here while testing initial screen clearing.
    end

    private system action PrepareNextSwapchainImage(VulkanDevice device, VulkanSwapchain swapchain, VulkanSemaphore semaphore) returns boolean

    action DisplayCurrentImage
        DisplayCurrentImageNative(presentationQueue, swapchain, imageRenderCompleteSemaphores:Get(currentSwapchainIndex), currentSwapchainIndex)
    end

    private system action DisplayCurrentImageNative(VulkanQueue presentQueue, VulkanSwapchain swapchain, VulkanSemaphore waitSemaphore, integer imageIndex) returns boolean

    private action RegenerateSwapchain
        alert("NYI")
    end
    
    /*
    This action sets the background color of the window. This is the color used to clear
    the screen between each frame of animation. 

    Attribute: Parameter red The red component of the color, as a number between 0.0 (no red) and 1.0 (full red).
    Attribute: Parameter green The green component of the color, as a number between 0.0 (no green) and 1.0 (full green).
    Attribute: Parameter blue The blue component of the color, as a number between 0.0 (no blue) and 1.0 (full blue).
    */
    action SetClearScreenColor(number red, number green, number blue)
        clearValue:SetColor(red, green, blue)
    end

    /*
    This action sets the background color of the window. This is the color used to clear
    the screen between each frame of animation. The alpha component (transparency) isn't 
    supported for OpenGL rendering, but Vulkan rendering can draw a transparent window 
    background if the feature is enabled.

    Attribute: Parameter red The red component of the color, as a number between 0.0 (no red) and 1.0 (full red).
    Attribute: Parameter green The green component of the color, as a number between 0.0 (no green) and 1.0 (full green).
    Attribute: Parameter blue The blue component of the color, as a number between 0.0 (no blue) and 1.0 (full blue).
    Attribute: Parameter alpha The alpha component of the color, as a number between 0.0 (completely transparent) and 1.0 (completely opaque).
    */
    action SetClearScreenColor(number red, number green, number blue, number alpha)
        clearValue:SetColor(red, green, blue, alpha)
    end
    
    /*
    This action returns the maximum number of textures that can be supported on the system. This number depends
    on the local hardware being used.
    */
    action GetMaximumTextureCount returns integer
        alert("NYI")
        return -1
    end
    
    /*
    This action makes a new shader of the requested type (e.g., FRAGMENT_SHADER or VERTEX_SHADER from the Shader class)
    using the given source code. If the shader code successfully compiles, this action will return an integer ID
    representing that shader. If the shader can't be created or it does not successfully compile, this will alert an error.
    */
    action CreateShader(integer shaderType, text sourceCode, text shaderName) returns integer
        alert("NYI")
        return -1
    end
    
    /*
    This action instructs the rendering system to delete the native resources allocated to a shader. After deleting
    a shader, it can't be used by the rendering system unless it's recompiled.
    */
    action DeleteShader(integer shaderID)
        alert("NYI")
    end
    
    /*
    */
    action CreateShaderProgram(ShaderProgram program) returns integer
        alert("NYI")
    end

    /*
    This action tells the graphics system to render content using the shader program indicated by the provided ID.
    */
    action UseShaderProgram(integer programID)
        alert("NYI")
    end

    /*
    This action instructs the rendering system to delete the native resources allocated to a shader program. After deleting
    a shader program, it can't be used by the rendering system unless it's reloaded. Deleting a program doesn't automatically
    delete the shaders attached to it -- those must also be deleted manually.
    */
    action DeleteShaderProgram(integer programID)
        alert("NYI")
    end
    
    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, integer value)
        alert("NYI")
    end
    
    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, integer value1, integer value2)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, integer value1, integer value2, integer value3)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, integer value1, integer value2, integer value3, integer value4)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, number value)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, number value1, number value2)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, number value1, number value2, number value3)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, number value1, number value2, number value3, number value4)
        alert("NYI")
    end
    
    /*
    This action sets the values of a shader "uniform" array variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. 

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter length How many elements should be copied from the input array to the uniform array.
    */
    action SetShaderInputArray(integer uniformID, Number32BitArray array, integer startIndex, integer length)
        alert("NYI")
    end

    /*
    This action sets the values of an array of Vector2's in a shader "uniform" array variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. 

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter length How many elements should be copied from the input array to the uniform array.
    */
    action SetShaderInputVector2Array(integer uniformID, Number32BitArray array, integer startIndex, integer length)
        alert("NYI")
    end

    /*
    This action sets the values of an array of Vector3's in a shader "uniform" array variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. 

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter length How many elements should be copied from the input array to the uniform array.
    */
    action SetShaderInputVector3Array(integer uniformID, Number32BitArray array, integer startIndex, integer length)
        alert("NYI")
    end

    /*
    This action sets the values of an array of Vector4's in a shader "uniform" array variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. 

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter length How many elements should be copied from the input array to the uniform array.
    */
    action SetShaderInputVector4Array(integer uniformID, Number32BitArray array, integer startIndex, integer length)
        alert("NYI")
    end

    /*
    This action sets the value of an array of Matrix4's in a shader "uniform" variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. The array is assumed to provide
    the matrix in column-major order, unless the transpose flag is set to true, in which case it will be assumed to be
    row-major instead.

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter matrixCount How many matrices should be set in the uniform. Each matrix requires 16 sequential values from the source array.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter transpose If set to true, the uniform will be set to the transpose of the Matrix.
    */
    action SetShaderInputMatrix4Array(integer uniformID, integer matrixCount, Number32BitArray array, integer startIndex, boolean transpose)
        alert("NYI")
    end

    /*
    This action sets the value of an array of Matrix3's in a shader "uniform" variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. The array is assumed to provide
    the matrix in column-major order, unless the transpose flag is set to true, in which case it will be assumed to be
    row-major instead.

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter matrixCount How many matrices should be set in the uniform. Each matrix requires 9 sequential values from the source array.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter transpose If set to true, the uniform will be set to the transpose of the Matrix.
    */
    action SetShaderInputMatrix3Array(integer uniformID, integer matrixCount, Number32BitArray array, integer startIndex, boolean transpose)
        alert("NYI")
    end

    /*
    This action informs the rendering system of how to interpret elements of vertex input data for a particular input.

    Attribute: Parameter inputID An ID that describes a vertex input.
    Attribute: Parameter size How many bytes from the array are needed to set a single instance of the input value in the shader. Must be between 1 and 4.
    Attribute: Parameter type A constant value representing the type of data, such as GL_INT.
    Attribute: Parameter normalize If set to true, fixed-point data values will be normalized when passed down to the system. If set to false, the values will be passed down without modification.
    Attribute: Parameter stride How many bytes of data separate each instance of data meant to be used for this input. If this value is 0, it's assumed that there is no additional data interleaved between data used for this input.
    Attribute: Parameter offset The index of the first element of this input's data in the input buffer, or in other words, how many bytes of data appear before the first instance of input data for this input.
    */
    action SetVertexInputInformation(integer inputID, integer size, integer type, boolean normalize, integer stride, integer offset)
        alert("NYI")
    end

    action GetSurface returns VulkanSurface
        return surface
    end

    action GetInstance returns VulkanInstance
        return instance
    end

    action GetPhysicalDevice returns VulkanPhysicalDevice
        return physicalDevice
    end

    action GetDevice returns VulkanDevice
        return device
    end

    action GetGraphicsQueue returns VulkanQueue
        return graphicsQueue
    end

    action GetPresentationQueue returns VulkanQueue
        return presentationQueue
    end

    action GetSwapchain returns VulkanSwapchain
        return swapchain
    end

    action GetCommandPool returns VulkanCommandPool
        return commandPool
    end

end