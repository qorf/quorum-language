package Libraries.Game.Graphics.Vulkan

use Libraries.Game.Graphics.GraphicsManager
use Libraries.Containers.Number32BitArray
use Libraries.Game.Graphics.Shaders.ShaderProgram
use Libraries.Game.GameStateManager
use Libraries.Game.DesktopApplication
use Libraries.Game.DesktopDisplay
use Libraries.Compute.BitwiseOperations
use Libraries.Containers.Array

class VulkanGraphics is GraphicsManager
    
    VulkanInstance instance = undefined
    VulkanPhysicalDevice physicalDevice = undefined
    VulkanDevice device = undefined
    VulkanSurface surface = undefined
    VulkanQueue graphicsQueue = undefined
    VulkanQueue presentationQueue = undefined
    VulkanSwapchain swapchain = undefined
    VulkanCommandPool commandPool = undefined
    
    // Color components used to clear the screen when a frame of animation begins.
    number redClearComponent = 0.85
    number greenClearComponent = 0.85
    number blueClearComponent = 0.85
    number alphaClearComponent = 1.0
    
    /*
    This action constructs the necessary Vulkan resources to render using this VulkanGraphics. This will also create and setup the GameDisplay for the Game class,
    if there isn't already one setup, because access to the screen is needed for full VulkanGraphics setup.
    */
    action Initialize(VulkanOptions options) returns boolean
        VulkanInstance instance
        me:instance = instance
        
        instance:SetLogger(options:logger)
        boolean success = instance:CreateGraphicsInstance(options:applicationName, options:applicationVersion, options:apiVersion, options:useValidationLayers)

        output "Instance created, success = " + success
        if not success
            return false
        end

        VulkanPhysicalDevice physicalDevice
        me:physicalDevice = physicalDevice
        
        success = physicalDevice:CreateGraphicsDevice(instance)

        output "Physical device created, success = " + success
        if not success
            return false
        end

        VulkanDevice device
        me:device = device

        success = device:CreateGraphicsDevice(physicalDevice)

        output "Device created, success = " + success
        if not success
            return false
        end

        // Create a DesktopDisplay initialized for use with Vulkan, if we don't have one already.
        GameStateManager manager
        if manager:GetApplication() is DesktopApplication and manager:GetGameDisplay() = undefined
            DesktopDisplay display
            manager:SetGameDisplay(display)
            display:SetConfiguration(manager:GetGame():GetDesktopConfiguration())
            success = display:SetupDisplay(true)

            output "Created Vulkan Display, success = " + success
            if not success
                return false
            end
        else
            output "Display was already defined: " + (manager:GetGameDisplay() not= undefined)
        end

        VulkanSurface surface
        me:surface = surface
        success = surface:Create(instance, manager:GetGameDisplay())
       
        output "Created Vulkan Surface, success = " + success
        if not success
            return false
        end

        // Create the graphics queue. We need to check the device's queue families to see which one will do the work we want.
        // We'll need to compare against a bitmask for this.
        BitwiseOperations bits
        VulkanConstants constants

        integer i = 0
        repeat while i < device:GetQueueFamilyCount()
            VulkanQueueFamily family = device:GetQueueFamily(i)
            if bits:And(family:GetQueueFlags(), constants:QUEUE_GRAPHICS_BIT) not= 0
                VulkanQueue queue
                graphicsQueue = queue
                output "Selected queue " + i + " with flags = " + family:GetQueueFlags() + ", creating graphics queue..."
                // Create the queue using the device, the queue family, and indicate the first (or zero-th) queue in the family
                queue:Create(device, family, 0)
                i = device:GetQueueFamilyCount()
            end

            i = i + 1
        end

        output "Made graphics queue, success = " + (graphicsQueue not= undefined)
        if graphicsQueue = undefined
            return false
        end

        i = 0
        repeat while i < device:GetQueueFamilyCount()
            VulkanQueueFamily family = device:GetQueueFamily(i)
            if family:CanPresentToSurface(surface)
                // If the graphics queue we already have can also support presentation, use the same queue for both.
                if graphicsQueue:GetQueueFamily():GetQueueFamilyIndex() = i
                    output "Using already selected graphics queue at " + i + " for presentation."
                    presentationQueue = graphicsQueue
                else
                    VulkanQueue queue
                    presentationQueue = queue
                    output "Selected queue " + i + " with flags = " + family:GetQueueFlags() + ", creating presentation queue..."
                    // Create the queue using the device, the queue family, and indicate the first (or zero-th) queue in the family
                    queue:Create(device, family, 0)
                end
                i = device:GetQueueFamilyCount()
            end
            i = i + 1
        end

        output "Made presentation queue, success = " + (presentationQueue not= undefined)
        if presentationQueue = undefined
            return false
        end

        output "Creating Swapchain..."
        VulkanSwapchain swapchain
        me:swapchain = swapchain

        VulkanSwapchainInfo swapchainInfo = options:swapchainInfo
        if graphicsQueue not= presentationQueue
            Array<integer> queueFamilyIndices
            queueFamilyIndices:Add(graphicsQueue:GetQueueFamily():GetQueueFamilyIndex())
            queueFamilyIndices:Add(presentationQueue:GetQueueFamily():GetQueueFamilyIndex())
            swapchainInfo:SetQueueFamilyIndices(queueFamilyIndices)
        end

        success = swapchain:Create(device, surface, swapchainInfo)
        output "Made swapchain, success = " + success
        if not success
            return false
        end

        VulkanCommandPool commandPool
        me:commandPool = commandPool

        output "Creating command pool..."
        success = commandPool:Create(device, constants:COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT, graphicsQueue:GetQueueFamily():GetQueueFamilyIndex())
        output "Created command pool, success = " + success
        if not success
            return false
        end

        // Create the RenderPass that will be used for the pipeline. This work will likely be moved into a Painter later.
        VulkanAttachmentDescription outputColorAttachment
        outputColorAttachment:SetFormat(swapchainInfo:GetImageViewInfo():GetFormat())
        outputColorAttachment:SetSamples(constants:SAMPLE_COUNT_1_BIT)
        outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_CLEAR)
        outputColorAttachment:SetInitialLayout(constants:IMAGE_LAYOUT_UNDEFINED)
        outputColorAttachment:SetFinalLayout(constants:IMAGE_LAYOUT_PRESENT_SRC)

        Array<VulkanAttachmentDescription> attachmentDescriptions
        attachmentDescriptions:Add(outputColorAttachment)


        VulkanAttachmentReference outputColorReference
        outputColorReference:SetAttachmentIndex(0)
        outputColorReference:SetLayout(constants:IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)

        Array<VulkanAttachmentReference> attachmentReferences
        attachmentReferences:Add(outputColorReference)


        VulkanSubpassDescription subpass
        subpass:SetPipelineBindPoint(constants:PIPELINE_BIND_POINT_GRAPHICS)
        subpass:SetColorAttachments(attachmentReferences)

        Array<VulkanSubpassDescription> subpassDescriptions
        subpassDescriptions:Add(subpass)

        
        VulkanSubpassDependency dependency
        dependency:SetSourceSubpass(constants:SUBPASS_EXTERNAL)
        dependency:SetDestinationSubpass(0)
        dependency:SetSourceStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetDestinationStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetSourceAccessMask(0)
        dependency:SetDestinationAccessMask(constants:ACCESS_COLOR_ATTACHMENT_WRITE_BIT)

        Array<VulkanSubpassDependency> subpassDependencies
        subpassDependencies:Add(dependency)


        output "Creating RenderPass..."
        VulkanRenderPass renderPass
        success = renderPass:Create(device, attachmentDescriptions, subpassDescriptions, subpassDependencies)
        output "Created RenderPass, success = " + success
        if not success
            return false
        end


        output "Creating FrameBuffers..."
        i = 0
        repeat while i < swapchain:GetImageCount()
            VulkanImageView imageView = swapchain:GetImageView(i)
            Array<VulkanImageView> imageViewArray
            imageViewArray:Add(imageView)

            VulkanFramebuffer framebuffer
            success = framebuffer:Create(device, imageViewArray, renderPass)
            if not success
                return false
            end

            i = i + 1
        end
        output "Created FrameBuffers, success = " + success

        return true
    end
    
    /*
    This action sets the background color of the window. This is the color used to clear
    the screen between each frame of animation. The alpha component (transparency) isn't 
    supported for OpenGL rendering, but Vulkan rendering can draw a transparent window 
    background if the feature is enabled.

    Attribute: Parameter red The red component of the color, as a number between 0.0 (no red) and 1.0 (full red).
    Attribute: Parameter green The green component of the color, as a number between 0.0 (no green) and 1.0 (full green).
    Attribute: Parameter blue The blue component of the color, as a number between 0.0 (no blue) and 1.0 (full blue).
    Attribute: Parameter alpha The alpha component of the color, as a number between 0.0 (completely transparent) and 1.0 (completely opaque).
    */
    action SetClearScreenColor(number red, number green, number blue, number alpha)
        redClearComponent = red
        greenClearComponent = green
        blueClearComponent = blue
        alphaClearComponent = alpha
    end
    
    /*
    This action returns the maximum number of textures that can be supported on the system. This number depends
    on the local hardware being used.
    */
    action GetMaximumTextureCount returns integer
        alert("NYI")
        return -1
    end
    
    /*
    This action makes a new shader of the requested type (e.g., FRAGMENT_SHADER or VERTEX_SHADER from the Shader class)
    using the given source code. If the shader code successfully compiles, this action will return an integer ID
    representing that shader. If the shader can't be created or it does not successfully compile, this will alert an error.
    */
    action CreateShader(integer shaderType, text sourceCode, text shaderName) returns integer
        alert("NYI")
        return -1
    end
    
    /*
    This action instructs the rendering system to delete the native resources allocated to a shader. After deleting
    a shader, it can't be used by the rendering system unless it's recompiled.
    */
    action DeleteShader(integer shaderID)
        alert("NYI")
    end
    
    /*
    */
    action CreateShaderProgram(ShaderProgram program) returns integer
        alert("NYI")
    end

    /*
    This action tells the graphics system to render content using the shader program indicated by the provided ID.
    */
    action UseShaderProgram(integer programID)
        alert("NYI")
    end

    /*
    This action instructs the rendering system to delete the native resources allocated to a shader program. After deleting
    a shader program, it can't be used by the rendering system unless it's reloaded. Deleting a program doesn't automatically
    delete the shaders attached to it -- those must also be deleted manually.
    */
    action DeleteShaderProgram(integer programID)
        alert("NYI")
    end
    
    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, integer value)
        alert("NYI")
    end
    
    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, integer value1, integer value2)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, integer value1, integer value2, integer value3)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, integer value1, integer value2, integer value3, integer value4)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, number value)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, number value1, number value2)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, number value1, number value2, number value3)
        alert("NYI")
    end

    /*
    This action sets the value of a shader "uniform" variable to the given input values.
    The uniform is identified by a unique ID that is generated when a shader program using
    that uniform is compiled and linked.
    */
    action SetShaderInput(integer uniformID, number value1, number value2, number value3, number value4)
        alert("NYI")
    end
    
    /*
    This action sets the values of a shader "uniform" array variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. 

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter length How many elements should be copied from the input array to the uniform array.
    */
    action SetShaderInputArray(integer uniformID, Number32BitArray array, integer startIndex, integer length)
        alert("NYI")
    end

    /*
    This action sets the values of an array of Vector2's in a shader "uniform" array variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. 

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter length How many elements should be copied from the input array to the uniform array.
    */
    action SetShaderInputVector2Array(integer uniformID, Number32BitArray array, integer startIndex, integer length)
        alert("NYI")
    end

    /*
    This action sets the values of an array of Vector3's in a shader "uniform" array variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. 

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter length How many elements should be copied from the input array to the uniform array.
    */
    action SetShaderInputVector3Array(integer uniformID, Number32BitArray array, integer startIndex, integer length)
        alert("NYI")
    end

    /*
    This action sets the values of an array of Vector4's in a shader "uniform" array variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. 

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter length How many elements should be copied from the input array to the uniform array.
    */
    action SetShaderInputVector4Array(integer uniformID, Number32BitArray array, integer startIndex, integer length)
        alert("NYI")
    end

    /*
    This action sets the value of an array of Matrix4's in a shader "uniform" variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. The array is assumed to provide
    the matrix in column-major order, unless the transpose flag is set to true, in which case it will be assumed to be
    row-major instead.

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter matrixCount How many matrices should be set in the uniform. Each matrix requires 16 sequential values from the source array.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter transpose If set to true, the uniform will be set to the transpose of the Matrix.
    */
    action SetShaderInputMatrix4Array(integer uniformID, integer matrixCount, Number32BitArray array, integer startIndex, boolean transpose)
        alert("NYI")
    end

    /*
    This action sets the value of an array of Matrix3's in a shader "uniform" variable. The uniform is identified by a unique ID
    that is generated when a shader program using the uniform is compiled and linked. The array is assumed to provide
    the matrix in column-major order, unless the transpose flag is set to true, in which case it will be assumed to be
    row-major instead.

    Attribute: Parameter uniformID An integer ID that represents a uniform in a linked shader program.
    Attribute: Parameter matrixCount How many matrices should be set in the uniform. Each matrix requires 9 sequential values from the source array.
    Attribute: Parameter array A typed array containing the values to copy to the uniform.
    Attribute: Parameter startIndex The first index of the array to begin copying.
    Attribute: Parameter transpose If set to true, the uniform will be set to the transpose of the Matrix.
    */
    action SetShaderInputMatrix3Array(integer uniformID, integer matrixCount, Number32BitArray array, integer startIndex, boolean transpose)
        alert("NYI")
    end

    /*
    This action informs the rendering system of how to interpret elements of vertex input data for a particular input.

    Attribute: Parameter inputID An ID that describes a vertex input.
    Attribute: Parameter size How many bytes from the array are needed to set a single instance of the input value in the shader. Must be between 1 and 4.
    Attribute: Parameter type A constant value representing the type of data, such as GL_INT.
    Attribute: Parameter normalize If set to true, fixed-point data values will be normalized when passed down to the system. If set to false, the values will be passed down without modification.
    Attribute: Parameter stride How many bytes of data separate each instance of data meant to be used for this input. If this value is 0, it's assumed that there is no additional data interleaved between data used for this input.
    Attribute: Parameter offset The index of the first element of this input's data in the input buffer, or in other words, how many bytes of data appear before the first instance of input data for this input.
    */
    action SetVertexInputInformation(integer inputID, integer size, integer type, boolean normalize, integer stride, integer offset)
        alert("NYI")
    end

    action GetSurface returns VulkanSurface
        return surface
    end

end