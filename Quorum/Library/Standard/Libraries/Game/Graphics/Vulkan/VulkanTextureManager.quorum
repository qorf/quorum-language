package Libraries.Game.Graphics.Vulkan

use Libraries.Containers.Array
use Libraries.Game.Graphics.PixelMap
use Libraries.Game.Graphics.Texture
use Libraries.Game.GameStateManager
use Libraries.Game.Graphics.Format
use Libraries.Compute.BitwiseOperations
use Libraries.Game.Graphics.Vulkan.Commands.PipelineBarrierCommand
use Libraries.Game.Graphics.Vulkan.Commands.CopyBufferToImageCommand
use Libraries.Containers.HashTable
use Libraries.Containers.Queue

class VulkanTextureManager

    // A pair of parallel arrays. The pending textures are all textures that received Load commands since the last frame of animation.
    // The pending pixel maps are the sets of pixel data associated with the load commands.
    Array<Texture> pendingTextures
    Array<PixelMap> pendingPixelMaps

    // An array of staging buffers used for transferring texture data from host memory to GPU memory.
    // Disposed of after the transfers have finished.
    Array<VulkanBuffer> stagingBuffers

    VulkanDevice device = undefined

    // A host-accessible mirror of the global texture resource that is presented to the GPU.
    Array<Texture> globalTextureArray
    // A hash table for converting textures back to their index in the global texture array.
    HashTable<Texture, integer> textureToIndexTable
    // The next index to store a texture at in the global array.
    integer nextTextureID = 0
    // TO-DO: NYI, whenever a Texture is disposed, store its index here. New textures reuse previously freed IDs before using a new index.
    Queue<integer> recycledTextureIDs

    /*
    A descriptor set that can be dynamically added to and updated (UPDATE_AFTER_BIND_BIT) that
    contains all valid textures in the system. Changes only when textures are loaded/disposed.
    */
    VulkanDescriptorSet globalTextureDescriptorSet = undefined

    action Create(VulkanDevice device)
        GameStateManager gameState
        VulkanConstants constants
        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
        VulkanDescriptorSetManager setManager = graphics:GetDescriptorSetManager()

        // NYI: Currently using a hardcoded value for the maximum number of textures, but this should be drawn from the PhysicalDevice properties instead.
        output "Creating VulkanTextureManager. Using testing value of 256 max descriptors for textures..."
        integer maxDescriptors = 256
        Array<VulkanDescriptorSetLayoutBinding> bindings

        VulkanDescriptorSetLayoutBinding texturesBinding
        texturesBinding:SetBinding(0)
        texturesBinding:SetDescriptorType(constants:DESCRIPTOR_TYPE_SAMPLED_IMAGE)
        texturesBinding:SetStageFlags(constants:SHADER_STAGE_FRAGMENT_BIT)
        texturesBinding:SetDescriptorCount(maxDescriptors)
        texturesBinding:SetBindingFlags(constants:DESCRIPTOR_BINDING_DYNAMIC)
        bindings:Add(texturesBinding)

        VulkanDescriptorSetLayout globalTextureLayout
        globalTextureLayout:CreateUpdateAfterBind(device, bindings)
    end

    action RequestLoad(Texture texture, PixelMap pixelMap)
        pendingTextures:Add(texture)
        pendingPixelMaps:Add(pixelMap)
    end

    action ProcessPendingTextures
        if pendingTextures:IsEmpty() = false
            GameStateManager manager
            VulkanGraphics graphics = cast(VulkanGraphics, manager:GetGameGraphics())
            VulkanDevice device = graphics:GetDevice()
            VulkanCommandBuffer commandBuffer = graphics:GetCurrentRenderCommandBuffer()
            VulkanConstants constants
            BitwiseOperations bits

            integer i = 0
            repeat while i < pendingTextures:GetSize()
                Texture texture = pendingTextures:Get(i)
                PixelMap pixelMap = pendingPixelMaps:Get(i)                

                integer width = pixelMap:GetWidth()
                integer height = pixelMap:GetHeight()

                integer pixelSize = 1
                Format format = pixelMap:GetFormat()
                integer formatValue = format:GetValue()

                if formatValue = format:RGBA8888
                    pixelSize = 4
                elseif formatValue = format:ALPHA or formatValue = format:LUMINANCE_ALPHA
                    pixelSize = 1
                elseif formatValue = format:RGB888
                    pixelSize = 3
                elseif formatValue = format:RGB565 or formatValue = format:RGBA4444
                    pixelSize = 2
                end


                VulkanBuffer buffer
                buffer:CreateTransferSourceBuffer(device, width * height * pixelSize)
                buffer:BeginMapping()
                TransferPixelData(pixelMap, buffer)
                buffer:StopMapping()

                VulkanImage image
                image:Create(device, width, height, bits:And(constants:IMAGE_USAGE_TRANSFER_DESTINATION_BIT, constants:IMAGE_USAGE_SAMPLED_BIT))

                // We'll need this as part of the buffer-to-image copy, in order to ensure the image is in the right format to accept the 
                // buffer data before we send it.
                VulkanImageMemoryBarrier memoryBarrier
                memoryBarrier:SetNewLayout(constants:IMAGE_LAYOUT_TRANSFER_DESTINATION_OPTIMAL)
                memoryBarrier:SetSourceAccessMask(0)
                memoryBarrier:SetDestinationAccessMask(constants:ACCESS_TRANSFER_WRITE_BIT)
                memoryBarrier:SetSourceStageMask(constants:PIPELINE_STAGE_TOP_OF_PIPE_BIT)
                memoryBarrier:SetDestinationStageMask(constants:PIPELINE_STAGE_TRANSFER_BIT)
                memoryBarrier:SetAspectMask(constants:IMAGE_ASPECT_COLOR_BIT)
                memoryBarrier:SetImage(image)

                PipelineBarrierCommand transitionForTransferCommand
                transitionForTransferCommand:SetMemoryBarrier(memoryBarrier)
                commandBuffer:Record(transitionForTransferCommand)

                // Now send the command to copy the buffer to the image.
                CopyBufferToImageCommand copyCommand
                copyCommand:SetImageWidth(width)
                copyCommand:SetImageHeight(height)
                copyCommand:SetAspectMask(constants:IMAGE_ASPECT_COLOR_BIT)
                copyCommand:SetSourceBuffer(buffer)
                copyCommand:SetDestinationImage(image)
                commandBuffer:Record(copyCommand)

                // Once the copy is finished, we'll need to transition the image's layout from a state for receiving data, and into a new state fit for reading from the shader.
                VulkanImageMemoryBarrier readTransition
                readTransition:SetOldLayout(constants:IMAGE_LAYOUT_TRANSFER_DESTINATION_OPTIMAL)
                readTransition:SetNewLayout(constants:IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
                readTransition:SetSourceAccessMask(constants:ACCESS_TRANSFER_WRITE_BIT)
                readTransition:SetDestinationAccessMask(constants:ACCESS_SHADER_READ_BIT)
                readTransition:SetSourceStageMask(constants:PIPELINE_STAGE_TRANSFER_BIT)
                readTransition:SetDestinationStageMask(constants:PIPELINE_STAGE_FRAGMENT_SHADER_BIT)
                readTransition:SetAspectMask(constants:IMAGE_ASPECT_COLOR_BIT)
                readTransition:SetImage(image)

                PipelineBarrierCommand transitionForReadCommand
                transitionForReadCommand:SetMemoryBarrier(readTransition)
                commandBuffer:Record(transitionForReadCommand)

                // We need to hold onto the buffer to be disposed after the transfer is done.
                stagingBuffers:Add(buffer)


                // Now we need an ImageView to encapsulate the Image. The view will be accessed to get information about the related image.
                VulkanImageView view
                VulkanImageViewInfo viewInfo
                viewInfo:SetFormat(constants:FORMAT_R8G8B8A8_SRGB)
                view:Create(device, image, viewInfo)

                // Finally, associate the image view with the texture.
                texture:SetVulkanImageView(view)

                // Also store the texture in our global array and associate our resources.
                if not recycledTextureIDs:IsEmpty()
                    // TO-DO: Handle this case. This gets complicated slightly by the question of releasing texture IDs that might be in use for previous frames.
                else
                    globalTextureArray:Add(texture)
                    texture:SetVulkanTextureIndex(nextTextureID)
                    nextTextureID = nextTextureID + 1
                end

                VulkanDescriptorResourcesInfo resourcesInfo
                resourcesInfo:SetDescriptorType(constants:DESCRIPTOR_TYPE_SAMPLED_IMAGE)
                resourcesInfo:SetDestinationArrayElement(texture:GetVulkanTextureIndex())
                resourcesInfo:AddImageInfo(undefined, view, constants:IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
                globalTextureDescriptorSet:LinkResources(resourcesInfo)
  
                // NOTE: Currently not assigning a sampler, because 2D is using the images with a shared common sampler from the Painter2D instead.      
                // We'll use a combined image sampler to access the texture. Create a sampler and associate it with the texture.
//                VulkanSampler sampler
//                VulkanSamplerInfo samplerInfo
//                // TO-DO: NYI, Update the samplerInfo to more accurately match the information given for a Texture, especially its wrap and min/mag modes.
//                // For now, just use the default sampler values.
//                sampler:Create(device, samplerInfo)
//                texture:SetVulkanSampler(sampler)


                i = i + 1
            end
        end
    end

    private system action TransferPixelData(PixelMap pixelMap, VulkanBuffer buffer)

end