package Libraries.Game.Graphics.Vulkan

use Libraries.Interface.Item2D
use Libraries.Game.Graphics.Painter2D
use Libraries.Game.Graphics.Camera
use Libraries.Game.Graphics.Drawable
use Libraries.Game.Graphics.Color
use Libraries.Containers.Array
use Libraries.Game.GameStateManager
use Libraries.Game.Graphics.Vulkan.Commands.all
use Libraries.Game.Game
use Libraries.Containers.Iterator
use Libraries.Game.Layer
use Libraries.Game.Layer2D
use Libraries.Game.Graphics.Shaders.Shader
use Libraries.Game.Graphics.Shaders.ShaderManager
use Libraries.Game.Graphics.Shaders.Vulkan.VulkanShaderManager
use Libraries.Containers.Number32BitArray
use Libraries.Containers.Integer32BitArray
use Libraries.Containers.HashTable
use Libraries.Game.Graphics.DrawableShape

class VulkanPainter2D is Painter2D

    GameStateManager gameState
    VulkanRenderPass renderPass = undefined
    VulkanPipeline defaultPipeline = undefined

    /*
    A hash table storing the batch(es) associated with a particular pipeline.
    Each pipeline uses its own buffers for vertices and indices. Each array will
    likely only have one element, but it's possible that there will be multiple
    if more elements need to be rendered with one pipeline than can fit in a single batch.
    */
    HashTable<VulkanPipeline, Array<VulkanPainter2DBatch>> batches

    // The current batch being used.
    VulkanPainter2DBatch currentBatch = undefined
    // The first index from the IndexData to be drawn for the currentBatch. Used when recording upcoming draw commands.
    integer currentStartIndex = 0

    // The maximum number of frames to allow a batch to remain without being used before it should be disposed to free up memory.
    integer maximumAge = 180

    // Draw commands that will be queued into a buffer.
    // These are stored to be used later because buffer transfer commands need to be processed before these, but we won't know
    // how much data needs to be transferred until we're done looking at all the data. 
    Array<DrawIndexedCommand> pendingDrawCommands
    // A parallel array of batches. The n-th draw command uses the vertex and index buffers from the n-th pending batch.
    Array<VulkanPainter2DBatch> pendingBatches

    on create
        LoadDefaultPainter()
    end

    action IsRenderPassValid returns boolean
        return renderPass not= undefined
    end

    action RegenerateRenderPass(boolean isFirstPass) returns boolean
        if renderPass not= undefined
            renderPass:Dispose()
        end

        VulkanRenderPass pass
        renderPass = pass

        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
        VulkanConstants constants

        /*
        Create the RenderPass that will be used for this painter. 
        This must be compatible with the render pass used for the swapchain Framebuffers.
        The RenderPass provided to the Framebuffers will indicate how rendering to the buffers will be performed. Pipelines using the
        Framebuffers must either exactly match the RenderPass, or be compatible with it. More details here:
        https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap8.html#renderpass-compatibility
        */
        VulkanAttachmentDescription outputColorAttachment
        outputColorAttachment:SetFormat(graphics:GetSwapchain():GetImageViewInfo():GetFormat())
        outputColorAttachment:SetSamples(constants:SAMPLE_COUNT_1_BIT)
        outputColorAttachment:SetStoreOp(constants:ATTACHMENT_STORE_OP_STORE)
        outputColorAttachment:SetInitialLayout(constants:IMAGE_LAYOUT_UNDEFINED)
        outputColorAttachment:SetFinalLayout(constants:IMAGE_LAYOUT_PRESENT_SOURCE)

        if isFirstPass
            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_CLEAR)
        else
//            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_LOAD)
            output "NOTE: Hard-setting attachment load op to CLEAR during testing..."
            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_CLEAR)
        end

        Array<VulkanAttachmentDescription> attachmentDescriptions
        attachmentDescriptions:Add(outputColorAttachment)


        VulkanAttachmentReference outputColorReference
        outputColorReference:SetAttachmentIndex(0)
        outputColorReference:SetLayout(constants:IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)

        Array<VulkanAttachmentReference> attachmentReferences
        attachmentReferences:Add(outputColorReference)


        VulkanSubpassDescription subpass
        subpass:SetPipelineBindPoint(constants:PIPELINE_BIND_POINT_GRAPHICS)
        subpass:SetColorAttachments(attachmentReferences)

        Array<VulkanSubpassDescription> subpassDescriptions
        subpassDescriptions:Add(subpass)

        
        VulkanSubpassDependency dependency
        dependency:SetSourceSubpass(constants:SUBPASS_EXTERNAL)
        dependency:SetDestinationSubpass(0)
        dependency:SetSourceStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetDestinationStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetSourceAccessMask(0)
        dependency:SetDestinationAccessMask(constants:ACCESS_COLOR_ATTACHMENT_WRITE_BIT)

        Array<VulkanSubpassDependency> subpassDependencies
        subpassDependencies:Add(dependency)


        boolean success = renderPass:Create(graphics:GetDevice(), attachmentDescriptions, subpassDescriptions, subpassDependencies)
        output "Painter: Created RenderPass, success = " + success
        return success
    end

    private action LoadDefaultPainter
        // Load a default structure for vertices or other GPU info here?

        
    end

    private action GetDefaultPipeline returns VulkanPipeline
        if defaultPipeline = undefined
            VulkanPipeline pipeline

            VulkanShaderManager shaderManager = cast(VulkanShaderManager, gameState:GetShaderManager())
            Shader vertexShader = shaderManager:GetDefaultVertexShader2D()
            Shader fragmentShader = shaderManager:GetDefaultFragmentShader2D()

            Array<Shader> shaders
            shaders:Add(vertexShader)
            shaders:Add(fragmentShader)

            VulkanDevice device = renderPass:GetDevice()
            VulkanPipelineCache cache = shaderManager:GetPipelineCache()
            VulkanConstants constants



            VulkanPipelineInfo info
            Array<VulkanVertexInputAttributeDescription> vertexAttributes = info:GetVertexInputAttributeDescriptions()
            Array<VulkanVertexInputBindingDescription> vertexBindings = info:GetVertexInputBindingDescriptions()
            Array<VulkanPipelineColorBlendAttachmentState> colorBlendAttachments = info:GetPipelineColorBlendAttachmentStates()

            // Create the vertex attribute descriptions, and the binding that will indicate how far apart each vertex's data is in the buffers.
    
            // How far into the data structure the current piece of data is.
            integer offset = 0

            // Position attribute
            VulkanVertexInputAttributeDescription positionAttribute
            positionAttribute:Set(0, 0, constants:FORMAT_R32G32B32_SFLOAT, offset)
            vertexAttributes:Add(positionAttribute)

            // Position is stored as 3 floats of 4 bytes each.
            offset = offset + (3 * 4)


            /*
            // Texture coordinate attribute
            VulkanVertexInputAttributeDescription textureCoordinatesAttribute
            textureCoordinatesAttribute:Set(0, 1, constants:FORMAT_R32G32_SFLOAT, 3 * 4)
            vertexAttributes:Add(textureCoordinatesAttribute)

            // Texture coordinates are stored as 2 floats of 4 bytes each.
            offset = offset + (2 * 4)
            */
            
            // Binding description, indicates how far apart each vertex's data is
            VulkanVertexInputBindingDescription bindingDescription
            bindingDescription:Set(0, offset, constants:VERTEX_INPUT_RATE_VERTEX)
            vertexBindings:Add(bindingDescription)



            // Define the color blend attachment states. Just creating and adding it is enough, the default values work for us.
            VulkanPipelineColorBlendAttachmentState colorBlend
            colorBlendAttachments:Add(colorBlend)


            // Define the dynamic states permitted by the pipeline. For our case, we want to be able to dynamically adjust viewport and scissor values.
            Array<integer> dynamicStates = info:GetDynamicStates()
            dynamicStates:Add(constants:DYNAMIC_STATE_VIEWPORT)
            dynamicStates:Add(constants:DYNAMIC_STATE_SCISSOR)


            // The info structure has lots of other values we could customize, but all of the default values will work well for us here.
            // We can now create the Pipeline itself.
            boolean success = pipeline:Create(device, renderPass, cache, shaders, info)
            
            if success
                defaultPipeline = pipeline
            else
                pipeline:Dispose()
            end
        end

        return defaultPipeline
    end

    private action GetBatch(VulkanPipeline pipeline) returns VulkanPainter2DBatch
        if batches:HasKey(pipeline)
            // Try to find an existing batch that's available. This will be the most common case.
            Array<VulkanPainter2DBatch> array = batches:GetValue(pipeline)
            integer i = 0
            repeat while i < array:GetSize()
                VulkanPainter2DBatch batch = array:Get(i)
                if not batch:IsFull()
                    return batch
                end

                i = i + 1
            end

            // If there wasn't an available batch, make a new one and add it to the array.
            VulkanPainter2DBatch batch = NewBatch(pipeline)
            array:Add(batch)
            return batch
        else
            // This is our first time using this pipeline. Make an array and a batch for it.
            Array<VulkanPainter2DBatch> array
            VulkanPainter2DBatch batch = NewBatch(pipeline)
            array:Add(batch)
            batches:Add(pipeline, array)
            return batch
        end
    end

    private action NewBatch(VulkanPipeline pipeline) returns VulkanPainter2DBatch
        VulkanPainter2DBatch batch
        batch:Create(pipeline)
        return batch
    end

    private action EndBatches(VulkanCommandBuffer commandBuffer)
        Iterator<Array<VulkanPainter2DBatch>> arrays = batches:GetValueIterator()
        repeat while arrays:HasNext()
            Array<VulkanPainter2DBatch> array
            integer i = array:GetSize()
            repeat while i > 0
                i = i - 1

                VulkanPainter2DBatch batch = array:Get(i)
                // If the age is 0, it has been used this frame. Allow it to record any transfer commands it needs.
                if batch:GetAge() = 0
                    batch:TransferBuffers(commandBuffer)
                end
                
                // If the batch hasn't been used, and it isn't the default one, dispose of it to free up memory.
                if batch:GetAge() > maximumAge and (batch:GetPipeline() not= defaultPipeline or i not= 0)
                    batch:Dispose()
                    array:Remove(batch)
                    if array:IsEmpty()
                        batches:RemoveValue(array)
                    end
                else
                    batch:PrepareForNextFrame()
                end
            end
        end
    end

    action SetCamera(Camera camera)
//        output "NYI: VulkanPainter2D SetCamera"
//        alert("NYI")
    end
    
    action Begin
        // If the render pass isn't defined and valid, regenerate it.
        // We'll have to determine if this is the first painter in the Game as part of this.
        if not IsRenderPassValid()
            boolean isFirstLayer = false

            Game game = gameState:GetGame()
            Iterator<Layer> layers = game:GetLayerIterator()
            if layers:HasNext()
                Layer layer = layers:Next()
                if layer is Layer2D
                    Layer2D layer2D = cast(Layer2D, layer)
                    isFirstLayer = layer2D:GetPainter():Equals(me)
                end
            end

            RegenerateRenderPass(isFirstLayer)
        end

//        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
//        VulkanConstants constants
//
//        VulkanCommandBuffer commandBuffer = graphics:GetCurrentRenderCommandBuffer()
//        VulkanFramebuffer framebuffer = graphics:GetCurrentFramebuffer()
//        VulkanSwapchain swapchain = graphics:GetSwapchain()
//        VulkanClearValue clearValue = graphics:GetClearValue()
//        
//
//
//        // Create the command to begin the render pass.
//        BeginRenderPassCommand beginRenderPass
//        beginRenderPass:SetRenderPass(renderPass)
//        beginRenderPass:SetClearValue(clearValue)
//        beginRenderPass:SetFramebuffer(framebuffer)
//        beginRenderPass:SetRenderArea(swapchain:GetImageWidth(), swapchain:GetImageHeight())
//        commandBuffer:Record(beginRenderPass)
//
////        // NEXT STEP: Bind pipeline command
//////        BindPipelineCommand bindPipeline
//////        bindPipeline:SetPipeline(pipeline)
//
//        // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
//        // Set viewport command
//        // Setting the position to the height and the height to the negated height flips the Y axis of our viewport.
//        SetViewportCommand setViewport
//        setViewport:SetPosition(0, swapchain:GetImageHeight())
//        setViewport:SetSize(swapchain:GetImageWidth(), -swapchain:GetImageHeight())
//        commandBuffer:Record(setViewport)
//
//        // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
//        // Set scissor command
//        SetScissorCommand setScissor
//        setScissor:SetPosition(0, 0)
//        setScissor:SetSize(swapchain:GetImageWidth(), swapchain:GetImageHeight())
//        commandBuffer:Record(setScissor)
    end
    
    action End
        Flush()

        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
        VulkanCommandBuffer commandBuffer = graphics:GetCurrentRenderCommandBuffer()
        VulkanFramebuffer framebuffer = graphics:GetCurrentFramebuffer()
        VulkanSwapchain swapchain = graphics:GetSwapchain()
        VulkanClearValue clearValue = graphics:GetClearValue()
        VulkanConstants constants
        
        /*
        End the batches. This will reset information from the last pass, dispose of any batches that 
        haven't been used in a long time, and record transfer commands from staging buffers to output buffers.
        */
        EndBatches(commandBuffer)

        // After ending the batches, we need to wait for data transfers to complete before any drawing can occur.
        // Create a memory barrier that ensures that all commands after this must wait for the transfer stage of
        // the pipeline to complete before operations in the vertex input stage can begin.
        VulkanMemoryBarrier memoryBarrier
        memoryBarrier:SetSourceStageMask(constants:PIPELINE_STAGE_TRANSFER_BIT)
        memoryBarrier:SetSourceAccessMask(constants:ACCESS_MEMORY_WRITE_BIT)
        memoryBarrier:SetDestinationStageMask(constants:PIPELINE_STAGE_VERTEX_INPUT_BIT)
        memoryBarrier:SetDestinationAccessMask(constants:ACCESS_MEMORY_READ_BIT)

        PipelineBarrierCommand barrierCommand
        barrierCommand:SetMemoryBarrier(memoryBarrier)
        commandBuffer:Record(barrierCommand)
        

        // Create the command to begin the render pass.
        BeginRenderPassCommand beginRenderPass
        beginRenderPass:SetRenderPass(renderPass)
        beginRenderPass:SetClearValue(clearValue)
        beginRenderPass:SetFramebuffer(framebuffer)
        beginRenderPass:SetRenderArea(swapchain:GetImageWidth(), swapchain:GetImageHeight())
        commandBuffer:Record(beginRenderPass)

//        // NEXT STEP: Bind pipeline command
////        BindPipelineCommand bindPipeline
////        bindPipeline:SetPipeline(pipeline)

        // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
        // Set viewport command
        // Setting the position to the height and the height to the negated height flips the Y axis of our viewport.
        SetViewportCommand setViewport
        setViewport:SetPosition(0, swapchain:GetImageHeight())
        setViewport:SetSize(swapchain:GetImageWidth(), -swapchain:GetImageHeight())
        commandBuffer:Record(setViewport)

        // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
        // Set scissor command
        SetScissorCommand setScissor
        setScissor:SetPosition(0, 0)
        setScissor:SetSize(swapchain:GetImageWidth(), swapchain:GetImageHeight())
        commandBuffer:Record(setScissor)

        // Set the pipelines and send the corresponding draw calls.
        integer i = 0
        repeat while i < pendingBatches:GetSize()
            VulkanPainter2DBatch batch = pendingBatches:Get(i)
            DrawIndexedCommand drawCommand = pendingDrawCommands:Get(i)

            BindPipelineCommand bindPipeline
            bindPipeline:SetPipeline(batch:GetPipeline())
            commandBuffer:Record(bindPipeline)

            BindVertexBufferCommand vertexBind
            vertexBind:SetBuffer(batch:GetVertexOutputBuffer())
            commandBuffer:Record(vertexBind)

            BindIndexBufferCommand indexBind
            indexBind:SetBuffer(batch:GetIndexOutputBuffer())
            commandBuffer:Record(indexBind)

            commandBuffer:Record(drawCommand)

            i = i + 1
        end

        // End the render pass.
        EndRenderPassCommand endRenderPass
        commandBuffer:Record(endRenderPass)

        // Set the current batch to undefined, to ensure we're starting with a clean slate again next time.
        currentBatch = undefined

        // Empty the pending arrays.
        pendingDrawCommands:Empty(false)
        pendingBatches:Empty(false)
    end
    
    action SetClipping(boolean clippingEnabled)
//        output "NYI: VulkanPainter2D SetClipping"
//        alert("NYI")
    end
    
    action SetColor(Color color)
//        output "NYI: VulkanPainter2D SetColor"
//        alert("NYI")
    end
    
    action SetColor(number red, number green, number blue, number alpha)
//        output "NYI: VulkanPainter2D SetColor(2)"
//        alert("NYI")
    end
    
    action QueueForDrawing(Item2D item)
        if not (item is Drawable)
            return now
        end

        Drawable drawable = cast(Drawable, item)
        DrawableShape shape = drawable:GetDrawableShape()

        if not shape:IsRenderable()
            return now
        end

        // TO-DO: Check if the Item has a specific pipeline it needs for rendering.
        VulkanPipeline requestedPipeline = undefined

        if requestedPipeline = undefined
            requestedPipeline = defaultPipeline
        end

        if currentBatch = undefined or currentBatch:GetPipeline() not= requestedPipeline
            Flush()
            currentBatch = GetBatch(requestedPipeline)
            currentBatch:ResetAge()
            currentStartIndex = currentBatch:GetIndexWritePosition()
        end

        currentBatch:Add(drawable:GetDrawableShape())
    end

    private action Flush
        if currentBatch = undefined
            return now
        end

        DrawIndexedCommand drawCommand
        drawCommand:SetFirstIndex(currentStartIndex)
        drawCommand:SetIndexCount(currentBatch:GetIndexWritePosition() - currentStartIndex)
        pendingDrawCommands:Add(drawCommand)
        pendingBatches:Add(currentBatch)
    end
    
    action Draw(Drawable drawable)
//        output "NYI: VulkanPainter2D Draw"
//        alert("NYI")
    end
    
    action SetClipCoordinates(number x, number y, number width, number height)
//        output "NYI: VulkanPainter2D SetClipCoordinates"
//        alert("NYI")
    end

end