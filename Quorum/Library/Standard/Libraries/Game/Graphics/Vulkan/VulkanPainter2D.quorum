package Libraries.Game.Graphics.Vulkan

use Libraries.Interface.Item2D
use Libraries.Game.Graphics.Painter2D
use Libraries.Game.Graphics.Camera
use Libraries.Game.Graphics.Drawable
use Libraries.Game.Graphics.Color
use Libraries.Containers.Array
use Libraries.Game.GameStateManager
use Libraries.Game.Graphics.Vulkan.Commands.all
use Libraries.Game.Game
use Libraries.Containers.Iterator
use Libraries.Game.Layer
use Libraries.Game.Layer2D
use Libraries.Game.Graphics.Shaders.Shader
use Libraries.Game.Graphics.Shaders.ShaderManager
use Libraries.Game.Graphics.Shaders.Vulkan.VulkanShaderManager
use Libraries.Containers.Number32BitArray
use Libraries.Containers.Integer32BitArray
use Libraries.Containers.HashTable
use Libraries.Game.Graphics.DrawableShape
use Libraries.Compute.Matrix4

class VulkanPainter2D is Painter2D

    GameStateManager gameState
    VulkanRenderPass renderPass = undefined
    VulkanPipeline defaultPipeline = undefined

    /*
    A hash table storing the batch(es) associated with a particular pipeline.
    Each pipeline uses its own buffers for vertices and indices. Each array will
    likely only have one element, but it's possible that there will be multiple
    if more elements need to be rendered with one pipeline than can fit in a single batch.
    */
    HashTable<VulkanPipeline, Array<VulkanPainter2DBatch>> batches

    // The current batch being used.
    VulkanPainter2DBatch currentBatch = undefined
    // The first index from the IndexData to be drawn for the currentBatch. Used when recording upcoming draw commands.
    integer currentStartIndex = 0

    // The maximum number of frames to allow a batch to remain without being used before it should be disposed to free up memory.
    integer maximumAge = 180

    // Draw commands that will be queued into a buffer.
    // These are stored to be used later because buffer transfer commands need to be processed before these, but we won't know
    // how much data needs to be transferred until we're done looking at all the data. 
    Array<DrawIndexedCommand> pendingDrawCommands
    // A parallel array of batches. The n-th draw command uses the vertex and index buffers from the n-th pending batch.
    Array<VulkanPainter2DBatch> pendingBatches

    // TO-DO: Move these into structures that more closely associate these resources with a VulkanPipeline, or wherever else they make sense.
    VulkanDescriptorSetLayout descriptorSetLayout = undefined
    VulkanPipelineLayout pipelineLayout = undefined

    // Each array below holds 1 object per frame in the swapchain, e.g. the uniformBuffers holds 1 buffer per swapchain image.
    // We do this so each image in-flight has independent resources to work on in parallel.

    // Resources for the Camera uniform.
    Array<VulkanBuffer> cameraBuffers
    Array<VulkanNumber32BitMappedMemory> cameraMappings
    Array<VulkanDescriptorSet> cameraDescriptors

    // The sampler used to access 2D textures.
    VulkanSampler immutableSampler = undefined

    Camera camera = undefined

    // An internal array used to transfer data from Matrix4 objects to mapped memory.
    Number32BitArray matrix4Array

    on create
        matrix4Array:SetSize(16)
    end

    action IsRenderPassValid returns boolean
        return renderPass not= undefined
    end

    action RegenerateRenderPass(boolean isFirstPass) returns boolean
        if renderPass not= undefined
            renderPass:Dispose()
        end

        VulkanRenderPass pass
        renderPass = pass

        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
        VulkanConstants constants

        /*
        Create the RenderPass that will be used for this painter. 
        This must be compatible with the render pass used for the swapchain Framebuffers.
        The RenderPass provided to the Framebuffers will indicate how rendering to the buffers will be performed. Pipelines using the
        Framebuffers must either exactly match the RenderPass, or be compatible with it. More details here:
        https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap8.html#renderpass-compatibility
        */
        VulkanAttachmentDescription outputColorAttachment
        outputColorAttachment:SetFormat(graphics:GetSwapchain():GetImageViewInfo():GetFormat())
        outputColorAttachment:SetSamples(constants:SAMPLE_COUNT_1_BIT)
        outputColorAttachment:SetStoreOp(constants:ATTACHMENT_STORE_OP_STORE)
        outputColorAttachment:SetInitialLayout(constants:IMAGE_LAYOUT_UNDEFINED)
        outputColorAttachment:SetFinalLayout(constants:IMAGE_LAYOUT_PRESENT_SOURCE)

        if isFirstPass
            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_CLEAR)
        else
//            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_LOAD)
            output "NOTE: Hard-setting attachment load op to CLEAR during testing..."
            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_CLEAR)
        end

        Array<VulkanAttachmentDescription> attachmentDescriptions
        attachmentDescriptions:Add(outputColorAttachment)


        VulkanAttachmentReference outputColorReference
        outputColorReference:SetAttachmentIndex(0)
        outputColorReference:SetLayout(constants:IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)

        Array<VulkanAttachmentReference> attachmentReferences
        attachmentReferences:Add(outputColorReference)


        VulkanSubpassDescription subpass
        subpass:SetPipelineBindPoint(constants:PIPELINE_BIND_POINT_GRAPHICS)
        subpass:SetColorAttachments(attachmentReferences)

        Array<VulkanSubpassDescription> subpassDescriptions
        subpassDescriptions:Add(subpass)

        
        VulkanSubpassDependency dependency
        dependency:SetSourceSubpass(constants:SUBPASS_EXTERNAL)
        dependency:SetDestinationSubpass(0)
        dependency:SetSourceStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetDestinationStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetSourceAccessMask(0)
        dependency:SetDestinationAccessMask(constants:ACCESS_COLOR_ATTACHMENT_WRITE_BIT)

        Array<VulkanSubpassDependency> subpassDependencies
        subpassDependencies:Add(dependency)


        boolean success = renderPass:Create(graphics:GetDevice(), attachmentDescriptions, subpassDescriptions, subpassDependencies)
        output "Painter: Created RenderPass, success = " + success
        return success
    end

    private action GetDefaultPipeline returns VulkanPipeline
        if defaultPipeline = undefined
            output "CREATING DEFAULT PIPELINE!"
            VulkanPipeline pipeline

            VulkanShaderManager shaderManager = cast(VulkanShaderManager, gameState:GetShaderManager())
            Shader vertexShader = shaderManager:GetDefaultVertexShader2D()
            Shader fragmentShader = shaderManager:GetDefaultFragmentShader2D()

            Array<Shader> shaders
            shaders:Add(vertexShader)
            shaders:Add(fragmentShader)

            VulkanDevice device = renderPass:GetDevice()
            VulkanPipelineCache cache = shaderManager:GetPipelineCache()
            VulkanConstants constants


            VulkanPipelineInfo info
            Array<VulkanVertexInputAttributeDescription> vertexAttributes = info:GetVertexInputAttributeDescriptions()
            Array<VulkanVertexInputBindingDescription> vertexBindings = info:GetVertexInputBindingDescriptions()
            Array<VulkanPipelineColorBlendAttachmentState> colorBlendAttachments = info:GetPipelineColorBlendAttachmentStates()

            // Create the vertex attribute descriptions, and the binding that will indicate how far apart each vertex's data is in the buffers.
    
            // How far into the data structure the current piece of data is.
            integer offset = 0

            // Position attribute
            VulkanVertexInputAttributeDescription positionAttribute
            positionAttribute:Set(0, 0, constants:FORMAT_R32G32B32_SFLOAT, offset)
            vertexAttributes:Add(positionAttribute)

            // Position is stored as 3 floats of 4 bytes each.
            offset = offset + (3 * 4)

            VulkanVertexInputAttributeDescription colorAttribute
            colorAttribute:Set(0, 1, constants:FORMAT_R8G8B8A8_UNORM, offset)
            vertexAttributes:Add(colorAttribute)

            // The color attribute is made of 4 components of 1 byte each.
            offset = offset + 4



            // Texture coordinate attribute
            VulkanVertexInputAttributeDescription textureCoordinatesAttribute
            textureCoordinatesAttribute:Set(0, 2, constants:FORMAT_R32G32_SFLOAT, offset)
            vertexAttributes:Add(textureCoordinatesAttribute)

            // Texture coordinates are stored as 2 floats of 4 bytes each.
            offset = offset + (2 * 4)


            // Texture index attribute. Used to access the right texture from the global texture array in the 2D fragment shader.
            VulkanVertexInputAttributeDescription textureIndexAttribute
            textureIndexAttribute:Set(0, 3, constants:FORMAT_R32_UINT, offset)
            vertexAttributes:Add(textureIndexAttribute)

            // Texture index is stored as a 32-bit (4 byte) integer.
            offset = offset + 4
            
            // Binding description, indicates how far apart each vertex's data is
            VulkanVertexInputBindingDescription bindingDescription
  
            bindingDescription:Set(0, offset, constants:VERTEX_INPUT_RATE_VERTEX)
//            output "WARNING: HARD-SETTING PAINTER2D DEFAULT PIPELINE STRIDE TO 24"
//            bindingDescription:Set(0, 24, constants:VERTEX_INPUT_RATE_VERTEX)
            vertexBindings:Add(bindingDescription)



            // Define the color blend attachment states, and use default transparency values.
            VulkanPipelineColorBlendAttachmentState colorBlend
            colorBlend:EnableDefaultTransparency()
            colorBlendAttachments:Add(colorBlend)


            // Define the dynamic states permitted by the pipeline. For our case, we want to be able to dynamically adjust viewport and scissor values.
            Array<integer> dynamicStates = info:GetDynamicStates()
            dynamicStates:Add(constants:DYNAMIC_STATE_VIEWPORT)
            dynamicStates:Add(constants:DYNAMIC_STATE_SCISSOR)


            // Create a sampler. We'll use this to access texture information in the shaders.
            VulkanSampler immutableSampler
            VulkanSamplerInfo defaultSamplerInfo
            immutableSampler:Create(device, defaultSamplerInfo)
            me:immutableSampler = immutableSampler


            // Create a structure for the uniforms. We'll need this for the projection matrix (i.e. the camera).
            // Define how our uniforms will be laid out.
            VulkanDescriptorSetLayout descriptorLayout
            Array<VulkanDescriptorSetLayoutBinding> descriptorBindings            

            // Describe the binding of the uniform buffers.
            VulkanDescriptorSetLayoutBinding uniformsBinding
            uniformsBinding:SetBinding(0)
            uniformsBinding:SetDescriptorType(constants:DESCRIPTOR_TYPE_UNIFORM_BUFFER)
            uniformsBinding:SetDescriptorCount(1)
            uniformsBinding:SetStageFlags(constants:SHADER_STAGE_VERTEX_BIT)
            descriptorBindings:Add(uniformsBinding)

            // Describe the binding of the image sampler
            VulkanDescriptorSetLayoutBinding samplerBinding
            samplerBinding:SetBinding(1)
            samplerBinding:SetDescriptorType(constants:DESCRIPTOR_TYPE_SAMPLER)
            samplerBinding:SetDescriptorCount(1)
            samplerBinding:SetStageFlags(constants:SHADER_STAGE_FRAGMENT_BIT)
            Array<VulkanSampler> immutableSamplers
            immutableSamplers:Add(immutableSampler)
            samplerBinding:SetImmutableSamplers(immutableSamplers)
            descriptorBindings:Add(samplerBinding)


            descriptorLayout:Create(device, descriptorBindings)
            descriptorSetLayout = descriptorLayout
            
            Array<VulkanDescriptorSetLayout> descriptorLayouts
            descriptorLayouts:Add(descriptorLayout)

            // We also need the descriptor set layout for the global textures. The texture manager holds onto that layout, so go fetch it.
            GameStateManager manager
            VulkanGraphics graphics = cast(VulkanGraphics, manager:GetGameGraphics())
            VulkanTextureManager textureManager = graphics:GetTextureManager()
            descriptorLayouts:Add(textureManager:GetGlobalTextureDescriptorSetLayout())
            

            VulkanPipelineLayout pipelineLayout = info:GetLayout()
            pipelineLayout:Create(device, descriptorLayouts)
            me:pipelineLayout = pipelineLayout

            // The info structure has lots of other values we could customize, but all of the default values will work well for us here.
            // We can now create the Pipeline itself.
            boolean success = pipeline:Create(device, renderPass, cache, shaders, info)
            
            if success
                defaultPipeline = pipeline
            else
                pipeline:Dispose()
            end

            // Create the buffers for the uniforms. We'll need to know how many images the swapchain has for this.
            // This is because we'll need separate buffers for each swapchain image, so each image can be done in parallel.
            // Once the buffers are made, we can also combine them together with the layouts to create our final DescriptorSets.
            VulkanDescriptorSetManager descriptorSetManager = graphics:GetDescriptorSetManager()

            integer counter = 0
            repeat while counter < graphics:GetSwapchain():GetImageCount()
                // These buffers are for a 4x4 matrix of floats, so 4 bytes * 16 values.
                VulkanBuffer buffer
                buffer:CreateMappableBuffer(device, 4 * 16, constants:BUFFER_USAGE_UNIFORM_BUFFER_BIT)
                cameraBuffers:Add(buffer)

                VulkanNumber32BitMappedMemory mapping = buffer:MapToNumber32BitMemory()
                cameraMappings:Add(mapping)
                output "Added Camera Mapping, size is now " + cameraMappings:GetSize()

                VulkanDescriptorResourcesInfo cameraResourcesInfo
                cameraResourcesInfo:SetDescriptorType(constants:DESCRIPTOR_TYPE_UNIFORM_BUFFER)
                cameraResourcesInfo:AddBufferInfo(cameraBuffers:Get(counter), 0, cameraBuffers:Get(counter):GetSize())
                

                VulkanDescriptorSet set = descriptorSetManager:CreateDescriptorSet(descriptorSetLayout, cameraResourcesInfo)
                cameraDescriptors:Add(set)

                counter = counter + 1
            end
        end

        return defaultPipeline
    end

    private action GetBatch(VulkanPipeline pipeline) returns VulkanPainter2DBatch
        if pipeline = undefined
            output "Getting default pipeline..."
            pipeline = GetDefaultPipeline()
        end

        if batches:HasKey(pipeline)
            // Try to find an existing batch that's available. This will be the most common case.
            Array<VulkanPainter2DBatch> array = batches:GetValue(pipeline)
            integer i = 0
            repeat while i < array:GetSize()
                VulkanPainter2DBatch batch = array:Get(i)
                if not batch:IsFull()
                    return batch
                end

                i = i + 1
            end

            // If there wasn't an available batch, make a new one and add it to the array.
            VulkanPainter2DBatch batch = NewBatch(pipeline)
            array:Add(batch)
            return batch
        else
            // This is our first time using this pipeline. Make an array and a batch for it.
            Array<VulkanPainter2DBatch> array
            VulkanPainter2DBatch batch = NewBatch(pipeline)
            array:Add(batch)
            batches:Add(pipeline, array)
            return batch
        end
    end

    private action NewBatch(VulkanPipeline pipeline) returns VulkanPainter2DBatch
        VulkanPainter2DBatch batch
        batch:Create(pipeline)
        return batch
    end

    private action EndBatches(VulkanCommandBuffer commandBuffer)
        Iterator<Array<VulkanPainter2DBatch>> arrays = batches:GetValueIterator()
        repeat while arrays:HasNext()
            Array<VulkanPainter2DBatch> array = arrays:Next()
            integer i = array:GetSize()
            repeat while i > 0
                i = i - 1

                VulkanPainter2DBatch batch = array:Get(i)
                // If the age is 0, it has been used this frame. Allow it to record any transfer commands it needs.
                if batch:GetAge() = 0
                    batch:TransferBuffers(commandBuffer)
                end
                
                // If the batch hasn't been used, and it isn't the default one, dispose of it to free up memory.
                if batch:GetAge() > maximumAge and (batch:GetPipeline() not= defaultPipeline or i not= 0)
                    batch:Dispose()
                    array:Remove(batch)
                    if array:IsEmpty()
                        batches:RemoveValue(array)
                    end
                else
                    batch:PrepareForNextFrame()
                end
            end
        end
    end

    action SetCamera(Camera camera)
        me:camera = camera
    end
    
    action Begin
        // If the render pass isn't defined and valid, regenerate it.
        // We'll have to determine if this is the first painter in the Game as part of this.
        if not IsRenderPassValid()
            boolean isFirstLayer = false

            Game game = gameState:GetGame()
            Iterator<Layer> layers = game:GetLayerIterator()
            if layers:HasNext()
                Layer layer = layers:Next()
                if layer is Layer2D
                    Layer2D layer2D = cast(Layer2D, layer)
                    isFirstLayer = layer2D:GetPainter():Equals(me)
                end
            end

            RegenerateRenderPass(isFirstLayer)

            // If the default pipeline hasn't been loaded, do so now.
            if defaultPipeline = undefined
                GetDefaultPipeline()
            end
        end

//        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
//        VulkanConstants constants
//
//        VulkanCommandBuffer commandBuffer = graphics:GetCurrentRenderCommandBuffer()
//        VulkanFramebuffer framebuffer = graphics:GetCurrentFramebuffer()
//        VulkanSwapchain swapchain = graphics:GetSwapchain()
//        VulkanClearValue clearValue = graphics:GetClearValue()
//        
//
//
//        // Create the command to begin the render pass.
//        BeginRenderPassCommand beginRenderPass
//        beginRenderPass:SetRenderPass(renderPass)
//        beginRenderPass:SetClearValue(clearValue)
//        beginRenderPass:SetFramebuffer(framebuffer)
//        beginRenderPass:SetRenderArea(swapchain:GetImageWidth(), swapchain:GetImageHeight())
//        commandBuffer:Record(beginRenderPass)
//
////        // NEXT STEP: Bind pipeline command
//////        BindPipelineCommand bindPipeline
//////        bindPipeline:SetPipeline(pipeline)
//
//        // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
//        // Set viewport command
//        // Setting the position to the height and the height to the negated height flips the Y axis of our viewport.
//        SetViewportCommand setViewport
//        setViewport:SetPosition(0, swapchain:GetImageHeight())
//        setViewport:SetSize(swapchain:GetImageWidth(), -swapchain:GetImageHeight())
//        commandBuffer:Record(setViewport)
//
//        // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
//        // Set scissor command
//        SetScissorCommand setScissor
//        setScissor:SetPosition(0, 0)
//        setScissor:SetSize(swapchain:GetImageWidth(), swapchain:GetImageHeight())
//        commandBuffer:Record(setScissor)
    end
    
    action End
        Flush()

        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
        VulkanCommandBuffer commandBuffer = graphics:GetCurrentRenderCommandBuffer()
        VulkanFramebuffer framebuffer = graphics:GetCurrentFramebuffer()
        VulkanSwapchain swapchain = graphics:GetSwapchain()
        VulkanClearValue clearValue = graphics:GetClearValue()
        VulkanConstants constants
        
        /*
        End the batches. This will reset information from the last pass, dispose of any batches that 
        haven't been used in a long time, and record transfer commands from staging buffers to output buffers.
        */
        EndBatches(commandBuffer)

//        output "WARNING: SKIPPING MEMORY BARRIER IN PAINTER 2D"
//        if false and not pendingDrawCommands:IsEmpty()
        if not pendingDrawCommands:IsEmpty()
            // After ending the batches, we need to wait for data transfers to complete before any drawing can occur.
            // Create a memory barrier that ensures that all commands after this must wait for the transfer stage of
            // the pipeline to complete before operations in the vertex input stage can begin.
            VulkanMemoryBarrier memoryBarrier
            memoryBarrier:SetSourceStageMask(constants:PIPELINE_STAGE_TRANSFER_BIT)
            memoryBarrier:SetSourceAccessMask(constants:ACCESS_MEMORY_WRITE_BIT)
            memoryBarrier:SetDestinationStageMask(constants:PIPELINE_STAGE_VERTEX_INPUT_BIT)
            memoryBarrier:SetDestinationAccessMask(constants:ACCESS_MEMORY_READ_BIT)

            PipelineBarrierCommand barrierCommand
            barrierCommand:SetMemoryBarrier(memoryBarrier)
            commandBuffer:Record(barrierCommand)
        end

        integer currentSwapchainIndex = graphics:GetCurrentSwapchainIndex()
        VulkanNumber32BitMappedMemory currentCameraMapping = cameraMappings:Get(currentSwapchainIndex)
        VulkanDescriptorSet currentCameraDescriptor = cameraDescriptors:Get(currentSwapchainIndex)
        
        camera:Update()
        Number32BitArray projectionViewMatrix = MatrixToArray(camera:GetCombinedMatrix())
        currentCameraMapping:Set(projectionViewMatrix)

        VulkanDescriptorSet texturesDescriptorSet = graphics:GetTextureManager():GetGlobalTextureDescriptorSet()
        

        // Create the command to begin the render pass.
        BeginRenderPassCommand beginRenderPass
        beginRenderPass:SetRenderPass(renderPass)
        beginRenderPass:SetClearValue(clearValue)
        beginRenderPass:SetFramebuffer(framebuffer)
        beginRenderPass:SetRenderArea(swapchain:GetImageWidth(), swapchain:GetImageHeight())
        commandBuffer:Record(beginRenderPass)

//        // NEXT STEP: Bind pipeline command
////        BindPipelineCommand bindPipeline
////        bindPipeline:SetPipeline(pipeline)

        // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
        // Set viewport command
        // Setting the position to the height and the height to the negated height flips the Y axis of our viewport.
//        SetViewportCommand setViewport
//        setViewport:SetPosition(0, swapchain:GetImageHeight())
//        setViewport:SetSize(swapchain:GetImageWidth(), -swapchain:GetImageHeight())
//        commandBuffer:Record(setViewport)
//
//        // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
//        // Set scissor command
//        SetScissorCommand setScissor
//        setScissor:SetPosition(0, 0)
//        setScissor:SetSize(swapchain:GetImageWidth(), swapchain:GetImageHeight())
//        commandBuffer:Record(setScissor)
    
        // Set the pipelines and send the corresponding draw calls.
        integer i = 0
        repeat while i < pendingBatches:GetSize()
            VulkanPainter2DBatch batch = pendingBatches:Get(i)
            DrawIndexedCommand drawCommand = pendingDrawCommands:Get(i)

            BindPipelineCommand bindPipeline
            bindPipeline:SetPipeline(batch:GetPipeline())
            commandBuffer:Record(bindPipeline)

            // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
            SetViewportCommand setViewport
            setViewport:SetPosition(0, swapchain:GetImageHeight())
            setViewport:SetSize(swapchain:GetImageWidth(), -swapchain:GetImageHeight())
            commandBuffer:Record(setViewport)
    
            // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
            // Set scissor command
            SetScissorCommand setScissor
            setScissor:SetPosition(0, 0)
            setScissor:SetSize(swapchain:GetImageWidth(), swapchain:GetImageHeight())
            commandBuffer:Record(setScissor)

            BindVertexBufferCommand vertexBind
            vertexBind:SetBuffer(batch:GetVertexOutputBuffer())
            commandBuffer:Record(vertexBind)

            BindIndexBufferCommand indexBind
            indexBind:SetBuffer(batch:GetIndexOutputBuffer())
            commandBuffer:Record(indexBind)

            BindDescriptorSetCommand descriptorBind
            descriptorBind:SetPipelineLayout(pipelineLayout)
            descriptorBind:SetDescriptorSet(currentCameraDescriptor)
            commandBuffer:Record(descriptorBind)

            BindDescriptorSetCommand texturesBind
            texturesBind:SetPipelineLayout(pipelineLayout)
            texturesBind:SetDescriptorSet(texturesDescriptorSet)
            texturesBind:SetSetIndex(1)
            commandBuffer:Record(texturesBind)

            commandBuffer:Record(drawCommand)

            i = i + 1
        end

        // End the render pass.
        EndRenderPassCommand endRenderPass
        commandBuffer:Record(endRenderPass)

        // Set the current batch to undefined, to ensure we're starting with a clean slate again next time.
        currentBatch = undefined

        // Empty the pending arrays.
        pendingDrawCommands:Empty(false)
        pendingBatches:Empty(false)
    end
    
    action SetClipping(boolean clippingEnabled)
//        output "NYI: VulkanPainter2D SetClipping"
//        alert("NYI")
    end
    
    action SetColor(Color color)
//        output "NYI: VulkanPainter2D SetColor"
//        alert("NYI")
    end
    
    action SetColor(number red, number green, number blue, number alpha)
//        output "NYI: VulkanPainter2D SetColor(2)"
//        alert("NYI")
    end
    
    action QueueForDrawing(Item2D item)
        if not (item is Drawable)
            return now
        end

        Drawable drawable = cast(Drawable, item)
        DrawableShape shape = drawable:GetDrawableShape()

        if not shape:IsRenderable()
            return now
        end

        if shape:NeedsUpdate()
            shape:UpdateVertices()
        elseif shape:AreTextureVerticesValid() = false
            shape:UpdateTextureVertices()
        end

        if shape:AreTextureVerticesValid() = false
//            output "Invalid texture vertices for " + item:GetName() + "!"
            return now
        end

        // TO-DO: Check if the Item has a specific pipeline it needs for rendering.
        VulkanPipeline requestedPipeline = undefined

        if requestedPipeline = undefined
            requestedPipeline = defaultPipeline
        end

        if currentBatch = undefined or currentBatch:GetPipeline() not= requestedPipeline
            Flush()
            currentBatch = GetBatch(requestedPipeline)
            currentBatch:ResetAge()
            currentStartIndex = currentBatch:GetIndexWritePosition()
        end

        currentBatch:Add(drawable:GetDrawableShape())
    end

    private action Flush
        if currentBatch = undefined
            return now
        end

        DrawIndexedCommand drawCommand
        drawCommand:SetFirstIndex(currentStartIndex)
        drawCommand:SetIndexCount(currentBatch:GetIndexWritePosition() - currentStartIndex)
        pendingDrawCommands:Add(drawCommand)
        pendingBatches:Add(currentBatch)
    end
    
    action Draw(Drawable drawable)
//        output "NYI: VulkanPainter2D Draw"
//        alert("NYI")
    end
    
    action SetClipCoordinates(number x, number y, number width, number height)
//        output "NYI: VulkanPainter2D SetClipCoordinates"
//        alert("NYI")
    end

    private action MatrixToArray(Matrix4 matrix) returns Number32BitArray
        matrix4Array:Set(0, matrix:row0column0)
        matrix4Array:Set(1, matrix:row1column0)
        matrix4Array:Set(2, matrix:row2column0)
        matrix4Array:Set(3, matrix:row3column0)
        matrix4Array:Set(4, matrix:row0column1)
        matrix4Array:Set(5, matrix:row1column1)
        matrix4Array:Set(6, matrix:row2column1)
        matrix4Array:Set(7, matrix:row3column1)
        matrix4Array:Set(8, matrix:row0column2)
        matrix4Array:Set(9, matrix:row1column2)
        matrix4Array:Set(10, matrix:row2column2)
        matrix4Array:Set(11, matrix:row3column2)
        matrix4Array:Set(12, matrix:row0column3)
        matrix4Array:Set(13, matrix:row1column3)
        matrix4Array:Set(14, matrix:row2column3)
        matrix4Array:Set(15, matrix:row3column3)
        return matrix4Array
    end

end