package Libraries.Game.Graphics.Vulkan

use Libraries.Interface.Item2D
use Libraries.Game.Graphics.Painter2D
use Libraries.Game.Graphics.Camera
use Libraries.Game.Graphics.Drawable
use Libraries.Game.Graphics.Color
use Libraries.Containers.Array
use Libraries.Game.GameStateManager
use Libraries.Game.Graphics.Vulkan.Commands.all
use Libraries.Game.Game
use Libraries.Containers.Iterator
use Libraries.Game.Layer
use Libraries.Game.Layer2D
use Libraries.Game.Graphics.Shaders.Shader
use Libraries.Game.Graphics.Shaders.ShaderManager
use Libraries.Containers.Number32BitArray
use Libraries.Containers.Integer32BitArray
use Libraries.Containers.HashTable
use Libraries.Game.Graphics.DrawableShape
use Libraries.Compute.Matrix4
use Libraries.Game.Graphics.Shaders.ShaderProgram
use Libraries.Game.Graphics.Shaders.Vulkan.VulkanShaderProgram
use Libraries.Game.Graphics.Shaders.Vulkan.Mapping.VulkanShaderMapping

class VulkanPainter2D is Painter2D

    GameStateManager gameState
    VulkanRenderPass renderPass = undefined
    ShaderProgram defaultProgram = undefined

    /*
    A hash table storing the batch(es) associated with a particular program and pipeline.
    Each pipeline uses its own buffers for vertices and indices. Each array will
    likely only have one element, but it's possible that there will be multiple
    if more elements need to be rendered with one pipeline than can fit in a single batch.
    */
    HashTable<ShaderProgram, Array<VulkanPainter2DBatch>> batches

    // The current batch being used.
    VulkanPainter2DBatch currentBatch = undefined
    // The first index from the IndexData to be drawn for the currentBatch. Used when recording upcoming draw commands.
    integer currentStartIndex = 0

    // The maximum number of frames to allow a batch to remain without being used before it should be disposed to free up memory.
    integer maximumAge = 180

    // Draw commands that will be queued into a buffer.
    // These are stored to be used later because buffer transfer commands need to be processed before these, but we won't know
    // how much data needs to be transferred until we're done looking at all the data. 
    Array<DrawIndexedCommand> pendingDrawCommands
    // A parallel array of batches. The n-th draw command uses the vertex and index buffers from the n-th pending batch.
    Array<VulkanPainter2DBatch> pendingBatches

    Camera camera = undefined

    action IsRenderPassValid returns boolean
        return renderPass not= undefined
    end

    action RegenerateRenderPass(boolean isFirstPass) returns boolean
        if renderPass not= undefined
            renderPass:Dispose()
        end

        VulkanRenderPass pass
        renderPass = pass

        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
        VulkanConstants constants

        /*
        Create the RenderPass that will be used for this painter. 
        This must be compatible with the render pass used for the swapchain Framebuffers.
        The RenderPass provided to the Framebuffers will indicate how rendering to the buffers will be performed. Pipelines using the
        Framebuffers must either exactly match the RenderPass, or be compatible with it. More details here:
        https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap8.html#renderpass-compatibility
        */
        VulkanAttachmentDescription outputColorAttachment
        outputColorAttachment:SetFormat(graphics:GetSwapchain():GetImageViewInfo():GetFormat())
        outputColorAttachment:SetSamples(constants:SAMPLE_COUNT_1_BIT)
        outputColorAttachment:SetStoreOp(constants:ATTACHMENT_STORE_OP_STORE)
        outputColorAttachment:SetInitialLayout(constants:IMAGE_LAYOUT_UNDEFINED)
        outputColorAttachment:SetFinalLayout(constants:IMAGE_LAYOUT_PRESENT_SOURCE)

        if isFirstPass
            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_CLEAR)
        else
//            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_LOAD)
            output "NOTE: Hard-setting attachment load op to CLEAR during testing..."
            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_CLEAR)
        end

        Array<VulkanAttachmentDescription> attachmentDescriptions
        attachmentDescriptions:Add(outputColorAttachment)


        VulkanAttachmentReference outputColorReference
        outputColorReference:SetAttachmentIndex(0)
        outputColorReference:SetLayout(constants:IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)

        Array<VulkanAttachmentReference> attachmentReferences
        attachmentReferences:Add(outputColorReference)


        VulkanSubpassDescription subpass
        subpass:SetPipelineBindPoint(constants:PIPELINE_BIND_POINT_GRAPHICS)
        subpass:SetColorAttachments(attachmentReferences)

        Array<VulkanSubpassDescription> subpassDescriptions
        subpassDescriptions:Add(subpass)

        
        VulkanSubpassDependency dependency
        dependency:SetSourceSubpass(constants:SUBPASS_EXTERNAL)
        dependency:SetDestinationSubpass(0)
        dependency:SetSourceStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetDestinationStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetSourceAccessMask(0)
        dependency:SetDestinationAccessMask(constants:ACCESS_COLOR_ATTACHMENT_WRITE_BIT)

        Array<VulkanSubpassDependency> subpassDependencies
        subpassDependencies:Add(dependency)


        boolean success = renderPass:Create(graphics:GetDevice(), attachmentDescriptions, subpassDescriptions, subpassDependencies)
        output "Painter: Created RenderPass, success = " + success
        return success
    end
    
    action GetDefaultProgram returns ShaderProgram
        if defaultProgram = undefined
            ShaderManager shaders = gameState:GetShaderManager()
            defaultProgram = shaders:GetDefaultShaderProgram2D()
        end
        
        return defaultProgram
    end
    
    action GetDefaultPipeline returns VulkanPipeline
        ShaderProgram program = GetDefaultProgram()
        VulkanShaderProgram strategy = cast(VulkanShaderProgram, program:GetShaderProgramStrategy())
        return strategy:GetPipeline()
    end

    private action GetBatch(ShaderProgram program) returns VulkanPainter2DBatch
        if program = undefined
            program = GetDefaultProgram()
        end

        if batches:HasKey(program)
            // Try to find an existing batch that's available. This will be the most common case.
            Array<VulkanPainter2DBatch> array = batches:GetValue(program)
            integer i = 0
            repeat while i < array:GetSize()
                VulkanPainter2DBatch batch = array:Get(i)
                if not batch:IsFull()
                    return batch
                end

                i = i + 1
            end

            // If there wasn't an available batch, make a new one and add it to the array.
            VulkanPainter2DBatch batch = NewBatch(program)
            array:Add(batch)
            return batch
        else
            // This is our first time using this pipeline. Make an array and a batch for it.
            Array<VulkanPainter2DBatch> array
            VulkanPainter2DBatch batch = NewBatch(program)
            array:Add(batch)
            batches:Add(program, array)
            return batch
        end
    end

    private action NewBatch(ShaderProgram program) returns VulkanPainter2DBatch
        VulkanPainter2DBatch batch
        batch:Create(program)
        return batch
    end

    private action EndBatches(VulkanCommandBuffer commandBuffer)
        Iterator<Array<VulkanPainter2DBatch>> arrays = batches:GetValueIterator()
        VulkanPipeline defaultPipeline = GetDefaultPipeline()
        repeat while arrays:HasNext()
            Array<VulkanPainter2DBatch> array = arrays:Next()
            integer i = array:GetSize()
            repeat while i > 0
                i = i - 1

                VulkanPainter2DBatch batch = array:Get(i)
                // If the age is 0, it has been used this frame. Allow it to record any transfer commands it needs.
                if batch:GetAge() = 0
                    batch:TransferBuffers(commandBuffer)
                end
                
                // If the batch hasn't been used, and it isn't the default one, dispose of it to free up memory.
                if batch:GetAge() > maximumAge and (batch:GetPipeline() not= defaultPipeline or i not= 0)
                    batch:Dispose()
                    array:Remove(batch)
                    if array:IsEmpty()
                        batches:RemoveValue(array)
                    end
                else
                    batch:PrepareForNextFrame()
                end
            end
        end
    end

    action SetCamera(Camera camera)
        me:camera = camera
    end
    
    action Begin
        // If the render pass isn't defined and valid, regenerate it.
        // We'll have to determine if this is the first painter in the Game as part of this.
        if not IsRenderPassValid()
            boolean isFirstLayer = false

            Game game = gameState:GetGame()
            Iterator<Layer> layers = game:GetLayerIterator()
            if layers:HasNext()
                Layer layer = layers:Next()
                if layer is Layer2D
                    Layer2D layer2D = cast(Layer2D, layer)
                    isFirstLayer = layer2D:GetPainter():Equals(me)
                end
            end

            RegenerateRenderPass(isFirstLayer)

            // If the default program hasn't been loaded, do so now.
            if defaultProgram = undefined
                GetDefaultProgram()
            end
        end
    end
    
    action End
        Flush()

        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
        VulkanCommandBuffer commandBuffer = graphics:GetCurrentRenderCommandBuffer()
        VulkanFramebuffer framebuffer = graphics:GetCurrentFramebuffer()
        VulkanSwapchain swapchain = graphics:GetSwapchain()
        VulkanClearValue clearValue = graphics:GetClearValue()
        VulkanConstants constants
        
        /*
        End the batches. This will reset information from the last pass, dispose of any batches that 
        haven't been used in a long time, and record transfer commands from staging buffers to output buffers.
        */
        EndBatches(commandBuffer)

        if not pendingDrawCommands:IsEmpty()
            // After ending the batches, we need to wait for data transfers to complete before any drawing can occur.
            // Create a memory barrier that ensures that all commands after this must wait for the transfer stage of
            // the pipeline to complete before operations in the vertex input stage can begin.
            VulkanMemoryBarrier memoryBarrier
            memoryBarrier:SetSourceStageMask(constants:PIPELINE_STAGE_TRANSFER_BIT)
            memoryBarrier:SetSourceAccessMask(constants:ACCESS_MEMORY_WRITE_BIT)
            memoryBarrier:SetDestinationStageMask(constants:PIPELINE_STAGE_VERTEX_INPUT_BIT)
            memoryBarrier:SetDestinationAccessMask(constants:ACCESS_MEMORY_READ_BIT)

            PipelineBarrierCommand barrierCommand
            barrierCommand:SetMemoryBarrier(memoryBarrier)
            commandBuffer:Record(barrierCommand)
        end

        integer currentSwapchainIndex = graphics:GetCurrentSwapchainIndex()
        
        camera:Update()

        // Create the command to begin the render pass.
        BeginRenderPassCommand beginRenderPass
        beginRenderPass:SetRenderPass(renderPass)
        beginRenderPass:SetClearValue(clearValue)
        beginRenderPass:SetFramebuffer(framebuffer)
        beginRenderPass:SetRenderArea(swapchain:GetImageWidth(), swapchain:GetImageHeight())
        commandBuffer:Record(beginRenderPass)

        ShaderProgram currentProgram = undefined
        VulkanPipeline currentPipeline = undefined
    
        // Set the pipelines and send the corresponding draw calls.
        integer i = 0
        repeat while i < pendingBatches:GetSize()
            VulkanPainter2DBatch batch = pendingBatches:Get(i)
            DrawIndexedCommand drawCommand = pendingDrawCommands:Get(i)
            
            if currentProgram not= batch:GetProgram()
                if currentProgram not= undefined
                    currentProgram:End()
                end
                
                currentProgram = batch:GetProgram()
                currentPipeline = batch:GetPipeline()
                
BindPipelineCommand bindPipeline
            bindPipeline:SetPipeline(batch:GetPipeline())
            commandBuffer:Record(bindPipeline)
                
            end

            // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
            SetViewportCommand setViewport
            setViewport:SetPosition(0, swapchain:GetImageHeight())
            setViewport:SetSize(swapchain:GetImageWidth(), -swapchain:GetImageHeight())
            commandBuffer:Record(setViewport)
    
            // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
            // Set scissor command
            SetScissorCommand setScissor
            setScissor:SetPosition(0, 0)
            setScissor:SetSize(swapchain:GetImageWidth(), swapchain:GetImageHeight())
            commandBuffer:Record(setScissor)

            BindVertexBufferCommand vertexBind
            vertexBind:SetBuffer(batch:GetVertexOutputBuffer())
            commandBuffer:Record(vertexBind)

            BindIndexBufferCommand indexBind
            indexBind:SetBuffer(batch:GetIndexOutputBuffer())
            commandBuffer:Record(indexBind)

            // Once the batches have loaded their vertex and index buffers, allow the shader mapping to submit commands to bind descriptors.
            VulkanShaderMapping mapping = cast(VulkanShaderMapping, currentProgram:GetShaderMapping())
            mapping:Begin(currentProgram, camera, commandBuffer, currentSwapchainIndex)

            commandBuffer:Record(drawCommand)

            i = i + 1
        end

        // End the render pass.
        EndRenderPassCommand endRenderPass
        commandBuffer:Record(endRenderPass)

        // Set the current batch to undefined, to ensure we're starting with a clean slate again next time.
        currentBatch = undefined

        // Empty the pending arrays.
        pendingDrawCommands:Empty(false)
        pendingBatches:Empty(false)
    end
    
    action SetClipping(boolean clippingEnabled)
//        output "NYI: VulkanPainter2D SetClipping"
//        alert("NYI")
    end
    
    action SetColor(Color color)
//        output "NYI: VulkanPainter2D SetColor"
//        alert("NYI")
    end
    
    action SetColor(number red, number green, number blue, number alpha)
//        output "NYI: VulkanPainter2D SetColor(2)"
//        alert("NYI")
    end
    
    action QueueForDrawing(Item2D item)
        if not (item is Drawable)
            return now
        end

        Drawable drawable = cast(Drawable, item)
        DrawableShape shape = drawable:GetDrawableShape()

        if not shape:IsRenderable()
            return now
        end

        if shape:NeedsUpdate()
            shape:UpdateVertices()
        elseif shape:AreTextureVerticesValid() = false
            shape:UpdateTextureVertices()
        end

        if shape:AreTextureVerticesValid() = false
//            output "Invalid texture vertices for " + item:GetName() + "!"
            return now
        end

        // TO-DO: Check if the Item has a specific pipeline it needs for rendering.
        ShaderProgram requestedProgram = drawable:GetShaderProgram()

        if requestedProgram = undefined
            requestedProgram = defaultProgram
        end
        VulkanShaderProgram vulkanProgram = cast(VulkanShaderProgram, requestedProgram:GetShaderProgramStrategy())
        
        if vulkanProgram:GetPipeline() = undefined
            vulkanProgram:CreatePipeline(renderPass)
        end

        if currentBatch = undefined or currentBatch:GetProgram() not= requestedProgram
            Flush()
            currentBatch = GetBatch(requestedProgram)
            currentBatch:ResetAge()
            currentStartIndex = currentBatch:GetIndexWritePosition()
        end

        currentBatch:Add(drawable:GetDrawableShape())
    end

    private action Flush
        if currentBatch = undefined
            return now
        end

        DrawIndexedCommand drawCommand
        drawCommand:SetFirstIndex(currentStartIndex)
        drawCommand:SetIndexCount(currentBatch:GetIndexWritePosition() - currentStartIndex)
        pendingDrawCommands:Add(drawCommand)
        pendingBatches:Add(currentBatch)
    end
    
    action Draw(Drawable drawable)
//        output "NYI: VulkanPainter2D Draw"
//        alert("NYI")
    end
    
    action SetClipCoordinates(number x, number y, number width, number height)
//        output "NYI: VulkanPainter2D SetClipCoordinates"
//        alert("NYI")
    end

end