package Libraries.Game.Graphics.Vulkan

use Libraries.Interface.Item2D
use Libraries.Game.Graphics.Painter2D
use Libraries.Game.Graphics.Camera
use Libraries.Game.Graphics.Drawable
use Libraries.Game.Graphics.Color
use Libraries.Containers.Array
use Libraries.Game.GameStateManager
use Libraries.Game.Graphics.Vulkan.Commands.all
use Libraries.Game.Game
use Libraries.Containers.Iterator
use Libraries.Game.Layer
use Libraries.Game.Layer2D
use Libraries.Game.Graphics.Shaders.Shader
use Libraries.Game.Graphics.Shaders.ShaderManager
use Libraries.Game.Graphics.Shaders.Vulkan.VulkanShaderManager
use Libraries.Containers.Number32BitArray
use Libraries.Containers.Integer32BitArray

class VulkanPainter2D is Painter2D

    GameStateManager gameState
    VulkanRenderPass renderPass = undefined

    VulkanPipeline defaultPipeline = undefined
    VulkanPipeline boundPipeline = undefined

    // The default index buffer size is enough for 
    public constant integer INDEX_BUFFER_SIZE = 2000 * 6

    // Arrays containing pending vertex and index data. To be copied into the staging buffers before drawing.
    Number32BitArray vertexData
    Integer32BitArray indexData

    // Staging buffers. These are accessible from the host (i.e., directly from this code) and will be copied into GPU-exclusive memory.
    VulkanBuffer vertexStagingBuffer
    VulkanBuffer indexStagingBuffer

    // Output buffers, only accessible to GPU memory. These hold the final information to be rendered.
    VulkanBuffer vertexOutputBuffer
    VulkanBuffer indexOutputBuffer

    // The current range of indices containing vertex/index information to be drawn.
    integer verticesStartIndex = 0
    integer verticesEndIndex = 0
    integer indexStartIndex = 0
    integer indexEndIndex = 0

    on create
        LoadDefaultPainter()
    end

    action IsRenderPassValid returns boolean
        return renderPass not= undefined
    end

    action RegenerateRenderPass(boolean isFirstPass) returns boolean
        if renderPass not= undefined
            renderPass:Dispose()
        end

        VulkanRenderPass pass
        renderPass = pass

        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
        VulkanConstants constants

        /*
        Create the RenderPass that will be used for this painter. 
        This must be compatible with the render pass used for the swapchain Framebuffers.
        The RenderPass provided to the Framebuffers will indicate how rendering to the buffers will be performed. Pipelines using the
        Framebuffers must either exactly match the RenderPass, or be compatible with it. More details here:
        https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap8.html#renderpass-compatibility
        */
        VulkanAttachmentDescription outputColorAttachment
        outputColorAttachment:SetFormat(graphics:GetSwapchain():GetImageViewInfo():GetFormat())
        outputColorAttachment:SetSamples(constants:SAMPLE_COUNT_1_BIT)
        outputColorAttachment:SetStoreOp(constants:ATTACHMENT_STORE_OP_STORE)
        outputColorAttachment:SetInitialLayout(constants:IMAGE_LAYOUT_UNDEFINED)
        outputColorAttachment:SetFinalLayout(constants:IMAGE_LAYOUT_PRESENT_SOURCE)

        if isFirstPass
            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_CLEAR)
        else
//            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_LOAD)
            output "NOTE: Hard-setting attachment load op to CLEAR during testing..."
            outputColorAttachment:SetLoadOp(constants:ATTACHMENT_LOAD_OP_CLEAR)
        end

        Array<VulkanAttachmentDescription> attachmentDescriptions
        attachmentDescriptions:Add(outputColorAttachment)


        VulkanAttachmentReference outputColorReference
        outputColorReference:SetAttachmentIndex(0)
        outputColorReference:SetLayout(constants:IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)

        Array<VulkanAttachmentReference> attachmentReferences
        attachmentReferences:Add(outputColorReference)


        VulkanSubpassDescription subpass
        subpass:SetPipelineBindPoint(constants:PIPELINE_BIND_POINT_GRAPHICS)
        subpass:SetColorAttachments(attachmentReferences)

        Array<VulkanSubpassDescription> subpassDescriptions
        subpassDescriptions:Add(subpass)

        
        VulkanSubpassDependency dependency
        dependency:SetSourceSubpass(constants:SUBPASS_EXTERNAL)
        dependency:SetDestinationSubpass(0)
        dependency:SetSourceStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetDestinationStageMask(constants:PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
        dependency:SetSourceAccessMask(0)
        dependency:SetDestinationAccessMask(constants:ACCESS_COLOR_ATTACHMENT_WRITE_BIT)

        Array<VulkanSubpassDependency> subpassDependencies
        subpassDependencies:Add(dependency)


        boolean success = renderPass:Create(graphics:GetDevice(), attachmentDescriptions, subpassDescriptions, subpassDependencies)
        output "Painter: Created RenderPass, success = " + success
        return success
    end

    private action LoadDefaultPainter
        // Load a default structure for vertices or other GPU info here?

        
    end

    private action GetDefaultPipeline returns VulkanPipeline
        if defaultPipeline = undefined
            VulkanPipeline pipeline

            VulkanShaderManager shaderManager = cast(VulkanShaderManager, gameState:GetShaderManager())
            Shader vertexShader = shaderManager:GetDefaultVertexShader2D()
            Shader fragmentShader = shaderManager:GetDefaultFragmentShader2D()

            Array<Shader> shaders
            shaders:Add(vertexShader)
            shaders:Add(fragmentShader)

            VulkanDevice device = renderPass:GetDevice()
            VulkanPipelineCache cache = shaderManager:GetPipelineCache()
            VulkanConstants constants



            VulkanPipelineInfo info
            Array<VulkanVertexInputAttributeDescription> vertexAttributes = info:GetVertexInputAttributeDescriptions()
            Array<VulkanVertexInputBindingDescription> vertexBindings = info:GetVertexInputBindingDescriptions()
            Array<VulkanPipelineColorBlendAttachmentState> colorBlendAttachments = info:GetPipelineColorBlendAttachmentStates()

            // Create the vertex attribute descriptions, and the binding that will indicate how far apart each vertex's data is in the buffers.
    
            // How far into the data structure the current piece of data is.
            integer offset = 0

            // Position attribute
            VulkanVertexInputAttributeDescription positionAttribute
            positionAttribute:Set(0, 0, constants:FORMAT_R32G32B32_SFLOAT, offset)
            vertexAttributes:Add(positionAttribute)

            // Position is stored as 3 floats of 4 bytes each.
            offset = offset + (3 * 4)


            /*
            // Texture coordinate attribute
            VulkanVertexInputAttributeDescription textureCoordinatesAttribute
            textureCoordinatesAttribute:Set(0, 1, constants:FORMAT_R32G32_SFLOAT, 3 * 4)
            vertexAttributes:Add(textureCoordinatesAttribute)

            // Texture coordinates are stored as 2 floats of 4 bytes each.
            offset = offset + (2 * 4)
            */
            
            // Binding description, indicates how far apart each vertex's data is
            VulkanVertexInputBindingDescription bindingDescription
            bindingDescription:Set(0, offset, constants:VERTEX_INPUT_RATE_VERTEX)
            vertexBindings:Add(bindingDescription)



            // Define the color blend attachment states. Just creating and adding it is enough, the default values work for us.
            VulkanPipelineColorBlendAttachmentState colorBlend
            colorBlendAttachments:Add(colorBlend)


            // Define the dynamic states permitted by the pipeline. For our case, we want to be able to dynamically adjust viewport and scissor values.
            Array<integer> dynamicStates = info:GetDynamicStates()
            dynamicStates:Add(constants:DYNAMIC_STATE_VIEWPORT)
            dynamicStates:Add(constants:DYNAMIC_STATE_SCISSOR)


            // The info structure has lots of other values we could customize, but all of the default values will work well for us here.
            // We can now create the Pipeline itself.
            boolean success = pipeline:Create(device, renderPass, cache, shaders, info)
            
            if success
                defaultPipeline = pipeline
            else
                pipeline:Dispose()
            end
        end

        return defaultPipeline
    end

    action SetCamera(Camera camera)
//        output "NYI: VulkanPainter2D SetCamera"
//        alert("NYI")
    end
    
    action Begin
        // If the render pass isn't defined and valid, regenerate it.
        // We'll have to determine if this is the first painter in the Game as part of this.
        if not IsRenderPassValid()
            boolean isFirstLayer = false

            Game game = gameState:GetGame()
            Iterator<Layer> layers = game:GetLayerIterator()
            if layers:HasNext()
                Layer layer = layers:Next()
                if layer is Layer2D
                    Layer2D layer2D = cast(Layer2D, layer)
                    isFirstLayer = layer2D:GetPainter():Equals(me)
                end
            end

            RegenerateRenderPass(isFirstLayer)
        end

        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
        VulkanConstants constants

        VulkanCommandBuffer commandBuffer = graphics:GetCurrentRenderCommandBuffer()
        VulkanFramebuffer framebuffer = graphics:GetCurrentFramebuffer()
        VulkanSwapchain swapchain = graphics:GetSwapchain()
        VulkanClearValue clearValue = graphics:GetClearValue()
        


        // Create the command to begin the render pass.
        BeginRenderPassCommand beginRenderPass
        beginRenderPass:SetRenderPass(renderPass)
        beginRenderPass:SetClearValue(clearValue)
        beginRenderPass:SetFramebuffer(framebuffer)
        beginRenderPass:SetRenderArea(swapchain:GetImageWidth(), swapchain:GetImageHeight())
        commandBuffer:Record(beginRenderPass)

//        // NEXT STEP: Bind pipeline command
////        BindPipelineCommand bindPipeline
////        bindPipeline:SetPipeline(pipeline)

        // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
        // Set viewport command
        // Setting the position to the height and the height to the negated height flips the Y axis of our viewport.
        SetViewportCommand setViewport
        setViewport:SetPosition(0, swapchain:GetImageHeight())
        setViewport:SetSize(swapchain:GetImageWidth(), -swapchain:GetImageHeight())
        commandBuffer:Record(setViewport)

        // TO-DO: CHANGE THIS DYNAMICALLY FOR RENDERED CONTENT
        // Set scissor command
        SetScissorCommand setScissor
        setScissor:SetPosition(0, 0)
        setScissor:SetSize(swapchain:GetImageWidth(), swapchain:GetImageHeight())
        commandBuffer:Record(setScissor)
    end
    
    action End
        VulkanGraphics graphics = cast(VulkanGraphics, gameState:GetGameGraphics())
        VulkanCommandBuffer commandBuffer = graphics:GetCurrentRenderCommandBuffer()

        // End the render pass.
        EndRenderPassCommand endRenderPass
        commandBuffer:Record(endRenderPass)
    end
    
    action SetClipping(boolean clippingEnabled)
//        output "NYI: VulkanPainter2D SetClipping"
//        alert("NYI")
    end
    
    action SetColor(Color color)
//        output "NYI: VulkanPainter2D SetColor"
//        alert("NYI")
    end
    
    action SetColor(number red, number green, number blue, number alpha)
//        output "NYI: VulkanPainter2D SetColor(2)"
//        alert("NYI")
    end
    
    action QueueForDrawing(Item2D item)
        /*
        NEXT STEPS:
        Queued items are checked for which Pipeline to use (currently, always default)
        If different than previous, flush, bind pipeline
        Add vertex/index values to end of buffers
        In "End" call, flush, unbind pipeline
        Flush: Draw commands
        */

//        output "NYI: VulkanPainter2D QueueForDrawing"
//        alert("NYI")
    end
    
    action Draw(Drawable drawable)
//        output "NYI: VulkanPainter2D Draw"
//        alert("NYI")
    end
    
    action SetClipCoordinates(number x, number y, number width, number height)
//        output "NYI: VulkanPainter2D SetClipCoordinates"
//        alert("NYI")
    end

end