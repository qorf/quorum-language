package Libraries.Game.Graphics.Vulkan
use Libraries.Containers.Number32BitArray
use Libraries.Containers.Integer32BitArray
use Libraries.Game.Graphics.Integer32BitBuffer
use Libraries.Game.Graphics.DrawableShape
use Libraries.Game.Graphics.Vulkan.Commands.CopyBufferCommand

/*
This class encapsulates a series of buffers and arrays used to batch a large number of drawn elements all at once.
This class is used by the VulkanPainter2D to organize resources used by different pipelines, or to handle overflow
elements if there are too many to be stored in a single buffer.
*/
class VulkanPainter2DBatch

    public constant integer DEFAULT_VERTEX_BUFFER_SIZE = 120000
    public constant integer DEFAULT_INDEX_BUFFER_SIZE = 30000
    public constant integer DEFAULT_VERTEX_BUFFER_BYTE_SIZE = DEFAULT_VERTEX_BUFFER_SIZE * 4
    public constant integer DEFAULT_INDEX_BUFFER_BYTE_SIZE = DEFAULT_INDEX_BUFFER_SIZE * 4

    // Arrays of information that will be bulk-copied into the staging buffers later.
    Number32BitArray vertexData = undefined
    Integer32BitArray indexData = undefined

    // Staging buffers are visible from the host (i.e. they're mapped to memory we can access from this code).
    // We use these to put our vertex and index data into, then copy them to the output buffers before drawing.
    VulkanBuffer vertexStagingBuffer = undefined
    VulkanBuffer indexStagingBuffer = undefined

    // The mapped memory is the allocated space that the staging buffers encapsulate. This is where the vertex/index data are copied
    // to send the information where the staging buffers can use them.
    VulkanNumber32BitMappedMemory vertexMappedMemory = undefined
    VulkanInteger32BitMappedMemory indexMappedMemory = undefined

    // Output buffers that are allocated onto GPU-exclusive memory. Used for final drawing.
    VulkanBuffer vertexOutputBuffer = undefined
    VulkanBuffer indexOutputBuffer = undefined

    // The position that the next chunk of data will be written to the vertex/input data arrays.
    // Set to 0 at the beginning of a frame of animation, and incremented as data is written.
    // Also indicates the size of the content that's already been written (i.e., if the position is 6, then index
    // 6 is the next to be written, and it also means 6 pieces of data have already been written into slots 0 - 5)
    integer vertexWritePosition = 0
    integer indexWritePosition = 0

    // The count of how many vertices have been inserted, and also an index representing the next vertex to be inserted.
    integer verticesCount = 0

    boolean isFull = false

    // The VulkanPipeline associated with this batch.
    VulkanPipeline pipeline = undefined

    // How many frames have passed without using this batch. Can be used to determine if a batch hasn't been used in a long time and can be disposed.
    integer age = 0

    action Create(VulkanPipeline pipeline)
        Create(pipeline, DEFAULT_VERTEX_BUFFER_SIZE, DEFAULT_INDEX_BUFFER_SIZE)
    end

    action Create(VulkanPipeline pipeline, integer vertexBufferSize, integer indexBufferSize)
        me:pipeline = pipeline
        VulkanDevice device = pipeline:GetDevice()

        Number32BitArray vertexData
        Integer32BitArray indexData
        VulkanBuffer vertexStagingBuffer
        VulkanBuffer indexStagingBuffer
        VulkanBuffer vertexOutputBuffer
        VulkanBuffer indexOutputBuffer

        me:vertexData = vertexData
        me:indexData = indexData
        me:vertexStagingBuffer = vertexStagingBuffer
        me:indexStagingBuffer = indexStagingBuffer
        me:vertexOutputBuffer = vertexOutputBuffer
        me:indexOutputBuffer = indexOutputBuffer

        VulkanConstants constants

        vertexData:SetSize(vertexBufferSize)
        indexData:SetSize(indexBufferSize)
        vertexStagingBuffer:CreateTransferSourceBuffer(device, vertexBufferSize * 4)
        indexStagingBuffer:CreateTransferSourceBuffer(device, indexBufferSize * 4)
        vertexOutputBuffer:CreateTransferDestinationBuffer(device, vertexBufferSize * 4, constants:BUFFER_USAGE_VERTEX_BUFFER_BIT)
        indexOutputBuffer:CreateTransferDestinationBuffer(device, indexBufferSize * 4, constants:BUFFER_USAGE_INDEX_BUFFER_BIT)

//        vertexStagingBuffer:Create(device, vertexBufferSize * 4, constants:BUFFER_USAGE_VERTEX_BUFFER_BIT, constants:MEMORY_USAGE_AUTO, constants:ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT, 0, 0, false)
//        indexStagingBuffer:Create(device, indexBufferSize * 4, constants:BUFFER_USAGE_INDEX_BUFFER_BIT, constants:MEMORY_USAGE_AUTO, constants:ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT, 0, 0, false)

        vertexMappedMemory = vertexStagingBuffer:MapToNumber32BitMemory()
        indexMappedMemory = indexStagingBuffer:MapToInteger32BitMemory()
    end

    action PrepareForNextFrame
        vertexWritePosition = 0
        indexWritePosition = 0
        verticesCount = 0
        isFull = false

        age = age + 1
    end

    action ResetAge
        age = 0
    end

    action GetAge returns integer
        return age
    end

    action IsFull returns boolean
        return isFull
    end

    action GetVertexBufferSize returns integer
        return vertexData:GetSize()
    end

    action GetIndexBufferSize returns integer
        return indexData:GetSize()
    end

    action Add(DrawableShape shape) returns boolean
        Number32BitArray vertices = shape:GetVertexData()
        Integer32BitBuffer indices = undefined
        if shape:GetMesh() not= undefined and shape:GetMesh():GetIndexData() not= undefined
            indices = shape:GetMesh():GetIndexData():GetBuffer()
        end

        if vertices:GetSize() + vertexWritePosition > GetVertexBufferSize() or (indices not= undefined and indices:GetSize() + indexWritePosition > GetIndexBufferSize())
            isFull = true
            return false
        end

//        integer i = 0
//        repeat while i < vertices:GetSize()
//            vertexData:Set(vertexWritePosition + i, vertices:Get(i))
//            i = i + 1
//        end
//        vertexWritePosition = vertexWritePosition + vertices:GetSize()

//        vertexData:Set(0, 0.25)
//        vertexData:Set(1, 0.25)
//        vertexData:Set(2, 0)
//        vertexData:Set(3, 0)
//        vertexData:Set(4, 0)
//        vertexData:Set(5, 0)
//
//        vertexData:Set(6, 0.75)
//        vertexData:Set(7, 0.25)
//        vertexData:Set(8, 0)
//        vertexData:Set(9, 0)
//        vertexData:Set(10, 0)
//        vertexData:Set(11, 0)
//
//        vertexData:Set(12, 0.75)
//        vertexData:Set(13, 0.75)
//        vertexData:Set(14, 0)
//        vertexData:Set(15, 0)
//        vertexData:Set(16, 0)
//        vertexData:Set(17, 0)
//        
//        vertexData:Set(18, 0.25)
//        vertexData:Set(19, 0.75)
//        vertexData:Set(20, 0)
//        vertexData:Set(21, 0)
//        vertexData:Set(22, 0)
//        vertexData:Set(23, 0)
//
//        vertexWritePosition = 24

        vertexData:Set(0, -0.5)
        vertexData:Set(1, -0.5)
        vertexData:Set(2, 0)

        vertexData:Set(3, 0.5)
        vertexData:Set(4, -0.5)
        vertexData:Set(5, 0)

        vertexData:Set(6, 0.5)
        vertexData:Set(7, 0.5)
        vertexData:Set(8, 0)
        
        vertexData:Set(9, -0.5)
        vertexData:Set(10, 0.5)
        vertexData:Set(11, 0)

        vertexWritePosition = 12

        // Most commonly, no custom indices are provided. In this case, set the default indices for a quad.
        if indices = undefined
            indexData:Set(indexWritePosition, verticesCount)
            indexData:Set(indexWritePosition + 1, verticesCount + 1)
            indexData:Set(indexWritePosition + 2, verticesCount + 2)
            indexData:Set(indexWritePosition + 3, verticesCount + 2)
            indexData:Set(indexWritePosition + 4, verticesCount + 3)
            indexData:Set(indexWritePosition + 5, verticesCount)

            indexWritePosition = indexWritePosition + 6
        else
            i = 0
            repeat while i < indices:GetSize()
                indexData:Set(indexWritePosition + i, indices:Get(i))
                i = i + 1
            end

            indexWritePosition = indexWritePosition + indices:GetSize()
        end

        verticesCount = verticesCount + shape:GetVertexCount()

        return true
    end

    action TransferBuffers(VulkanCommandBuffer buffer)
        output "Vertices:"
        integer i = 0
        repeat while i < vertexWritePosition
            output i + ": " + vertexData:Get(i)
            i = i + 1
        end

        output ""
        output "Indices:"
        i = 0
        repeat while i < indexWritePosition
            output i + ": " + indexData:Get(i)
            i = i + 1
        end

        vertexMappedMemory:Set(0, vertexData, 0, vertexWritePosition)
        indexMappedMemory:Set(0, indexData, 0, indexWritePosition)
        
        CopyBufferCommand vertexCopyCommand
        vertexCopyCommand:SetSourceBuffer(vertexStagingBuffer)
        vertexCopyCommand:SetDestinationBuffer(vertexOutputBuffer)
        vertexCopyCommand:SetSize(vertexWritePosition * 4)        

        CopyBufferCommand indexCopyCommand
        indexCopyCommand:SetSourceBuffer(indexStagingBuffer)
        indexCopyCommand:SetDestinationBuffer(indexOutputBuffer)
        indexCopyCommand:SetSize(indexWritePosition * 4)

        buffer:Record(vertexCopyCommand)
        buffer:Record(indexCopyCommand)
    end

    action CanFit(integer newVertices, integer newIndices) returns boolean
        if newVertices + vertexWritePosition > GetVertexBufferSize() or newIndices + indexWritePosition > GetIndexBufferSize()
            isFull = true
            return false
        end

        return true
    end

    action Dispose
        alert("NYI")
    end
    
    action GetPipeline returns VulkanPipeline
        return pipeline
    end

    action GetVertexWritePosition returns integer
        return vertexWritePosition
    end

    action GetIndexWritePosition returns integer
        return indexWritePosition
    end

    action GetVertexOutputBuffer returns VulkanBuffer
        return vertexOutputBuffer
//        return vertexStagingBuffer
    end

    action GetIndexOutputBuffer returns VulkanBuffer
        return indexOutputBuffer
//        return indexStagingBuffer
    end

end