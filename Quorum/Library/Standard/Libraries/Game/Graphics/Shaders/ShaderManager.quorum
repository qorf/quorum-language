package Libraries.Game.Graphics.Shaders

use Libraries.Containers.HashTable
use Libraries.Containers.Array
use Libraries.Game.Graphics.Mesh
use Libraries.Containers.Iterator
use Libraries.Game.GameStateManager

class ShaderManager

    public constant text DEFAULT_2D_SHADER_PROGRAM = "Default 2D Shader Program"
    public constant text DEFAULT_2D_VERTEX_SHADER = "Default 2D Vertex Shader"
    public constant text DEFAULT_2D_FRAGMENT_SHADER = "Default 2D Fragment Shader"
    public constant text DEFAULT_3D_SHADER_PROGRAM = "Default 3D Shader Program"
    public constant text DEFAULT_3D_VERTEX_SHADER = "Default 3D Vertex Shader"
    public constant text DEFAULT_3D_FRAGMENT_SHADER = "Default 3D Fragment Shader"

    // This type constant is used to indicate that the shader is a vertex shader. Every shader program must have a vertex shader as its first shader step.
    public constant integer VERTEX_SHADER = 1

    // This type constant is used to indicate that the shader is a fragment shader. Every shader program must have a fragment shader as its final shader step.
    public constant integer FRAGMENT_SHADER = 2
    
    // This type constant is used to indicate that the shader is a geometry shader. This shader step is optional.
    public constant integer GEOMETRY_SHADER = 3

    // This type constant is used to indicate that the shader is a tessellation control shader. This shader step is optional. If used, this should precede a tessellation evaluation shader in a shader program.
    public constant integer TESSELLATION_CONTROL_SHADER = 4

    // This type constant is used to indicate that the shader is a tessellation evaluation shader. This shader step is optional. If used, this should follow after a tessellation control shader in a shader program.
    public constant integer TESSELLATION_EVALUATION_SHADER = 5

    HashTable<text, Shader> registeredShaders
    HashTable<text, ShaderProgram> registeredPrograms
    
    // TO-DO: This array is currently in the ShaderManager for convenience, but reloading the meshes is only tangentially related to the shaders. This really should be somewhere else, more directly related to the meshes.
    // Make sure to move the add/remove/reload actions as well.
    Array<Mesh> reloadableMeshes

    action Register(text name, Shader shader)
        registeredShaders:Add(name, shader)
    end

    action Register(text name, ShaderProgram program)
        registeredPrograms:Add(name, program)
    end

    action RemoveShader(text name)
        registeredShaders:RemoveKey(name)
    end

    action RemoveShaderProgram(text name)
        registeredPrograms:RemoveKey(name)
    end

    action HasShader(text name) returns boolean
        return registeredShaders:HasKey(name)
    end

    action HasShaderProgram(text name) returns boolean
        return registeredPrograms:HasKey(name)
    end

    action GetShader(text name) returns Shader
        if HasShader(name)
            return registeredShaders:GetValue(name)
        else
            return undefined
        end
    end

    action GetShaderProgram(text name) returns ShaderProgram
        if HasShaderProgram(name)
            return registeredPrograms:GetValue(name)
        else
            return undefined
        end
    end

    action ReloadShaders
        GameStateManager manager
        if manager:GetGameGraphics() = undefined
            return now
        end

        Iterator<ShaderProgram> programs = registeredPrograms:GetValueIterator()
        repeat while programs:HasNext()
            ShaderProgram program = programs:Next()
            program:Reload()
        end
    end

    action GetDefaultShaderProgram2D returns ShaderProgram
        ShaderProgram program = GetShaderProgram(DEFAULT_2D_SHADER_PROGRAM)
        if program = undefined
            DefaultShaderProgram2D default2D
            // Compiling this program will automatically register it in the ShaderManager for future use.
            default2D:Compile()
            return default2D
        else
            return program
        end
    end

    action GetDefaultShaderProgram3D returns ShaderProgram
        ShaderProgram program = GetShaderProgram(DEFAULT_3D_SHADER_PROGRAM)
        if program = undefined
            DefaultShaderProgram3D default3D
            // Compiling this program will automatically register it in the ShaderManager for future use.
            default3D:Compile()
            return default3D
        else
            return program
        end
    end

    action GetDefaultVertexShader2D returns Shader
        if HasShader(DEFAULT_2D_VERTEX_SHADER) = false
            DefaultVertexShader2D shader
            // Compiling this shader will automatically register it in the ShaderManager for future use.
            shader:Compile()
        end

        return GetShader(DEFAULT_2D_VERTEX_SHADER)
    end

    action GetDefaultFragmentShader2D returns Shader
        if HasShader(DEFAULT_2D_FRAGMENT_SHADER) = false
            DefaultFragmentShader2D shader
            // Compiling this shader will automatically register it in the ShaderManager for future use.
            shader:Compile()
        end

        return GetShader(DEFAULT_2D_FRAGMENT_SHADER)
    end

    action GetDefaultVertexShader3D returns Shader
        if HasShader(DEFAULT_3D_VERTEX_SHADER) = false
            DefaultVertexShader3D shader
            // Compiling this shader will automatically register it in the ShaderManager for future use.
            shader:Compile()
        end

        return GetShader(DEFAULT_3D_VERTEX_SHADER)
    end

    action GetDefaultFragmentShader3D returns Shader
        if HasShader(DEFAULT_3D_FRAGMENT_SHADER) = false
            DefaultFragmentShader3D shader
            // Compiling this shader will automatically register it in the ShaderManager for future use.
            shader:Compile()
        end

        return GetShader(DEFAULT_3D_FRAGMENT_SHADER)
    end

    action AddReloadableMesh(Mesh mesh)
        reloadableMeshes:Add(mesh)
    end

    action RemoveReloadableMesh(Mesh mesh)
        reloadableMeshes:Remove(mesh)
    end

    action ReloadMeshes
        integer i = 0
        repeat while i < reloadableMeshes:GetSize()
            reloadableMeshes:Get(i):Reload()
            i = i + 1
        end
    end

    blueprint action DisposeShader(Shader shader)

    blueprint action CompileShader(Shader shader) returns integer
    

    blueprint action ReloadShader(Shader shader) returns integer

    /*
        This action takes platform into account and returns a default version of OpenGL's number to be placed at the top of a shader. For shaders
        not using OpenGL, this action does not provide useful information. The version number is calculated by Quorum, not the graphics hardware.
    */
    blueprint action GetVersionHeader returns text
    
end