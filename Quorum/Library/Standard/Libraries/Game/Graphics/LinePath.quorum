package Libraries.Game.Graphics

use Libraries.Interface.Controls.Control
use Libraries.Containers.Array
use Libraries.Compute.Vector2
use Libraries.Interface.Layouts.LayoutProperties
use Libraries.Containers.Iterator
use Libraries.Interface.Events.MouseEvent
use Libraries.Game.Layer
use Libraries.Compute.Vector3
use Libraries.Interface.Events.MouseMovementListener
use Libraries.Interface.Events.MouseListener
use Libraries.Interface.Events.MouseWheelListener
use Libraries.Interface.Selections.LinePathSelection

/*
The LinePath class represents a series of curved or straight lines connecting a set of points.
Each LinePath is a Control, and can be used on its own or in conjunction with layouts and/or
InterfaceOptions. Like a Drawable, the LinePath object has a bounding rectangle within a Game.
The LinePath can only draw lines inside of this rectangle, so it's important to use SetSize on
the LinePath so it has an area to draw in.

To set the colors of the LinePath, use SetBackgroundColor to change the color of the lines,
SetIconColor to change the color of the points, and SetBorderColor to change the color of
the outlining.

Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.Color
use Libraries.Game.Graphics.LinePath

class Main is Game

    Color color
    LinePath path

    action Main
        // The window for this Game can be resized by clicking and dragging the edges.
        EnableResizing(true)
        StartGame()
    end

    action CreateGame
        // It is very important to set a size on the LinePath!
        // The LinePath takes up a rectangle on the screen just like a Drawable.
        // The points and lines of the LinePath can only be drawn inside this rectangle.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Set visual values for the LinePath, including colors and thickness of the lines, points, and border
        path:SetBorderThickness(5)
        path:SetBackgroundColor(color:Red())
        path:SetIconColor(color:Pink())
        path:SetBorderColor(color:Black())
        path:SetLineThickness(7)
        path:SetPointThickness(14)

        // By setting this to true, the LinePath will draw each point in addition to the lines
        path:SetDrawPoints(true)

        // Add several points to the path.
        // Each point is an X and Y coordinate.
        path:Add(20, 20)
        path:Add(120, 100)
        path:Add(220, 340)
        path:Add(320, 300)
        path:Add(420, 120)
        path:Add(520, 400)
        path:Add(620, 480)
        path:Add(720, 200)

        // Using the MapToRegion action will instruct the path to render all of the points inside
        // the LinePath's rectangle (set using SetSize previously) as if it were on a specific coordinate
        // grid, no matter the size of the rectangle. In this case, the X-axis will always be from 0
        // to 750, and the Y-axis will always be from 0 to 500.
        path:MapToRegion(0, 750, 0, 500)

        Add(path)
    end

    action Update(number seconds)
        // On each frame, set the LinePath to the size of the window (in case the user resizes it)
        path:SetSize(GetScreenWidth(), GetScreenHeight())
    end
end
*/
class LinePath is Control

    /*
    TO-DO:
    Default interface options and/or colors?
    An alternative that doesn't require manually setting size?
    Ability to map points to a space?
    Write to SVG?
    */

    Array<Vector2> points
    Array<BezierCurve> curves
    boolean shouldRecalculate = true

    // The tension value of the Catmull-Rom Spline used to derive our bezier curves.
    // The default is 1. Increasing the tension reduces the severity of the curve.
    number tension = 1

    // The two extra points needed for the Catmull-Rom spline, one at the beginning and one at the end.
    Vector2 catmullRomStart
    Vector2 catmullRomEnd

    number lineThickness = 2
    number pointThickness = 6
    boolean drawPoints = false

    LinePathSelection selection

    /*
    The space the points should be mapped to. If the value is NotANumber, the dimensions
    of the LinePath object will be used instead.
    */
    number mappedLeft = tension:GetNotANumberValue()
    number mappedRight = tension:GetNotANumberValue()
    number mappedBottom = tension:GetNotANumberValue()
    number mappedTop = tension:GetNotANumberValue()

    on create
        SetCustomDrawing(true)
        SetName("Path")

        Color color
        SetBackgroundColor(color:Black())
        SetBorderColor(color:Black())
        SetIconColor(color:Navy())

        selection:Initialize(me)
    end

    /*
    This action sets the array of points the LinePath should use to draw.
    This will replace any previously loaded points in the LinePath.

    Attribute: Parameter points An array of points for the LinePath to draw between.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath
use Libraries.Containers.Array
use Libraries.Compute.Vector2

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Make an array and add 3 points to it.
        Array<Vector2> array
        Vector2 point1
        Vector2 point2
        Vector2 point3
        point1:Set(100, 400)
        point2:Set(300, 100)
        point3:Set(500, 400)
        array:Add(point1)
        array:Add(point2)
        array:Add(point3)

        // Load the array of points into our path.
        path:SetVectorPoints(array)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action SetVectorPoints(Array<Vector2> points)
        me:points:Empty()
        AddVectorPoints(points)
    end

    /*
    This action adds an array of points to the end of the LinePath. This doesn't
    remove any previously existing points in the LinePath, unlike SetVectorPoints().

    Attribute: Parameter points An array of points to be added to the end of the LinePath.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath
use Libraries.Containers.Array
use Libraries.Compute.Vector2

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Make an array and add 3 points to it.
        Array<Vector2> array
        Vector2 point1
        Vector2 point2
        Vector2 point3
        point1:Set(100, 400)
        point2:Set(300, 100)
        point3:Set(500, 400)
        array:Add(point1)
        array:Add(point2)
        array:Add(point3)

        // Load the array of points into our path.
        path:AddVectorPoints(array)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action AddVectorPoints(Array<Vector2> points)
        integer counter = 0
        repeat while counter < points:GetSize()
            Vector2 point
            point:Set(points:Get(counter):GetX(), points:Get(counter):GetY())
            me:points:Add(point)
            counter = counter + 1
        end
        shouldRecalculate = true
    end

    /*
    This action sets the points to be drawn between by the LinePath. The points are provided as
    x/y coordinate pairs in the array. This action will replace any previously set points in the LinePath.

    Attribute: Parameter array An array of numbers, representing the x/y coordinates of a series of points.    
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath
use Libraries.Containers.Array

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Make an array and add 3 points to it: (100, 100), (300, 200), and (500, 450).
        // We add the x coordinate and then the y coordinate of each pair, one at a time.
        Array<number> array
        array:Add(100)
        array:Add(100)
        array:Add(300)
        array:Add(200)
        array:Add(500)
        array:Add(450)

        // Load the array of points into our path.
        path:SetPoints(array)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action SetPoints(Array<number> points)
        me:points:Empty()
        AddPoints(points)
    end

/*
    This action adds points to the end of the LinePath. The points are provided as
    x/y coordinate pairs in the array. This action doesn't replace any previously set points in the LinePath,
    unlike SetPoints().

    Attribute: Parameter array An array of numbers, representing the x/y coordinates of a series of points.    
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath
use Libraries.Containers.Array

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Make an array and add 3 points to it: (100, 100), (300, 200), and (500, 450).
        // We add the x coordinate and then the y coordinate of each pair, one at a time.
        Array<number> array
        array:Add(100)
        array:Add(100)
        array:Add(300)
        array:Add(200)
        array:Add(500)
        array:Add(450)

        // Load the array of points into our path.
        path:AddPoints(array)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action AddPoints(Array<number> points)
        integer counter = 0
        repeat while counter < points:GetSize()
            Vector2 point
            point:Set(points:Get(counter), points:Get(counter + 1))
            me:points:Add(point)
            counter = counter + 2
        end
        shouldRecalculate = true
    end    

    /*
    This action adds a point to the end of the LinePath.

    Attribute: Parameter point A new point to add to the end of the LinePath.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath
use Libraries.Compute.Vector2

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Make 3 points and add them to the LinePath.
        Vector2 point1
        Vector2 point2
        Vector2 point3
        point1:Set(100, 400)
        point2:Set(300, 100)
        point3:Set(500, 400)
        path:Add(point1)
        path:Add(point2)
        path:Add(point3)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action Add(Vector2 point)
        Vector2 vector
        vector:Set(point)
        points:Add(vector)
        shouldRecalculate = true
    end

    /*
    This action adds a point to the end of the LinePath.    

    Attribute: Parameter x The x-coordinate of the new point.
    Attribute: Parameter y The y-coordinate of the new point.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Add 3 new points as x/y coordinate pairs to the LinePath.
        path:Add(100, 400)
        path:Add(300, 100)
        path:Add(500, 400)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action Add(number x, number y)
        Vector2 vector
        vector:Set(x, y)
        points:Add(vector)
        shouldRecalculate = true
    end

    /*
    The Empty action removes all points from the LinePath. The LinePath will not draw anything until new points are added.

    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Add 3 new points as x/y coordinate pairs to the LinePath.
        path:Add(100, 400)
        path:Add(300, 100)
        path:Add(500, 400)

        // Using the Empty call will remove all old points from the LinePath.
        path:Empty()

        // We can choose to add new points after removing the old ones.
        path:Add(100, 100)
        path:Add(300, 150)
        path:Add(500, 550)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action Empty
        points:Empty()
        shouldRecalculate = true
    end

    action Resize
        shouldRecalculate = true
        parent:Item2D:Resize()
    end

    action Draw(Painter2D painter)
        if not IsShowing() or points:IsEmpty()
            return now
        end

        if GetView2D() not= undefined
            GetView2D():Draw(painter)
        end

        if shouldRecalculate
            CalculateCurves()
        end

        LayoutProperties properties = GetDefaultLayoutProperties()
        number borderThickness = GetBorderThickness() * 2
        if GetBorderStyle() not= properties:NONE and borderThickness > 0
            integer i = 0
            repeat while i < curves:GetSize()
                BezierCurve curve = curves:Get(i)
                // Set values to render the curve as a thickened border behind the main curve.
                curve:SetBackgroundColor(GetBorderColor())
                curve:SetIconColor(GetBorderColor())
                curve:SetLineThickness((lineThickness + borderThickness) * GetInterfaceScale())
                curve:SetPointThickness((pointThickness + borderThickness) * GetInterfaceScale())

                curve:Draw(painter)
                painter:Flush()

                // Set values back before the rest of the rendering occurs.
                curve:SetBackgroundColor(GetBackgroundColor())
                curve:SetIconColor(GetIconColor())
                curve:SetLineThickness(lineThickness * GetInterfaceScale())
                curve:SetPointThickness(pointThickness * GetInterfaceScale())

                i = i + 1
            end
        end

        integer counter = 0
        Array<Item2D> children = GetChildren()
        repeat while counter < children:GetSize()
            children:Get(counter):Draw(painter)
            counter = counter + 1
        end
    end

    private action CalculateCurves
        if points:GetSize() = 1
            // We could make a special case here to render a single dot, but for now just throw an error.
            alert("I cannot render a LinePath with only one point.")
        end

        // Insert/remove curves until we have the correct amount.
        // For N points, we should have N-1 curves between them.
        repeat while curves:GetSize() < points:GetSize() - 1
            BezierCurve curve
            curves:Add(curve)
            Add(curve)
        end
        repeat until curves:GetSize() = points:GetSize() - 1
            BezierCurve curve = curves:RemoveFromEnd()
            Remove(curve)
        end

        // Calculate the extra Catmull-Rom points at the beginning and end.
        Vector2 distance
        distance:Set(points:Get(1))
        distance:Subtract(points:Get(0))
        catmullRomStart:Set(points:Get(0))
        catmullRomStart:Subtract(distance)

        distance:Set(points:Get(points:GetSize() - 2))
        distance:Subtract(points:Get(points:GetSize() - 1))
        catmullRomEnd:Set(points:Get(points:GetSize() - 1))
        catmullRomEnd:Subtract(distance)

        number leftBound = mappedLeft
        if mappedLeft:IsNotANumber()
            leftBound = 0
        end

        number rightBound = mappedRight
        if mappedRight:IsNotANumber()
            rightBound = GetWidth()
        end

        number bottomBound = mappedBottom
        if bottomBound:IsNotANumber()
            bottomBound = 0
        end

        number topBound = mappedTop
        if topBound:IsNotANumber()
            topBound = GetHeight()
        end

        /*
        Convert from Catmull-Rom spline to cubic Bezier curves.
        We use the approach described by Arasteh & Kalisz in "Conversion Between Cubic Bezier Curves and Catmull–Rom Splines", Equation 15.
        Source: https://link.springer.com/article/10.1007/s42979-021-00770-x
        */
        integer i = 0
        repeat while i < curves:GetSize()
            BezierCurve curve = curves:Get(i)

            Vector2 p0
            Vector2 p1
            Vector2 p2
            Vector2 p3

            p0:Set(GetCatmullRomPoint(i - 1))
            p1:Set(GetCatmullRomPoint(i))
            p2:Set(GetCatmullRomPoint(i + 1))
            p3:Set(GetCatmullRomPoint(i + 2))

            output "Before mapping: p0 = " + p0:GetX() + ", " + p0:GetY() + " -- p1 = " + p1:GetX() + ", " + p1:GetY() + " -- p2 = " + p2:GetX() + ", " + p2:GetY() + " -- p3 = " + p3:GetX() + ", " + p3:GetY()
            output "Bounds are " + leftBound + ", " + rightBound + ", " + bottomBound + ", " + topBound

            // The mapping step isn't part of the Catmull-Rom to Bezier conversion.
            // It's something we do to facilitate rendering a path that might want a different coordinate system than the raw pixels.
            TranslateFromMappedSpace(p0, leftBound, rightBound, bottomBound, topBound)
            TranslateFromMappedSpace(p1, leftBound, rightBound, bottomBound, topBound)
            TranslateFromMappedSpace(p2, leftBound, rightBound, bottomBound, topBound)
            TranslateFromMappedSpace(p3, leftBound, rightBound, bottomBound, topBound)

            output "After mapping: p0 = " + p0:GetX() + ", " + p0:GetY() + " -- p1 = " + p1:GetX() + ", " + p1:GetY() + " -- p2 = " + p2:GetX() + ", " + p2:GetY() + " -- p3 = " + p3:GetX() + ", " + p3:GetY()

            curve:SetPoint1(p1)
            curve:SetPoint2(p2)

            Vector2 c1
            c1:Set(p2)
            c1:Subtract(p0)
            c1:Scale(1.0 / (6.0 * tension))
            c1:Add(p1)
            curve:SetControlPoint1(c1)

            Vector2 c2
            c2:Set(p2)
            Vector2 temp
            temp:Set(p3)
            temp:Subtract(p1)
            temp:Scale(1.0 / (6.0 * tension))
            c2:Subtract(temp)
            curve:SetControlPoint2(c2)

            curve:SetBackgroundColor(GetBackgroundColor())
            curve:SetIconColor(GetIconColor())
            curve:SetLineThickness(lineThickness * GetInterfaceScale())
            curve:SetPointThickness(pointThickness * GetInterfaceScale())
            curve:SetDrawPoints(drawPoints)
            // Setting the size to match the path's is easy and makes it responsive to resizing, but is less performant than setting a more specific size and position.
            curve:SetSize(GetWidth(), GetHeight())

            output "Curve " + i + ": p1 = " + curve:GetPoint1():GetX() + ", " + curve:GetPoint1():GetY() + " -- p2 = " + curve:GetPoint2():GetX() + ", " + curve:GetPoint2():GetY() + " -- size = " + curve:GetWidth() + "x" + curve:GetHeight()

            i = i + 1
        end

        shouldRecalculate = false
    end

    /*
    Get a point on the Catmull-Rom spline we derive our curves from.
    The points of the spline are the same as the input points. 

    The spline also requires two extra points, one at the beginning and end. 
    These points are arbitrary, but to get nice results we reflect the second
    and second-to-last input points across the beginning and end, respectively,
    to get the extra points.
    */
    private action GetCatmullRomPoint(integer index) returns Vector2
        if index = -1
            return catmullRomStart
        end
        if index = points:GetSize()
            return catmullRomEnd
        end
        return GetPoint(index)
    end

    /*
    This action returns a Vector2 representing the x and y coordinates of the point at the requested index in the path.

    Attribute: Parameter index The index of the point to get.
    */
    action GetPoint(integer index) returns Vector2
        return points:Get(index)
    end

    /*
    This action returns the x-coordinate of the point at the requested index in the path.

    Attribute: Parameter index The index of the point to get.
    */
    action GetPointX(integer index) returns number
        return points:Get(index):GetX()
    end

    /*
    This action returns the y-coordinate of the point at the requested index in the path.

    Attribute: Parameter index The index of the point to get.
    */
    action GetPointY(integer index) returns number
        return points:Get(index):GetY()
    end

    /*
    This action returns a Vector2 representing the x and y coordinates of the point at the requested index in the path.
    This action returns the point's position in pixel coordinates (or "real space"), which could be different than the
    point's position in the line if the line has been mapped to a region. If no mapping is being used, this value will
    be identical.

    Attribute: Parameter index The index of the point to get.
    */
    action GetPixelPoint(integer index) returns Vector2
        Vector2 result
        result:Set(points:Get(index))
        TranslateFromMappedSpace(result)
        return result
    end

    /*
    This action returns the x-coordinate of the point at the requested index in the path.
    This action returns the point's position in pixel coordinates (or "real space"), which could be different than the
    point's position in the line if the line has been mapped to a region. If no mapping is being used, this value will
    be identical.

    Attribute: Parameter index The index of the point to get.
    */
    action GetPixelPointX(integer index) returns number
        Vector2 result
        result:Set(points:Get(index))
        TranslateFromMappedSpace(result)
        return result:GetX()
    end

    /*
    This action returns the y-coordinate of the point at the requested index in the path.
    This action returns the point's position in pixel coordinates (or "real space"), which could be different than the
    point's position in the line if the line has been mapped to a region. If no mapping is being used, this value will
    be identical.

    Attribute: Parameter index The index of the point to get.
    */
    action GetPixelPointY(integer index) returns number
        Vector2 result
        result:Set(points:Get(index))
        TranslateFromMappedSpace(result)
        return result:GetY()
    end

    /*
    This action sets the coordinates of one of the points in the LinePath. This is used to adjust existing points.
    This does not add new points -- if there is no point at the requested index, an error will occur.

    Attribute: Parameter index The index of the point to modify.
    Attribute: Parameter x The new x-coordinate for the point.
    Attribute: Parameter y The new y-coordinate for the point.
    */
    action SetPoint(integer index, number x, number y)
        if index >=0 and index < points:GetSize()
            points:Get(index):Set(x, y)
            shouldRecalculate = true
        else
            if index < 0
                alert("I could not set the point at index " + index + ". The index cannot be negative.")
            else
                alert("I could not set the point at index " + index + ". The LinePath only has " + points:GetSize() + " points.")
            end
        end
    end

    /*
    This action returns the number of points contained in this LinePath. This does not
    include the two extra points generated by the Catmull-Rom spline algorithm -- it
    is the count of user-provided, "real" points which can be accessed using GetPoint().

    Attribute: Returns How many "real" points are in this LinePath.
    */
    action GetPointCount returns integer
        return points:GetSize()
    end

    /*
    This action returns the selection within the LinePath.

    Attribute: Returns The LinePath's selection.
    */
    action GetSelection returns LinePathSelection
        return selection
    end

    /*
    Translate the values in the given Vector2 from the mapped space (the custom region set by the user via the mapping action)
    to the real space (pixel values contained within the dimensions of the LinePath object).
    */
    action TranslateFromMappedSpace(Vector2 point)
        number leftBound = mappedLeft
        if mappedLeft:IsNotANumber()
            leftBound = 0
        end

        number rightBound = mappedRight
        if mappedRight:IsNotANumber()
            rightBound = GetWidth()
        end

        number bottomBound = mappedBottom
        if bottomBound:IsNotANumber()
            bottomBound = 0
        end

        number topBound = mappedTop
        if topBound:IsNotANumber()
            topBound = GetHeight()
        end

        TranslateFromMappedSpace(point, leftBound, rightBound, bottomBound, topBound)
    end

    private action TranslateFromMappedSpace(Vector2 point, number leftBound, number rightBound, number bottomBound, number topBound)
        number x = (point:GetX() - leftBound) * (GetWidth() / (rightBound - leftBound))
        number y = (point:GetY() - bottomBound) * (GetHeight() / (topBound - bottomBound))
        point:Set(x, y)
    end

    /*
    Translate the values in the given Vector2 from the real space (pixel values contained within the dimensions of the LinePath object)
    to the mapped space (the custom region set by the user via the mapping action)
    */
    action TranslateToMappedSpace(Vector2 point)
        number leftBound = mappedLeft
        if mappedLeft:IsNotANumber()
            leftBound = 0
        end

        number rightBound = mappedRight
        if mappedRight:IsNotANumber()
            rightBound = GetWidth()
        end

        number bottomBound = mappedBottom
        if bottomBound:IsNotANumber()
            bottomBound = 0
        end

        number topBound = mappedTop
        if topBound:IsNotANumber()
            topBound = GetHeight()
        end

        TranslateToMappedSpace(point, leftBound, rightBound, bottomBound, topBound)
    end

    private action TranslateToMappedSpace(Vector2 point, number leftBound, number rightBound, number bottomBound, number topBound)
        number x = (point:GetX() / GetWidth()) * (rightBound - leftBound) + leftBound
        number y = (point:GetY() / GetHeight()) * (topBound - bottomBound) + bottomBound
        point:Set(x, y)
    end

    /*
    This action returns the base thickness of the lines, in pixels. The thickness of the lines remains constant even if the
    LinePath is mapped to a smaller or larger region, but the thickness value does not include adjustments made by interface scaling.

    Attribute: Returns The thickness of the lines, in pixels.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        output "The default line thickness of the path is " + path:GetLineThickness()
    end
end
    */
    action GetLineThickness returns number
        return lineThickness
    end

    /*
    This action sets how thick the lines of the LinePath should be, in pixels.

    Attribute: Parameter lineThickness How thick the lines should be, in pixels.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Add 3 new points as x/y coordinate pairs to the LinePath.
        path:Add(100, 400)
        path:Add(300, 100)
        path:Add(500, 400)

        // Set the line thickness.
        path:SetLineThickness(10)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action SetLineThickness(number lineThickness)
        me:lineThickness = lineThickness
    end

    /*
    This action returns the base thickness of the points, in pixels. The thickness of the points remains constant even if the
    LinePath is mapped to a smaller or larger region, but the thickness value does not include adjustments made by interface scaling.

    Attribute: Returns The thickness of the points, in pixels.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        output "The default point thickness of the path is " + path:GetPointThickness()
    end
end
    */
    action GetPointThickness returns number
        return pointThickness
    end

    /*
    This action sets how thick the points of the LinePath should be, in pixels.

    Attribute: Parameter pointThickness How thick the points should be, in pixels.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Add 3 new points as x/y coordinate pairs to the LinePath.
        path:Add(100, 400)
        path:Add(300, 100)
        path:Add(500, 400)

        // Set the point thickness.
        path:SetLineThickness(20)

        // The points will only display if we set them to -- by default they won't show.
        path:SetDrawPoints(true)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action SetPointThickness(number pointThickness)
        me:pointThickness = pointThickness
    end

    /*
    This action is used to toggle if points should be drawn or not. By default, this is false (points will not draw).

    Attribute: Parameter drawPoints True to draw the points, false to hide them.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Add 3 new points as x/y coordinate pairs to the LinePath.
        path:Add(100, 400)
        path:Add(300, 100)
        path:Add(500, 400)

        // Set the point thickness.
        path:SetLineThickness(20)

        // The points will only display if we set them to -- by default they won't show.
        path:SetDrawPoints(true)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action SetDrawPoints(boolean drawPoints)
        me:drawPoints = drawPoints
    end

    /*
    This action returns true if the LinePath is drawing points, or false if it is hiding them.
    By default, this is false.

    Attribute: Returns True if points are being drawn, or false otherwise.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        output "By default, drawing points is " + path:IsDrawingPoints()
    end
end
    */
    action IsDrawingPoints returns boolean
        return drawPoints
    end

    /*
    This action determines if the LinePath should use curved lines or straight ones.
    By default, this value is true (curved lines).

    Attribute: Parameter curve True to make the path use curved lines, or false to use straight lines.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Add 3 new points as x/y coordinate pairs to the LinePath.
        path:Add(100, 400)
        path:Add(300, 100)
        path:Add(500, 400)

        // Set the path to use straight lines.
        path:SetCurving(false)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action SetCurving(boolean curve)
        if curve
            tension = 1
        else
            tension = tension:GetPositiveInfinityValue()
        end
    end

    /*
    This action returns true if the LinePath using curved lines, or false if the LinePath is using straight ones.
    By default, this action returns true.

    Attribute: Returns True if the LinePath uses curved lines, or false otherwise.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        output "By default, it is " + path:IsDrawingPoints() + " that the LinePath uses curved lines."
    end
end
    */
    action IsCurving returns boolean
        return tension not= tension:GetPositiveInfinityValue()
    end

    /*
    This action gets an iterator over the points in the LinePath.
    
    Attribute: Returns An iterator over the points in the LinePath.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath
use Libraries.Containers.Iterator
use Libraries.Compute.Vector2

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Add 3 new points as x/y coordinate pairs to the LinePath.
        path:Add(100, 400)
        path:Add(300, 100)
        path:Add(500, 400)

        // Add the path to the Game.
        Add(path)

        // Get an iterator over the points.
        Iterator<Vector2> points = path:GetPointIterator()
    end
end
    */
    action GetPointIterator returns Iterator<Vector2>
        return points:GetIterator()
    end

    /*
    This action returns an Iterator containing the bezier curves used to draw lines between points.

    Attribute: Returns An iterator of bezier curves between the points.
    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath
use Libraries.Containers.Iterator
use Libraries.Game.Graphics.BezierCurve

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Add 3 new points as x/y coordinate pairs to the LinePath.
        path:Add(100, 400)
        path:Add(300, 100)
        path:Add(500, 400)

        // Add the path to the Game.
        Add(path)

        // Get an iterator over the bezier curves.
        Iterator<BezierCurve> curves = path:GetCurveIterator()
    end
end
    */
    action GetCurveIterator returns Iterator<BezierCurve>
        if shouldRecalculate
            CalculateCurves()
        end
        return curves:GetIterator()
    end

    /*
    This action maps the LinePath's points to a specific coordinate region. This can be
    convenient if you want the LinePath to consistently render points between some specific
    values, regardless of the dimensions of the LinePath object itself.

    If no mapping region is set, the points in the LinePath will default to using the dimensions
    of the LinePath object for their coordinate space (between 0 and the width/height for x/y
    coordinates, respectively).

    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Add 3 new points as x/y coordinate pairs to the LinePath.
        path:Add(-200, 1000)
        path:Add(0, 800)
        path:Add(200, 400)

        // By mapping to this region, we'll render our line as if the bottom-left of the LinePath rectangle is at (-250, 300) and the top-right is at (250, 1100).
        path:MapToRegion(-250, 250, 300, 1100)

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action MapToRegion(number minimumX, number maximumX, number minimumY, number maximumY)
        mappedLeft = minimumX
        mappedRight = maximumX
        mappedBottom = minimumY
        mappedTop = maximumY
    end

    /*
    This action returns whether or not this LinePath is currently mapping to a region. By default, this
    is false.

    Attribute: Returns True if this LinePath is mapping to a region, or false otherwise.
    */
    action IsMappedToRegion returns boolean
        // Either all four values will be NaN, or none of them will be. Just check one arbitrarily.
        return mappedLeft:IsNotANumber() = false
    end

    /*
    This action returns the x coordinate of the left side of the mapped region (the minimum X value).
    Note that if this LinePath is not currently mapping to a region, the returned value will be "not a 
    number". It is highly recommended to check if the region is mapped using "IsMappingToRegion" before
    using this value.

    Attribute: Returns The x-coordinate of the left side of the mapped region (the minimum X value).
    */
    action GetMappedLeft returns number
        return mappedLeft
    end

    /*
    This action returns the x coordinate of the right side of the mapped region (the maximum X value).
    Note that if this LinePath is not currently mapping to a region, the returned value will be "not a 
    number". It is highly recommended to check if the region is mapped using "IsMappingToRegion" before
    using this value.

    Attribute: Returns The x-coordinate of the right side of the mapped region (the maximum X value).
    */
    action GetMappedRight returns number
        return mappedRight
    end

    /*
    This action returns the y coordinate of the bottom side of the mapped region (the minimum Y value).
    Note that if this LinePath is not currently mapping to a region, the returned value will be "not a 
    number". It is highly recommended to check if the region is mapped using "IsMappingToRegion" before
    using this value.

    Attribute: Returns The y-coordinate of the bottom side of the mapped region (the minimum Y value).
    */
    action GetMappedBottom returns number
        return mappedBottom
    end

    /*
    This action returns the y coordinate of the top side of the mapped region (the maximum Y value).
    Note that if this LinePath is not currently mapping to a region, the returned value will be "not a 
    number". It is highly recommended to check if the region is mapped using "IsMappingToRegion" before
    using this value.

    Attribute: Returns The y-coordinate of the top side of the mapped region (the maximum Y value).
    */
    action GetMappedTop returns number
        return mappedTop
    end

    /*
    This action resets any region mapping applied by MapToRegion(). Points inside the
    LinePath will be positioned inside the dimensions of the LinePath using standard pixel positioning.
    This is the default behavior for the LinePath class -- this action is only useful if MapToRegion
    has been used previously.

    Attribute: Example
use Libraries.Game.Game
use Libraries.Game.Graphics.LinePath

class Main is Game

    LinePath path

    action Main
        StartGame()
    end

    action CreateGame
        // Set the size of the LinePath's bounding rectangle, so it knows where it's allowed to draw.
        // Like all Item2Ds, the LinePath's position defaults to 0,0.
        path:SetSize(GetScreenWidth(), GetScreenHeight())

        // Add 3 new points as x/y coordinate pairs to the LinePath.
        path:Add(-200, 1000)
        path:Add(0, 800)
        path:Add(200, 400)

        // By mapping to this region, we'll render our line as if the bottom-left of the LinePath rectangle is at (-250, 300) and the top-right is at (250, 1100).
        path:MapToRegion(-250, 250, 300, 1100)

        // After setting the mapping region, we can reset it to default behavior.
        // Note that with the points we picked earlier, most of this will be off of the screen!
        path:ResetMapping()

        // Add the path to the Game.
        Add(path)
    end
end
    */
    action ResetMapping
        mappedLeft = mappedLeft:GetNotANumberValue()
        mappedRight = mappedLeft:GetNotANumberValue()
        mappedBottom = mappedLeft:GetNotANumberValue()
        mappedTop = mappedLeft:GetNotANumberValue()
    end

    /*  
    This action takes a mouse event and handles it. It will first test to 
    see if the mouse event took place within the bounds of this Item. If so, it
    will notify any MouseListeners of the event. If the event was not contained
    within this Item, or if there are no MouseListeners on this Item, the Item
    will ask its parent Item to process the mouse event, if there is a parent.

    Attribute: Example

        use Libraries.Interface.Item2D
        use Libraries.Interface.Events.MouseEvent
        use Libraries.Interface.Events.MouseListener
        Item2D myItem
        MouseListener listener
        myItem:AddMouseListener(listener)
        MouseEvent event
        event:eventType = event:CLICKED_MOUSE
        myItem:ProcessMouseEvent(event)
    
    */
    action ProcessMouseEvent(MouseEvent event)
        if IsAcceptingMouseInput() = false or drawPoints = false
            event:SetEventHandled(false)
            return now
        end

        integer pointIndex = -1

        // Currently, the LinePath only detects mouse activity over the points if they are visible.
        Layer layer = GetLayer()
        if layer not= undefined and GetLayer():GetCamera() not= undefined
            Vector3 worldCoordinates = layer:GetCamera():ScreenToWorldCoordinates(event:GetX() - layer:GetViewportX(), event:GetY() - layer:GetViewportY())
            Vector2 mousePoint
            mousePoint:Set(worldCoordinates:GetX() - GetGlobalX(), worldCoordinates:GetY() - GetGlobalY())

            number radiusSquared = GetBorderThickness() + pointThickness
            radiusSquared = radiusSquared * radiusSquared

            integer i = 0
            boolean found = false
            repeat while i < points:GetSize() and found = false
                Vector2 point
                point:Set(points:Get(i))
                TranslateFromMappedSpace(point)

                if mousePoint:DistanceSquared(point) <= radiusSquared
                    found = true
                else
                    i = i + 1
                end
            end

            // If the mouse wasn't over a point, pass the event over to the parent.
            if not found
                pointIndex = -1
            else
                pointIndex = i
            end
        end

/*
    For each event and based on points:

    CLICKED_MOUSE:
        * If point: Select the point.
        * If not point: Deselect the point and pass on the event.
    RELEASED_MOUSE:
        * If point: process, but no special behavior
        * If not point: Pass on the event and ignore.
    MOVED_MOUSE:
        * If we're using mouse over colors:
            * If point: mouse over color on the point, if available.
            * If not point: Pass on event and ignore.
        * Else:
            * Pass on event and ignore.
    DRAGGED_MOUSE:
        * If selection: Process the mouse input normally.
        * If no selection: Pass on event and ignore.
    SCROLLED_MOUSE:
        * If point: Process the event
        * If not point: Pass on event and ignore.
*/

        // If the mouse was clicked off a point or the mouse was released, reset the selection.
        if event:eventType = event:RELEASED_MOUSE or (event:eventType = event:CLICKED_MOUSE and pointIndex = -1)
            selection:SetPointIndex(-1)
        end

        /*
        If the event wasn't on a point, we don't want to process it.
        The only exception is for drag events, which we'll want to process if there's a selection.
        (In the case that the user wants to drag a point, the drag likely starts on the point but then leaves it)
        */
        if pointIndex = -1 and not (event:eventType = event:DRAGGED_MOUSE and selection:GetPointIndex() >= 0)
            event:SetEventHandled(false)
            return now
        end

        boolean wasSent = false

        if event:eventType = event:MOVED_MOUSE
            Iterator<MouseMovementListener> iterator = GetMouseMovementListeners()
            if iterator:HasNext()
                event:SetEventHandled(true)
                wasSent = true
            end

            repeat while iterator:HasNext()
                iterator:Next():MovedMouse(event)
            end

        elseif event:eventType = event:DRAGGED_MOUSE
            Iterator<MouseMovementListener> iterator = GetMouseMovementListeners()
            if iterator:HasNext()
                event:SetEventHandled(true)
                wasSent = true
            end

            repeat while iterator:HasNext()
                iterator:Next():DraggedMouse(event)
            end

        elseif event:eventType = event:CLICKED_MOUSE
            selection:SetPointIndex(pointIndex)

            Iterator<MouseListener> iterator = GetMouseListeners()
            if iterator:HasNext()
                event:SetEventHandled(true)
                wasSent = true
            end

            repeat while iterator:HasNext()
                iterator:Next():ClickedMouse(event)
            end

        elseif event:eventType = event:RELEASED_MOUSE
            Iterator<MouseListener> iterator = GetMouseListeners()
            if iterator:HasNext()
                event:SetEventHandled(true)
                wasSent = true
            end

            repeat while iterator:HasNext()
                iterator:Next():ReleasedMouse(event)
            end

        elseif event:eventType = event:SCROLLED_MOUSE
            Iterator<MouseWheelListener> iterator = GetMouseWheelListeners()
            if iterator:HasNext()
                event:SetEventHandled(true)
                wasSent = true
            end

            repeat while iterator:HasNext()
                iterator:Next():ScrolledMouse(event)
            end
        end

        if not wasSent
            event:SetEventHandled(true)
            if GetParent() not= undefined
                GetParent():ProcessMouseEvent(event)
            end
        end
    end
end