package Libraries.Game

use Libraries.Game.Graphics.Camera
use Libraries.Game.Graphics.OrthographicCamera
use Libraries.Game.Graphics.GraphicsManager
use Libraries.Interface.Accessibility
use Libraries.Interface.Events.MouseEvent
use Libraries.Interface.Events.TouchEvent
use Libraries.Interface.Events.ResizeEvent
use Libraries.Interface.Events.MouseListener
use Libraries.Interface.Events.MouseMovementListener
use Libraries.Interface.Events.MouseWheelListener
use Libraries.Interface.Events.TouchListener
use Libraries.Containers.Array
use Libraries.Interface.Item
use Libraries.Interface.Item2D
use Libraries.Interface.Layouts.Layout
use Libraries.Interface.Controls.Control
use Libraries.Interface.Views.View2D
use Libraries.Game.Graphics.Painter2D
use Libraries.Game.Graphics.Color
use Libraries.Compute.Vector3
use Libraries.Containers.Iterator
use Libraries.Game.Collision.CollisionManager2D
use Libraries.Interface.Events.CollisionListener2D
use Libraries.Game.Collision.CollisionEdge2D
use Libraries.Interface.Events.CollisionEvent2D
use Libraries.Game.Physics.TimeStep
use Libraries.Game.Physics.Joints.Joint2D
use Libraries.Game.Physics.Joints.JointEdge2D
use Libraries.Game.Physics.CollisionGroup2D
use Libraries.Game.Collision.Narrowphase.TimeOfImpact2D
use Libraries.Game.Collision.Narrowphase.TimeOfImpactInput2D
use Libraries.Game.Collision.Narrowphase.TimeOfImpactOutput2D
use Libraries.Game.Collision.Sweep2D
use Libraries.Containers.Stack
use Libraries.Compute.Vector2
use Libraries.Game.GameInput
use Libraries.System.SystemHelper
use Libraries.Language.Errors.ConcurrencyError
use Libraries.Interface.Events.GestureListener
use Libraries.Interface.Events.GestureEvent

/*
The Layer2D class is used to manage a number of 2D objects, as well as manage
input. The Layer2D effectively consists of a 2D "world", where all objects added
to it exist in the same space and can interact with each other.

Attribute: Author William Allee

Attribute: Example

use Libraries.Game.Game
use Libraries.Game.Layer2D
use Libraries.Game.Graphics.Drawable

class Main is Game

    action Main
        StartGame()
    end

    action CreateGame
        Drawable box
        box:LoadFilledRectangle(50, 50)
        box:SetPosition(100, 100)

        Drawable circle
        circle:LoadFilledCircle(25)
        circle:SetPosition(300, 100)

        Layer2D layer
        layer:Add(box)
        layer:Add(circle)
        AddLayer(layer)
    end

    action Update(number seconds)
    end
end
*/
class Layer2D is Layer

    Array<Item2D> items
    Array<Joint2D> joints = undefined
    Array<MouseListener> mouseListeners
    Array<MouseMovementListener> mouseMovementListeners
    Array<MouseWheelListener> mouseWheelListeners
    Array<TouchListener> touchListeners
    Array<GestureListener> gestureListeners
    Array<Item2D> depthSortedArray
    Camera camera = undefined
    Painter2D painter
    CollisionGroup2D island = undefined
    Stack<Item2D> stack
    CollisionGroup2D toiIsland = undefined
    TimeOfImpactInput2D toiInput = undefined
    TimeOfImpactOutput2D toiOutput = undefined
    TimeStep substep = undefined
    Item2D tempBody0 = undefined
    Item2D tempBody1 = undefined
    Sweep2D backup1 = undefined
    Sweep2D backup2 = undefined
    TimeOfImpact2D toi = undefined

    GameStateManager manager
    SystemHelper systemHelper
    GraphicsManager graphics = undefined
    Item2DDepthComparison depthSorter

    CollisionManager2D collisionManager
    boolean automaticallyClearForces = true

    Vector2 gravity
    boolean requireSimulation = false

    number inverseDeltaTime0 = 0

    boolean warmStarting = true
    boolean continuousPhysics = false
    boolean subStepping = false
    boolean stepComplete = true

    boolean newItemAdded = false

    boolean physicsEnabled = false

    /* This allows us to turn off collisions for the entire game. */
    private boolean collide = true
    /*
    Used to layout controls in this Layer.
    */
    Layout layerLayout = undefined
    number interfaceScale = 1

    Array<Control> controls
    boolean shouldLayout = false
    boolean shouldSortDepthBuffer = true

    // A pair of reusable Vector2 objects used for one-off calculations, such
    // as GetClipCoordinates.
    Vector2 workVector2A
    Vector2 workVector2B

    // A reusable array of Item2D used for one-off calculations, such as
    // GetItemHierarchy.
    Array<Item2D> workArray

    on create
        SetName("Layer2D")

        OrthographicCamera cam
        camera = cam
        SetViewport(0, 0, manager:GetGameDisplay():GetWidth(), manager:GetGameDisplay():GetHeight())
        camera:Update()
        collisionManager:SetLayer(me)

        graphics = manager:GetGameGraphics()    
    end

    /*
        Call this action if you want to learn if depth 
        buffer sorting is on. By default, depth buffer sorting is on.
    */
    action IsDepthBufferSorting returns boolean
        return shouldSortDepthBuffer
    end

    /*
        Call this action if you want to manually tell the layer to turn off depth 
        buffer sorting. This can be appropriate if all items in the layer are 
        at the same level of depth. By default, depth buffer sorting is on.
    */
    action SetDepthBufferSorting(boolean sort)
        me:shouldSortDepthBuffer = sort
    end

    /* This allows us to know if collisions are on or off for the layer. */
    action IsColliding returns boolean
        return collide
    end

    /* This allows us to turn collisions on or off for the layer. */
    action SetColliding(boolean collide)
        if not collide
            collisionManager = undefined
            EnablePhysics(false)
        else
            CollisionManager2D collisionManager2
            EnablePhysics(true)
            collisionManager = collisionManager2
        end
        me:collide = collide
    end

    /*
    This action ensures that the current thread is the same as the main GUI
    thread. Certain kinds of actions like adding or removing items should only
    be done on the GUI thread.

    If this code is being called from outside the GUI thread, it alerts a
    ConcurrencyException.
    */
    private action EnsureCorrectThread
        if (manager:GetApplication() is DesktopApplication) and (manager:GetMainThreadName() not= systemHelper:GetThreadName())
            ConcurrencyError error
            error:SetErrorMessage("I can only add or remove items from the Game on the main thread, but I was asked to do so on a different thread.")
            alert(error)
        end
    end

    /*
    This action will add an Item2D to this Layer. It will be updated along with
    the rest of the layer, and will be drawn on the screen (if it is visible and
    possible to draw the given Item2D). The Item2D will be added to the back of
    the layer's internal array of items.

    Attribute: Parameter item The Item2D to be added to the layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            // Item2D objects aren't visible, but can still be used for game logic.
            Item2D area
            area:SetSize(50, 50)
            area:SetPosition(100, 100)

            // Drawables inherit from Item2D, so they can be added too.
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:Add(area)
            layer:Add(circle)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end

    */
    action Add(Item2D item)
        EnsureCorrectThread()

        if item is Control
            AddControl(cast(Control, item))
        end

        item:SetLayer(me)
        items:Add(item)
        newItemAdded = true

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Add(item)
        end
    end

    /*
    This action will add an Item2D to this Layer's array of items at the index
    location. It will be updated along with the rest of the layer, and will be 
    drawn on the screen (if it is visible and possible to draw the given Item2D).

    Attribute: Parameter index The index to store the item at in the layer's array of items.
    Attribute: Parameter item The Item2D to be added to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            // Item2D objects aren't visible, but can still be used for game logic.
            Item2D area
            area:SetSize(50, 50)
            area:SetPosition(100, 100)

            // Drawables inherit from Item2D, so they can be added too.
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:Add(0, area)
            layer:Add(1, circle)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end

    */
    action Add(integer index, Item2D item)
        EnsureCorrectThread()

        if item is Control
            AddControl(cast(Control, item))
        end

        item:SetLayer(me)
        items:Add(index, item)
        newItemAdded = true

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Add(item)
        end
    end

    /*
    This action will add an Item2D to this layer's array of items at index 0. 
    It will be updated along with the rest of the layer, and will be drawn on 
    the screen (if it is visible and possible to draw the given Item2D). Adding
    an item to the front will cause it to be drawn and updated before other
    items in the layer, and other drawn items will appear to be on top of it.

    Attribute: Parameter item The item to add to the front of the layer's item array.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            // Item2D objects aren't visible, but can still be used for game logic.
            Item2D area
            area:SetSize(50, 50)
            area:SetPosition(100, 100)

            // Drawables inherit from Item2D, so they can be added too.
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:AddToFront(area)
            layer:AddToFront(circle)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end

    */
    action AddToFront(Item2D item)
        EnsureCorrectThread()

        if item is Control
            AddControl(cast(Control, item))
        end

        item:SetLayer(me)
        items:AddToFront(item)
        newItemAdded = true

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Add(item)
        end
    end

    private action AddControl(Control control)
        controls:Add(control)
        control:RequestLayout()
        control:SetInterfaceScale(interfaceScale)
        shouldLayout = true
    end

    private action RemoveControl(Control control)
        controls:Remove(control)
        shouldLayout = true
    end

    /*
    This action will clear all the items in this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:Add(circle)
            AddLayer(layer)

            layer:Empty()
        end

        action Update(number seconds)
        end
    end

    */
    action Empty
        Iterator<Item2D> it = items:GetIterator()
        repeat while it:HasNext()
            Item2D body = it:Next()
            
            JointEdge2D jointEdge = body:GetJointList()
            repeat while jointEdge not= undefined
                JointEdge2D jointEdge0 = jointEdge
                jointEdge = jointEdge:GetNext()

                RemoveJoint(jointEdge0:GetJoint())

                body:SetJointList(jointEdge)
            end
            body:SetJointList(undefined)
            
            CollisionEdge2D edge = body:GetCollisionList()
            repeat while edge not= undefined
                CollisionEdge2D edge0 = edge
                edge = edge:GetNext()
                collisionManager:Destroy(edge0:GetCollision())
            end
            body:SetCollisionList(undefined)

            body:DestroyNodes(collisionManager:GetBroadphase())
            body:SetCollidable(false)
            body:SetLayer(undefined)
        end
        items:Empty()
        controls:Empty()
    end

    /*
    This action will remove an Item2D from this layer. If the item was not a
    part of this layer, this action will have no effect.

    Attribute: Parameter item The item to remove from this layer.

    Attribute: Returns Whether or not the item was found and removed from the layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:Add(circle)
            AddLayer(layer)

            layer:Remove(circle)
        end

        action Update(number seconds)
        end
    end
    
    */
    action Remove(Item2D item) returns boolean
        EnsureCorrectThread()

        if item is Control
            RemoveControl(cast(Control, item))
        end
        
        if PhysicsEnabled()
JointEdge2D jointEdge = item:GetJointList()
        repeat while jointEdge not= undefined
            JointEdge2D jointEdge0 = jointEdge
            jointEdge = jointEdge:GetNext()

            RemoveJoint(jointEdge0:GetJoint())

            item:SetJointList(jointEdge)
        end
        item:SetJointList(undefined)
        end

if IsColliding()
CollisionEdge2D edge = item:GetCollisionList()
        repeat while edge not= undefined
            CollisionEdge2D edge0 = edge
            edge = edge:GetNext()
            collisionManager:Destroy(edge0:GetCollision())
        end
        item:SetCollisionList(undefined)
            
item:DestroyNodes(collisionManager:GetBroadphase())
        item:SetCollidable(false)
        end

        item:SetLayer(undefined)

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Remove(item)
        end

        return items:Remove(item)
    end

    /*
    This action will remove an Item2D at the index location from this layer's 
    array of items, and return the item that was removed.

    Attribute: Parameter index The index to remove an item from in this layer's array of items.

    Attribute: Returns The item that was removed from the item array in the layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:Add(circle)
            AddLayer(layer)

            Item2D item = layer:RemoveAt(0)
        end

        action Update(number seconds)
        end
    end

    */
    action RemoveAt(integer index) returns Item2D
        EnsureCorrectThread()

        Item2D item = items:RemoveAt(index)

        if item is Control
            RemoveControl(cast(Control, item))
        end

        if PhysicsEnabled()
JointEdge2D jointEdge = item:GetJointList()
        repeat while jointEdge not= undefined
            JointEdge2D jointEdge0 = jointEdge
            jointEdge = jointEdge:GetNext()

            RemoveJoint(jointEdge0:GetJoint())
            
            item:SetJointList(jointEdge)
        end
        item:SetJointList(undefined)
        end
        
        if IsColliding()
CollisionEdge2D edge = item:GetCollisionList()
        repeat while edge not= undefined
            CollisionEdge2D edge0 = edge
            edge = edge:GetNext()
            collisionManager:Destroy(edge0:GetCollision())
        end
        item:SetCollisionList(undefined)

        item:DestroyNodes(collisionManager:GetBroadphase())
        item:SetCollidable(false)
        end

        item:SetLayer(undefined)

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Remove(item)
        end

        return item
    end 

    /*
    This action will remove an Item2D from the front of the array of items in
    this layer, and return the item that was removed. This is functionally the
    same as calling "RemoveAt(0)".

    Attribute: Returns The item that was removed from the front of the layer's item array.
    
    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:Add(circle)
            AddLayer(layer)

            Item2D item = layer:RemoveFromFront()
        end

        action Update(number seconds)
        end
    end

    */
    action RemoveFromFront returns Item2D
        EnsureCorrectThread()

        Item2D item = items:RemoveFromFront()

        if item is Control
            RemoveControl(cast(Control, item))
        end

        if PhysicsEnabled()
JointEdge2D jointEdge = item:GetJointList()
        repeat while jointEdge not= undefined
            JointEdge2D jointEdge0 = jointEdge
            jointEdge = jointEdge:GetNext()
            
            RemoveJoint(jointEdge0:GetJoint())

            item:SetJointList(jointEdge)
        end
        item:SetJointList(undefined)
        end
        
if IsColliding()
CollisionEdge2D edge = item:GetCollisionList()
        repeat while edge not= undefined
            CollisionEdge2D edge0 = edge
            edge = edge:GetNext()
            collisionManager:Destroy(edge0:GetCollision())
        end
        item:SetCollisionList(undefined)

        item:DestroyNodes(collisionManager:GetBroadphase())
        item:SetCollidable(false)
        end

        item:SetLayer(undefined)

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Remove(item)
        end

        return item
    end

    /*
    This action will remove an Item2D from the end of the array of items in 
    the layer, and return the item that was removed.

    Attribute: Returns The item that was removed from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:Add(circle)
            AddLayer(layer)

            Item2D item = layer:RemoveFromEnd()
        end

        action Update(number seconds)
        end
    end

    */
    action RemoveFromEnd returns Item2D
        EnsureCorrectThread()

        Item2D item = items:RemoveFromEnd()

        if item is Control
            RemoveControl(cast(Control, item))
        end

        if PhysicsEnabled()
JointEdge2D jointEdge = item:GetJointList()
        repeat while jointEdge not= undefined
            JointEdge2D jointEdge0 = jointEdge
            jointEdge = jointEdge:GetNext()

            RemoveJoint(jointEdge0:GetJoint())

            item:SetJointList(jointEdge)
        end
        item:SetJointList(undefined)
        end

        if IsColliding()
CollisionEdge2D edge = item:GetCollisionList()
        repeat while edge not= undefined
            CollisionEdge2D edge0 = edge
            edge = edge:GetNext()
            collisionManager:Destroy(edge0:GetCollision())
        end
        item:SetCollisionList(undefined)

        item:DestroyNodes(collisionManager:GetBroadphase())
        item:SetCollidable(false)
        end

        item:SetLayer(undefined)

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Remove(item)
        end

        return item
    end

    /*
    This action will get an Item2D stored in the layer at the given index in the
    layer's internal array of items.

    Attribute: Parameter index The index to retrieve an item from in the layer's array of items.

    Attribute: Returns The Item2D stored at the index in the array.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:Add(circle)
            AddLayer(layer)

            Item2D item = layer:Get(0)
        end

        action Update(number seconds)
        end
    end

    */
    action Get(integer index) returns Item2D
        return items:Get(index)
    end

    /*
    This action will return the Item2D at the front of the layer's array of
    items. This is functionally the same as calling "Get(0)".

    Attribute: Returns The first item in the layer's array of items.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:Add(circle)
            AddLayer(layer)

            Item2D item = layer:GetFromFront()
        end

        action Update(number seconds)
        end
    end

    */
    action GetFromFront returns Item2D
        return items:GetFromFront()
    end

    /*
    This action will return the item stored at the end of the layer's array of
    items.

    Attribute: Returns The last item in the layer's array of items.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D
    use Libraries.Game.Graphics.Drawable

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Drawable circle
            circle:LoadFilledCircle(25)
            circle:SetPosition(300, 100)

            Layer2D layer
            layer:Add(circle)
            AddLayer(layer)

            Item2D item = layer:GetFromEnd()
        end

        action Update(number seconds)
        end
    end

    */
    action GetFromEnd returns Item2D
        return items:GetFromEnd()
    end

    /*
    This action will return an iterator of all the Item2D's stored inside this
    layer's array of items.

    Attribute: Returns An iterator containing all Item2D's stored in this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D
    use Libraries.Containers.Iterator

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Item2D item1
            Item2D item2
            Item2D item3

            Layer2D layer
            layer:Add(item1)
            layer:Add(item2)
            layer:Add(item3)
            AddLayer(layer)

            Iterator<Item2D> itemIterator = layer:GetIterator()
        end

        action Update(number seconds)
        end
    end

    */
    action GetIterator returns Iterator<Item2D>
        return items:GetIterator()
    end

    /*
    This action will return the number of items that have been added to this
    layer.

    Attribute: Returns The number of items stored in this layer's array of items.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Item2D item1
            Item2D item2
            Item2D item3

            Layer2D layer
            layer:Add(item1)
            layer:Add(item2)
            layer:Add(item3)
            AddLayer(layer)

            integer size = layer:GetSize()
            output "There are " + size + " items stored in the layer."
        end

        action Update(number seconds)
        end
    end

    */
    action GetSize returns integer
        return items:GetSize()
    end

    /*
    This action will return false if there are items stored in this layer's array
    of items, or true if there are none.

    Attribute: Returns Whether or not any items are stored in this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Item2D item1
            Item2D item2
            Item2D item3

            Layer2D layer
            boolean empty = layer:IsEmpty()
            output "IsEmpty() returned " + empty

            layer:Add(item1)
            layer:Add(item2)
            layer:Add(item3)

            empty = layer:IsEmpty()
            output "After adding items, IsEmpty() returns " + empty

            AddLayer(layer)            
        end

        action Update(number seconds)
        end
    end

    */
    action IsEmpty returns boolean
        return items:IsEmpty()
    end

    /*
    This action will set the value of the given index in the layer's array of 
    items to be the given Item2D. The previous value will be overwritten. If the
    index does not exist in the array (e.g., the given index is larger than the 
    number of items stored in this layer), an error will be thrown.

    Attribute: Parameter index What index to set inside the layer's array of items.
    Attribute: Parameter item The item to store at the given index in the array.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Item2D

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            Item2D item1
            Item2D item2
            Item2D item3

            Layer2D layer
            layer:Add(item1)
            layer:Add(item2)
            layer:Set(1, item3)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end

    */
    action Set(integer index, Item2D item)
        if index < items:GetSize()
            Item oldItem = items:Get(index)
            Accessibility accessibility = manager:GetAccessibility()
            if accessibility not= undefined
                accessibility:Remove(oldItem)
            end
        end

        items:Set(index, item)
        newItemAdded = true

        Accessibility accessibility = manager:GetAccessibility()
        if accessibility not= undefined
            accessibility:Add(item)
        end
    end

    /*
    This action will update all of the items contained within this Layer. The
    given number of seconds will be passed to each updated item. This is
    automatically called by the Game class as needed. Most users will never need
    to use this action directly.
    */
    action Update(number seconds)
        integer counter = 0
        repeat items:GetSize() times
            Item2D item = items:Get(counter)

            if item is Control
                Control control = cast(Control, item)
                if control:NeedsLayout()
                    shouldLayout = true
                end
            end

            item:UpdateAll(seconds)
            counter = counter + 1
        end

        if shouldLayout and layerLayout not= undefined
            layerLayout:Layout(undefined, controls, camera:GetWidth(), camera:GetHeight())
            shouldLayout = false
        end
    end
    
    /*
    This action will draw all items in this Layer on the screen (if they can be
    drawn and they aren't hidden). If the Layer is currently hidden, then this
    action will do nothing. This is automatically called by the Game class as 
    needed. Most users will never need to use this action directly.
    */
    action Draw
        if not IsShowing()
            return now
        end

        CalculateDepthSortedArray()
        Array<Item2D> sortedItems = GetDepthSortedItems()

        camera:Update()
        painter:SetCamera(camera)
        
        if (GetViewportX() not= graphics:GetViewportX() or GetViewportY() not= graphics:GetViewportY()
            or GetViewportWidth() not= graphics:GetViewportWidth() or GetViewportHeight() not= graphics:GetViewportHeight())

            graphics:SetViewport(GetViewportX(), GetViewportY(), GetViewportWidth(), GetViewportHeight())
        end

        painter:Begin()

        painter:SetClipping(false)

        integer counter = sortedItems:GetSize()
        repeat while counter > 0
            counter = counter - 1
            sortedItems:Get(counter):QueueForDrawing(painter)
        end

        painter:End()
    end

    /*
    This action will set the camera being used by this Layer. The camera is used
    to determine what will be drawn on the screen. Objects will be drawn on the
    screen as they are seen by the Layer's set camera.

    Attribute: Parameter cam The camera that this layer should use.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Game.Graphics.OrthographicCamera

    class Main is Game

        action Main
            StartGame()
        end

        action CreateGame
            OrthographicCamera camera
            Layer2D layer
            layer:SetCamera(camera)
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end

    */
    action SetCamera(Camera cam)
        camera = cam
    end

    /*
    This action will return the camera being used by this Layer. The camera is used
    to determine what will be drawn on the screen. Objects will be drawn on the
    screen as they are seen by the Layer's set camera.

    Attribute: Returns The camera currently being used by this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Game.Graphics.Camera

    class Main is Game

        Camera layerCamera = undefined

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layerCamera = layer:GetCamera()
            AddLayer(layer)
        end

        action Update(number seconds)
        end
    end

    */
    action GetCamera returns Camera
        return camera
    end

    /*
    This action will notify mouse listeners that are a part of this layer of the
    given mouse event. This is called automatically by the Game engine as 
    needed. Most users will never need to use this action directly.

    Attribute: Parameter event The MouseEvent to send to the MouseListeners.
    Attribute: Returns The Item which intercepted the event, or undefined if no Item received the event.
    */
    action ProcessMouseEvent(MouseEvent event) returns Item
        if event:GetX() < GetViewportX() or (event:GetX() > GetViewportX() + GetViewportWidth())
            or event:GetY() < GetViewportY() or (event:GetY() > GetViewportY() + GetViewportHeight())
            
            return undefined
        end

        Array<Item2D> sortedItems = GetDepthSortedItems()
        if sortedItems = undefined or sortedItems:IsEmpty()
            return undefined
        end
        boolean found = false
        integer counter = 0
        Item2D temp = undefined
        Item result = undefined

        GameInput gameInput = manager:GetInput()
        integer originalClickCount = event:clickCount

        Vector3 pointVector = camera:ScreenToWorldCoordinates(event:GetX() - GetViewportX(), event:GetY() - GetViewportY())

        repeat while counter < sortedItems:GetSize() and not found
            Item2D item = sortedItems:Get(counter)
            if item:AreChildrenProcessingMouseEvents()
                workArray:Empty()
                GetItemHierarchy(item, workArray)
                integer i = 0
                repeat while i < workArray:GetSize() and not found
                    temp = workArray:Get(i)
                    found = TestMouseInput(temp, event, pointVector, gameInput)
                    if found
                        result = temp
                    end
                    i = i + 1
                end
            else
                found = TestMouseInput(item, event, pointVector, gameInput)
                if found
                    result = item
                end
            end

            counter = counter + 1
        end

        event:clickCount = originalClickCount

        if not found
            if event:eventType = event:MOVED_MOUSE
                if mouseMovementListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat mouseMovementListeners:GetSize() times
                        mouseMovementListeners:Get(counter):MovedMouse(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:DRAGGED_MOUSE
                if mouseMovementListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat mouseMovementListeners:GetSize() times
                        mouseMovementListeners:Get(counter):DraggedMouse(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:CLICKED_MOUSE
                if mouseListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    integer startSize = mouseListeners:GetSize()
                    repeat while counter < mouseListeners:GetSize()
                        mouseListeners:Get(counter):ClickedMouse(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:RELEASED_MOUSE
                if mouseListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat mouseListeners:GetSize() times
                        mouseListeners:Get(counter):ReleasedMouse(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:SCROLLED_MOUSE
                if mouseWheelListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat mouseWheelListeners:GetSize() times
                        mouseWheelListeners:Get(counter):ScrolledMouse(event)
                        counter = counter + 1
                    end
                end
            end
        end

        if event:GetSource() not= undefined and event:eventType = event:CLICKED_MOUSE
            event:GetSource():Focus()
        end

        return result
    end

    /*
    This action finds an Item on this layer which is present at the given coordinates
    and will respond to at least one of the given InputSets.
    */
    action GetItemWithInput(number x, number y, Array<InputSet> inputValues) returns Item
        if x < GetViewportX() or (x > GetViewportX() + GetViewportWidth())
            or y < GetViewportY() or (y > GetViewportY() + GetViewportHeight())
            
            return undefined
        end

        Array<Item2D> sortedItems = GetDepthSortedItems()
        if sortedItems = undefined or sortedItems:IsEmpty()
            return undefined
        end

        integer counter = 0
        Item2D temp = undefined

        Vector3 pointVector = camera:ScreenToWorldCoordinates(x, y)
        Game game = manager:GetGame()

        repeat while counter < sortedItems:GetSize()
            Item2D item = sortedItems:Get(counter)
            if item:AreChildrenProcessingMouseEvents()
                workArray:Empty()
                GetItemHierarchy(item, workArray)
                integer i = 0
                repeat while i < workArray:GetSize()
                    temp = workArray:Get(i)
                    if DoesItemContainPoint(temp, pointVector:GetX(), pointVector:GetY())
                        InputTable table = game:GetInputTable(temp:GetInputGroup())
                        if table not= undefined
                            integer inputCounter = 0
                            repeat while inputCounter < inputValues:GetSize()
                                if table:HasKey(inputValues:Get(inputCounter))
                                    return temp
                                end
                                inputCounter = inputCounter + 1
                            end
                        end
                    end

                    i = i + 1
                end
            else
                if DoesItemContainPoint(item, pointVector:GetX(), pointVector:GetY())
                    InputTable table = game:GetInputTable(item:GetInputGroup())
                    if table not= undefined
                        integer inputCounter = 0
                        repeat while inputCounter < inputValues:GetSize()
                            if table:HasKey(inputValues:Get(inputCounter))
                                return item
                            end
                            inputCounter = inputCounter + 1
                        end
                    end
                end
            end

            counter = counter + 1
        end

        return undefined
    end

    /*
    Returns true if the provided world coordinates are contained within the given Item.
    If the Item isn't showing, or if the coordinate falls in an area that's outside of the
    clipping region of the Item, this will return false.
    */
    private action DoesItemContainPoint(Item2D item, number x, number y) returns boolean
        if item:IsShowing() and item:Contains(x, y)
            boolean isClipped = item:GetClipCoordinates(workVector2A, workVector2B)

            // If the Item is subject to clipping, only forward mouse events
            // to it if the event occurred over an unclipped portion of it.
            if isClipped = false or
                    ((x >= workVector2A:GetX() and x <= workVector2A:GetY()) and
                     (y >= workVector2B:GetX() and y <= workVector2B:GetY()))
        
                return true
            end
        end

        return false
    end

    private action TestMouseInput(Item2D item, MouseEvent event, Vector3 pointVector, GameInput gameInput) returns boolean
        if DoesItemContainPoint(item, pointVector:GetX(), pointVector:GetY())
            event:SetSource(item)
            event:clickCount = gameInput:GetClickCount(item) + 1
            item:ProcessMouseEvent(event)
            return event:WasEventHandled()
        else
            return false
        end
    end

    private action GetItemHierarchy(Item2D root, Array<Item2D> array)
        // Don't add elements that are hidden, nor their children
        if root:IsShowing() = false
            return now
        end

        Array<Item2D> children = root:GetChildren()
        integer i = children:GetSize()
        repeat while i > 0
            i = i - 1
            GetItemHierarchy(children:Get(i), array)
        end

        array:Add(root)
    end

    integer lastDepthSort = -1
    Array<Item2D> depthSortTemp
    private action CalculateDepthSortedArray
        depthSortedArray:Empty(false)
        
        integer i = items:GetSize()

        repeat while i > 0
            i = i - 1
            GetDepthSortedItems(items:Get(i), depthSortedArray)
        end

        if lastDepthSort > depthSortedArray:GetSize() 
            depthSortedArray:ClearContents(depthSortedArray:GetSize(), lastDepthSort - 1)
        end
        lastDepthSort = depthSortedArray:GetSize()

        if shouldSortDepthBuffer
            if depthSortTemp:GetSize() not= depthSortedArray:GetSize() 
                depthSortTemp:SetMaxSize(depthSortedArray:GetSize())
                depthSortTemp:SetSize(depthSortedArray:GetSize())
            end
            depthSortedArray:Sort(depthSorter, depthSortTemp)
        end
    end

    /*
    This action returns an Array of all of the visible elements on this Layer, 
    including elements nested into other Items as children, sorted by ascending 
    depth. Items which are not visible (i.e. IsShowing() returns false) will not
    be included in the Array. In case of Items with equal depth, children items
    will appear earlier in the Array than their parent items. This is useful for
    mouse detection but does not match draw order.
    */
    private action GetDepthSortedItems returns Array<Item2D>
        return depthSortedArray
    end

    /*
    Used by GetDepthSortedItems() to recursively collect items. The given item
    adds itself to the array then recurses on the children elements.
    */
    private action GetDepthSortedItems(Item2D item, Array<Item2D> array)
        if item:IsShowing() = false
            return now
        end

        Array<Item2D> children = item:GetChildren()
        integer i = children:GetSize()

        if item:IsCustomDrawing() = false
            repeat while i > 0
                i = i - 1
                Item2D child = children:Get(i)
                GetDepthSortedItems(child, array)
            end
        end

        array:Add(item)
    end

    /*
    This action will notify touch listeners that are a part of this layer of the
    given touch event. This is called automatically by the Game engine as 
    needed. Most users will never need to use this action directly.

    Attribute: Parameter event The TouchEvent to send to the TouchListeners.
    */
    action ProcessTouchEvent(TouchEvent event) returns Item
        
        boolean processing = true
        integer counter = items:GetSize()
        Item2D temp = undefined
        Item result = undefined

        Vector3 pointVector = camera:ScreenToWorldCoordinates(event:GetX(), event:GetY())

        repeat while counter > 0 and processing
            counter = counter - 1
            temp = items:Get(counter):GetItemAt(pointVector:GetX(), pointVector:GetY())

            if temp not= undefined
                event:SetSource(temp)
                temp:ProcessTouchEvent(event)
                processing = not event:WasEventHandled()
                if event:WasEventHandled()
                    result = temp
                end
            end
        end

        if processing

            if event:eventType = event:MOVED or event:eventType = event:STATIONARY
                if touchListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat touchListeners:GetSize() times
                        touchListeners:Get(counter):ContinuedTouch(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:BEGAN
                if touchListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat touchListeners:GetSize() times
                        touchListeners:Get(counter):BeganTouch(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:ENDED or event:eventType = event:CANCELLED
                if touchListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat touchListeners:GetSize() times
                        touchListeners:Get(counter):EndedTouch(event)
                        counter = counter + 1
                    end
                end

            end

        end

//        if event:GetSource() not= undefined and event:eventType = event:BEGAN
//            event:GetSource():Focus()
//        end

        return result
    end

    /*
    This action will notify gesture listeners that are a part of this layer of the
    given gesture event. This is called automatically by the Game engine as 
    needed. Most users will never need to use this action directly.

    Attribute: Parameter event The GestureEvent to send to the TouchListeners.
    */
    action ProcessGestureEvent(GestureEvent event) returns Item
        
        boolean processing = true
        integer counter = items:GetSize()
        Item2D temp = undefined
        Item result = undefined

/*
    public constant integer SINGLE_TAP = 1
    public constant integer DOUBLE_TAP = 2
    public constant integer SWIPE = 3
    public constant integer PAN = 4
    public constant integer LONG_PRESS = 5
    public constant integer PINCH = 6
*/

        Vector3 pointVector = camera:ScreenToWorldCoordinates(event:GetX(), event:GetY())

        repeat while counter > 0 and processing
            counter = counter - 1
            temp = items:Get(counter):GetItemAt(pointVector:GetX(), pointVector:GetY())

            if temp not= undefined
                event:SetSource(temp)
                temp:ProcessGestureEvent(event)
                processing = not event:WasEventHandled()
                if event:WasEventHandled()
                    result = temp
                end
            end
        end

        if processing
            if event:eventType = event:SINGLE_TAP
                if gestureListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat gestureListeners:GetSize() times
                        gestureListeners:Get(counter):OnSingleTap(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:DOUBLE_TAP
                if gestureListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat gestureListeners:GetSize() times
                        gestureListeners:Get(counter):OnDoubleTap(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:SWIPE
                if gestureListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat gestureListeners:GetSize() times
                        gestureListeners:Get(counter):OnSwipe(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:PAN
                if gestureListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat gestureListeners:GetSize() times
                        gestureListeners:Get(counter):OnPan(event)
                        counter = counter + 1
                    end
                end
        
            elseif event:eventType = event:LONG_PRESS
                if gestureListeners:GetSize() > 0
                    counter = 0
                    event:SetEventHandled(true)
                    repeat gestureListeners:GetSize() times
                        gestureListeners:Get(counter):OnDoubleTap(event)
                        counter = counter + 1
                    end
                end

            elseif event:eventType = event:PINCH
                if event:timingCode = event:BEGIN
                    if gestureListeners:GetSize() > 0
                        counter = 0
                        event:SetEventHandled(true)
                        repeat gestureListeners:GetSize() times
                            gestureListeners:Get(counter):OnPinchBegin(event)
                            counter = counter + 1
                        end
                    end
                elseif event:timingCode = event:FINISH
                    if gestureListeners:GetSize() > 0
                        counter = 0
                        event:SetEventHandled(true)
                        repeat gestureListeners:GetSize() times
                            gestureListeners:Get(counter):OnPinchEnd(event)
                            counter = counter + 1
                        end
                    end
                elseif event:timingCode = event:CONTINUE
                    if gestureListeners:GetSize() > 0
                        counter = 0
                        event:SetEventHandled(true)
                        repeat gestureListeners:GetSize() times
                            gestureListeners:Get(counter):OnPinchContinue(event)
                            counter = counter + 1
                        end
                    end
                end
            end
        end

        return result
    end

    /*
    This action will add a MouseListener to the layer. When the layer receives a
    mouse event, it will first try to find the topmost item which can handle the
    event. If the event is not handled, then all MouseListeners in the layer 
    will receive the event.

    Attribute: Parameter listener The MouseListener to add to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.MouseListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseListener.
        MouseListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddMouseListener(myListener)
            AddLayer(layer)
        end

        action Update(number seconds)
        end

    end

    */
    action AddMouseListener(MouseListener listener)
        mouseListeners:Add(listener)
    end

    /*
    This action will add a MouseMovementListener to the layer. When the layer
    receives a mouse event, it will first try to find the topmost item which can
    handle the event. If the event is not handled, then all 
    MouseMovementListeners in the layer will receive the event.

    Attribute: Parameter listener The MouseMovementListener to add to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.MouseMovementListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseMovementListener.
        MouseMovementListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddMouseMovementListener(myListener)
            AddLayer(layer)
        end

        action Update(number seconds)
        end

    end

    */
    action AddMouseMovementListener(MouseMovementListener listener)
        mouseMovementListeners:Add(listener)
    end

    /*
    This action will add a MouseWheelListener to the layer. When the layer
    receives a mouse event, it will first try to find the topmost item which can
    handle the event. If the event is not handled, then all 
    MouseWheelListeners in the layer will receive the event.

    Attribute: Parameter listener The MouseWheelListener to add to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.MouseWheelListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseWheelListener.
        MouseWheelListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddMouseWheelListener(myListener)
            AddLayer(layer)
        end

        action Update(number seconds)
        end

    end

    */
    action AddMouseWheelListener(MouseWheelListener listener)
        mouseWheelListeners:Add(listener)
    end

    /*
    This action will add a TouchListener to the layer. When the layer
    receives a touch event, it will first try to find the topmost item which can
    handle the event. If the event is not handled, then all 
    TouchListeners in the layer will receive the event.

    Attribute: Parameter listener The TouchListener to add to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.TouchListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from TouchListener.
        TouchListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddTouchListener(myListener)
            AddLayer(layer)
        end

        action Update(number seconds)
        end

    end

    */
    action AddTouchListener(TouchListener listener)
        touchListeners:Add(listener)
    end
    
    /*
    This action will remove a MouseListener from the layer. The listener will no
    longer receive events from the layer. If the given MouseListener is not on
    the layer before calling this action, then this action will have no effect.

    Attribute: Parameter listener The MouseListener to remove from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.MouseListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseListener.
        MouseListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddMouseListener(myListener)
            AddLayer(layer)

            layer:RemoveMouseListener(myListener)
        end

        action Update(number seconds)
        end

    end

    */
    action RemoveMouseListener(MouseListener listener)
        mouseListeners:Remove(listener)
    end

    /*
    This action will remove a MouseMovementListener from the layer. The listener
    will no longer receive events from the layer. If the given 
    MouseMovementListener is not on the layer before calling this action, then 
    this action will have no effect.

    Attribute: Parameter listener The MouseMovementListener to remove from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.MouseMovementListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseMovementListener.
        MouseMovementListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddMouseMovementListener(myListener)
            AddLayer(layer)

            layer:RemoveMouseMovementListener(myListener)
        end

        action Update(number seconds)
        end

    end

    */
    action RemoveMouseMovementListener(MouseMovementListener listener)
        mouseMovementListeners:Remove(listener)
    end

    /*
    This action will remove a MouseWheelListener from the layer. The listener 
    will no longer receive events from the layer. If the given 
    MouseWheelListener is not on the layer before calling this action, then this
    action will have no effect.

    Attribute: Parameter listener The MouseWheelListener to remove from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.MouseWheelListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseWheelListener.
        MouseWheelListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddMouseWheelListener(myListener)
            AddLayer(layer)

            layer:RemoveMouseWheelListener(myListener)
        end

        action Update(number seconds)
        end

    end

    */
    action RemoveMouseWheelListener(MouseWheelListener listener)
        mouseWheelListeners:Remove(listener)
    end

    /*
    This action will remove a TouchListener from the layer. The listener will no
    longer receive events from the layer. If the given TouchListener is not on
    the layer before calling this action, then this action will have no effect.

    Attribute: Parameter listener The TouchListener to remove from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.TouchListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from TouchListener.
        TouchListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddTouchListener(myListener)
            AddLayer(layer)

            layer:RemoveTouchListener(myListener)
        end

        action Update(number seconds)
        end

    end

    */
    action RemoveTouchListener(TouchListener listener)
        touchListeners:Remove(listener)
    end

    /*
    This action will add a GestureListener to the layer. When the layer
    receives a gesture event, it will first try to find the topmost item which can
    handle the event. If the event is not handled, then all 
    GestureListeners in the layer will receive the event.

    Attribute: Parameter listener The GestureListener to add to this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.GestureListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from GestureListener.
        GestureListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddGestureListener(myListener)
            AddLayer(layer)
        end

        action Update(number seconds)
        end

    end

    */
    action AddGestureListener(GestureListener listener)
        gestureListeners:Add(listener)
    end

    /*
    This action will remove a GestureListener from the layer. The listener will no
    longer receive events from the layer. If the given GestureListener is not on
    the layer before calling this action, then this action will have no effect.

    Attribute: Parameter listener The GestureListener to remove from this layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.GestureListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from GestureListener.
        GestureListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddGestureListener(myListener)
            AddLayer(layer)

            layer:RemoveGestureListener(myListener)
        end

        action Update(number seconds)
        end

    end

    */
    action RemoveGestureListener(GestureListener listener)
        gestureListeners:Remove(listener)
    end

    /*
    This action will remove all MouseListeners from the layer. 

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.MouseListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseListener.
        MouseListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddMouseListener(myListener)
            AddLayer(layer)

            layer:EmptyMouseListeners()
        end

        action Update(number seconds)
        end

    end

    */
    action EmptyMouseListeners
        mouseListeners:Empty()
    end

    /*
    This action will remove all MouseMovementListeners from the layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.MouseMovementListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseMovementListener.
        MouseMovementListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddMouseMovementListener(myListener)
            AddLayer(layer)

            layer:EmptyMouseMovementListeners()
        end

        action Update(number seconds)
        end

    end

    */
    action EmptyMouseMovementListeners
        mouseMovementListeners:Empty()
    end

    /*
    This action will remove all MouseWheelListeners from the layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.MouseWheelListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from MouseWheelListener.
        MouseWheelListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddMouseWheelListener(myListener)
            AddLayer(layer)

            layer:EmptyMouseWheelListeners()
        end

        action Update(number seconds)
        end

    end

    */
    action EmptyMouseWheelListeners
        mouseWheelListeners:Empty()
    end

    /*
    This action will remove all TouchListeners from the layer.

    Attribute: Example

    use Libraries.Game.Game
    use Libraries.Game.Layer2D
    use Libraries.Interface.Events.TouchListener

    class Main is Game

        // For most programs, this should be replaced with 
        // a custom class inheriting from TouchListener.
        TouchListener myListener

        action Main
            StartGame()
        end

        action CreateGame
            Layer2D layer
            layer:AddTouchListener(myListener)
            AddLayer(layer)

            layer:EmptyTouchListeners()
        end

        action Update(number seconds)
        end

    end

    */
    action EmptyTouchListeners
        touchListeners:Empty()
    end

    /*
    Using SetColorFilter will tint all drawn objects on the layer that do not
    have their own custom color tint. For example, using a red color filter will
    make all objects drawn on the layer to appear to be more red.
    */
    action SetColorFilter(Color color)
        painter:SetColor(color)
    end

    /*
    SetColorFilter can be called using four number parameters instead of a
    color object. The four parameters are the red, green, blue, and opacity
    of the filter, respectively. All four of the parameters should be between 0
    and 1, representing between 0% and 100% of that color component. For example,
    a value of 0 for red means that the tinting color will have no red, while a
    value of 1 will have all red components. An opacity of 0 is totally
    transparent, while an opacity of 1 will be totally visible. 
    */
    action SetColorFilter(number red, number green, number blue, number alpha)
        painter:SetColor(red, green, blue, alpha)
    end

    /*
    AddCollisionListener will add a collision listener to this layer. The
    collision listener will be notified of collisions occuring on this layer, 
    and is responsible for managing the collision events.
    */
    action AddCollisionListener(CollisionListener2D listener)
        collisionManager:AddCollisionListener(listener)
    end

    /*
    RemoveCollisionListener removes a collision listener to this layer. The
    collision listener will no longer be notified of collision events occurring
    on this layer. If the given listener is not a part of this layer, then this
    action will have no effect.
    */
    action RemoveCollisionListener(CollisionListener2D listener)
        collisionManager:RemoveCollisionListener(listener)
    end
    /*
    This action gets the list of items on this layer that are colliding and
    returns it as an array.
    */
    action GetCollisionList returns CollisionEvent2D
        return collisionManager:GetCollisionList()
    end

    /*
    This action gets the collision manager for this object which is responsible
    for managing the collisions between all colliding items on this layer.
    */
    action GetCollisionManager returns CollisionManager2D
        return collisionManager
    end

    /*
    This action triggers collision detection for this layer during a frame in
    the Game engine. This action will automatically be called by the Game class
    as necessary. Most users should never need to use this action directly.
    */
    action TestForCollisions(number seconds)
        if not collide
            return now
        end
        SetUpdateTransforms(false)

        if newItemAdded
            collisionManager:FindNewCollisions()
            newItemAdded = false
        end

        collisionManager:Collide()

        integer i = 0
        repeat items:GetSize() times
            Item2D body = items:Get(i)
            if body:IsPhysicsEnabled()
                body:SetCollisionGroupFlag(false)
            end
            if body:IsCollidable() or body:IsPhysicsEnabled()
                body:SetTransform0(body:GetTransform())
            end
            i = i + 1
        end

        if physicsEnabled
            StepPhysics(seconds)
            SetUpdateTransforms(true)
            SetScreenPositionsFromPhysicsPositions()
        end

        SetUpdateTransforms(true)

        i = 0
        repeat items:GetSize() times
            Item2D item = items:Get(i)
            SynchronizeAllNodes(item)
            i = i + 1
        end

        collisionManager:FindNewCollisions()
    end

    private action SynchronizeAllNodes(Item2D item)
        if item:IsCollidable() or item:IsPhysicsEnabled()
            item:SynchronizeNodes()
        end
            
        integer i = 0
        Array<Item2D> children = item:GetChildren()
        repeat while i < children:GetSize()
            SynchronizeAllNodes(children:Get(i))
            i = i + 1
        end
    end

    private action SetUpdateTransforms(boolean flag) 
        integer i = 0
        repeat items:GetSize() times
            Item2D item = items:Get(i)
            item:SetUpdateTransform(flag)
            i = i + 1
        end
    end

    private action SetScreenPositionsFromPhysicsPositions
        integer i = 0
        repeat items:GetSize() times
            Item2D item = items:Get(i)
            if item:IsPhysicsEnabled()
                item:SetScreenPositionFromPhysicsPosition()
            end
            i = i + 1
        end
    end

    /*
    This action indicates that the layer has received a new item that it must
    manage during collision detection. This is automatically called by the Game
    engine as necessary, and most users should never need to use this action
    directly.
    */
    action SetNewItemAdded(boolean flag)
        newItemAdded = flag
    end

    action RequireSimulation(boolean flag)
        if requireSimulation = flag
            return now
        end

        requireSimulation = flag
        if requireSimulation
            integer i = 0
            repeat items:GetSize() times
                Item2D item = items:Get(i)
                item:Simulate(true)
                i = i + 1
            end
        end
    end

    action IsSimulationRequired returns boolean
        return requireSimulation
    end

    action SetSubStepping(boolean flag)
        subStepping = flag
    end

    action IsSubStepping returns boolean
        return subStepping
    end

    TimeStep timeStep

    private action StepPhysics(number seconds)
        number dt = seconds
        timeStep:SetTimeStep(dt)
        number inverse_dt = 0
        if dt > 0
            inverse_dt = 1.0 / dt
        end
        timeStep:SetInverseTimeStep(inverse_dt)

        number dtRatio = inverseDeltaTime0 * dt
        timeStep:SetTimeStepRatio(dtRatio)
        
        timeStep:SetWarmStarting(warmStarting)
        
        if stepComplete and timeStep:GetTimeStep() > 0
            SolvePhysics(timeStep)
        end

        if continuousPhysics and timeStep:GetTimeStep() > 0
            SolveTimeOfImpact(timeStep)
        end

        if timeStep:GetTimeStep() > 0
            inverseDeltaTime0 = timeStep:GetInverseTimeStep()
        end

        if automaticallyClearForces
            ClearForces()
        end
    end

    action ClearForces
        integer i = 0
        repeat items:GetSize() times
            Item2D body = items:Get(i)
            if body:IsPhysicsEnabled()
                Vector2 zero
                zero:SetZero()
                body:SetForce(zero)
                body:SetTorque(0)
            end
            i = i + 1
        end
    end

    action SetWarmStarting(boolean flag)
        warmStarting = flag
    end

    action IsWarmStarting returns boolean
        return warmStarting
    end

    action SetContinuousPhysics(boolean flag)
        continuousPhysics = flag
    end

    action IsContinuousPhysics returns boolean
        return continuousPhysics
    end

    action SetGravity(Vector2 gravity)
        me:gravity:Set(gravity)
    end

    action SetGravity(number gravityX, number gravityY)
        gravity:Set(gravityX, gravityY)
    end

    action GetGravity returns Vector2
        return gravity
    end

    action SetAutomaticallyClearForces(boolean flag)
        automaticallyClearForces = flag
    end

    action AutomaticallyClearForces returns boolean
        return automaticallyClearForces
    end

    private action SolvePhysics(TimeStep step)
        CollisionEvent2D collision = collisionManager:GetCollisionList()
        repeat until collision = undefined
            collision:SetInCollisionGroup(false)
            collision = collision:GetNext()
        end

        i = 0
        repeat joints:GetSize() times
            Joint2D joint = joints:Get(i)
            joint:SetInCollisionGroup(false)
            i = i + 1
        end

        i = 0
        repeat items:GetSize() times
            Item2D seed = items:Get(i)
            if not seed:IsPhysicsEnabled()
                // continue with loop -- this item does not need physics solved
            elseif seed:GetCollisionGroupFlag()
                // continue with loop -- this item has already had physics solved
            elseif not seed:IsSimulated()
                // continue with loop -- this item is not currently being simulated
            elseif seed:IsUnmovable()
                // continue with loop -- this item is unmovable and cannot start off a collision group
            else
                island:Empty()
                stack:Empty()
                stack:Push(seed)
                seed:SetCollisionGroupFlag(true)

                repeat while not stack:IsEmpty()
                    Item2D body = stack:Pop()
                    island:Add(body)

                    body:Simulate(true)

                    if body:IsUnmovable()
                        // continue -- don't look for colliding items with unmovable items
                        // to add to a collision group -- this keeps collision groups small
                        // and faster to solve -- the items colliding with an unmovable
                        // item will be a part of a separate collision group
                    else
                        CollisionEdge2D edge = body:GetCollisionList()
                        repeat while edge not= undefined
                            CollisionEvent2D collision1 = edge:GetCollision()
                            if collision1:InCollisionGroup()
                                // continue with group -- the collision has already been
                                // accounted for in the collision group
                            elseif not collision1:IsEnabled() or not collision1:IsTouching() or not collision1:HasPhysicsResponse()
                                // continue with group -- this collision is not currently
                                // colliding (close, may collide in a few frames) or this
                                // collision has been disalbed from producing a physics
                                // response
                            else
                                boolean physicsA = collision1:GetItemA():IsPhysicsEnabled()
                                boolean physicsB = collision1:GetItemB():IsPhysicsEnabled()
                                boolean sensor = not physicsA or not physicsB

                                if sensor
                                    // continue with group -- one or both items
                                    // does not have physics enabled
                                else
                                    island:Add(collision1)
                                    collision1:SetInCollisionGroup(true)

                                    Item2D other = edge:GetOther()
                                    if other:GetCollisionGroupFlag()
                                        // continue with group -- the other item
                                        // is already in this group
                                    else
                                        stack:Push(other)
                                        other:SetCollisionGroupFlag(true)
                                    end
                                end
                            end
                            edge = edge:GetNext()
                        end

                        JointEdge2D jointEdge = body:GetJointList()
                        repeat while jointEdge not= undefined
                            Joint2D joint = jointEdge:GetJoint()
                            if joint:InCollisionGroup()
                                // continue with group -- the joint has already been
                                // accounted for in the collision group
                            else
                                Item2D other = jointEdge:GetOther()

                                island:Add(joint)
                                joint:SetInCollisionGroup(true)

                                if other:GetCollisionGroupFlag()
                                    // continuee with group -- the other item is
                                    // already in the group
                                else
                                    stack:Push(other)
                                    other:SetCollisionGroupFlag(true)
                                end
                            end

                            jointEdge = jointEdge:GetNext()
                        end

                        integer k = 0
                        repeat body:GetItemCount() times
                            Item2D child = body:GetItem(k)
                            if child:GetCollisionGroupFlag()
                                // continue with group -- the child item is
                                // already in the group
                            else
                                stack:Push(child)
                                child:SetCollisionGroupFlag(true)
                            end
                            k = k + 1
                        end
                    end
                end

                island:Solve(step, gravity, requireSimulation)

                integer j = 0
                repeat island:GetItemCount() times
                    Item2D body = island:GetItem(j)
                    if body:IsUnmovable()
                        body:SetCollisionGroupFlag(false)
                    end
                    j = j + 1
                end
            end
            i = i + 1
        end

        i = 0
        repeat items:GetSize() times
            Item2D body = items:Get(i)
            if not body:IsPhysicsEnabled() 
                // do nothing -- physics is not enabled for this item
            elseif (not body:GetCollisionGroupFlag()) and body:GetResponsiveness() not= body:GetPhysicsProperties():UNMOVABLE
                // do nothing -- this item was never a part of a physics group
            elseif body:GetResponsiveness() = body:GetPhysicsProperties():UNMOVABLE and not body:HasMoved()
                // do nothing -- this item is unmovable so synchronizing its nodes
                // is not necessary
            else
                body:SynchronizeNodes()
                body:SetHasMoved(false)
            end
            i = i + 1
        end

        collisionManager:FindNewCollisions()
    end

    private action SolveTimeOfImpact(TimeStep timeStep)
        CollisionGroup2D island = toiIsland

        if stepComplete
            integer i = 0
            repeat items:GetSize() times
                Item2D body = items:Get(i)
                if body:IsPhysicsEnabled()
                    body:SetCollisionGroupFlag(false)
                end
                body:GetSweep():SetAlpha0(0)
                i = i + 1
            end

            CollisionEvent2D c = collisionManager:GetCollisionList()
            repeat while c not= undefined
                c:SetTimeOfImpactSolved(false)
                c:SetInCollisionGroup(false)
                c:SetTimeOfImpactCount(0)
                c:SetTimeOfImpact(1)

                c = c:GetNext()
            end
        end

        boolean continue = true

        repeat while continue
            CollisionEvent2D minCollision = undefined
            number minAlpha = 1

            CollisionEvent2D c = collisionManager:GetCollisionList()
            repeat while c not= undefined
                if not c:IsEnabled()
                    // skip to end of loop
                elseif c:GetTimeOfImpactCount() > 8
                    // skip to end of loop
                else
                    number alpha = 1
                    if c:TimeOfImpactSolved()
                        alpha = c:GetTimeOfImpact()
                    else
                        Item2D bA = c:GetItemA()
                        Item2D bB = c:GetItemB()

                        if not bA:IsPhysicsEnabled() or not bB:IsPhysicsEnabled()
                            // skip to end of loop; these items don't need to be solved
                            // for physical interactions because physics is not enabled
                        else
                            integer typeA = bA:GetResponsiveness()
                            integer typeB = bB:GetResponsiveness()

                            boolean activeA = bA:IsSimulated() and typeA not= bA:GetPhysicsProperties():UNMOVABLE
                            boolean activeB = bB:IsSimulated() and typeB not= bB:GetPhysicsProperties():UNMOVABLE

                            if not activeA and not activeB
                                // skip to end of loop
                            else
                                boolean collideA = bA:IsFastMoving() or typeA not= bA:GetPhysicsProperties():RESPONSIVE
                                boolean collideB = bB:IsFastMoving() or typeB not= bB:GetPhysicsProperties():RESPONSIVE

                                if collideA = false and collideB = false
                                    // skip to end of loop
                                else
                                    number alpha0 = bA:GetSweep():GetAlpha0()

                                    if bA:GetSweep():GetAlpha0() < bB:GetSweep():GetAlpha0()
                                        alpha0 = bB:GetSweep():GetAlpha0()
                                        bA:GetSweep():Advance(alpha0)
                                    elseif bB:GetSweep():GetAlpha0() < bA:GetSweep():GetAlpha0()
                                        alpha0 = bA:GetSweep():GetAlpha0()
                                        bB:GetSweep():Advance(alpha0)
                                    end

                                    integer indexA = c:GetChildIndexA()
                                    integer indexB = c:GetChildIndexB()

                                    toiInput:GetProxyA():Set(bA:GetShape(), indexA)
                                    toiInput:GetProxyB():Set(bB:GetShape(), indexB)
                                    toiInput:GetSweepA():Set(bA:GetSweep())
                                    toiInput:GetSweepB():Set(bB:GetSweep())
                                    toiInput:SetTimeMax(1)

                                    toi:TimeOfImpact(toiOutput, toiInput)

                                    number beta = toiOutput:GetTime()
                                    if toiOutput:GetState() = toiOutput:TOUCHING
                                        alpha = alpha0 + (1.0 - alpha0) * beta
                                        if alpha > 1.0
                                            alpha = 1.0
                                        end
                                    else
                                        alpha = 1.0
                                    end

                                    c:SetTimeOfImpact(alpha)
                                    c:SetTimeOfImpactSolved(true)
                                end
                            end
                        end
                    end

                    if alpha < minAlpha
                        minCollision = c
                        minAlpha = alpha
                    end
                end
                c = c:GetNext()
            end

            if minCollision = undefined or 1.0 - 10.0 * 0.00000011920928955078125 < minAlpha
                stepComplete = true
                continue = false
            end

            if continue
                Item2D bA = minCollision:GetItemA()
                Item2D bB = minCollision:GetItemB()

                backup1:Set(bA:GetSweep())
                backup2:Set(bB:GetSweep())

                minCollision:DispatchCollision(collisionManager:GetCollisionListeners())
                minCollision:SetTimeOfImpactSolved(false)
                minCollision:SetTimeOfImpactCount(minCollision:GetTimeOfImpactCount() + 1)

                if not minCollision:IsEnabled() or not minCollision:IsTouching()
                    minCollision:SetEnabled(false)
                    bA:GetSweep():Set(backup1)
                    bB:GetSweep():Set(backup2)
                    bA:SynchronizeTransform()
                    bB:SynchronizeTransform()
                else
                    bA:Simulate(true)
                    bB:Simulate(true)

                    island:Empty()
                    island:Add(bA)
                    island:Add(bB)
                    island:Add(minCollision)

                    bA:SetCollisionGroupFlag(true)
                    bB:SetCollisionGroupFlag(true)
                    minCollision:SetInCollisionGroup(true)

                    tempBody0 = bA
                    tempBody1 = bB
                    integer i = 0
                    repeat 2 times
                        Item2D body = tempBody0
                        if i = 1
                            body = tempBody1
                        end

                        if body:GetResponsiveness() = body:GetPhysicsProperties():RESPONSIVE
                            CollisionEdge2D ce = body:GetCollisionList()
                            repeat while ce not= undefined
                                CollisionEvent2D collision = ce:GetCollision()

                                if collision:InCollisionGroup()
                                    //nothing to do; collision is already in island
                                else
                                    Item2D other = ce:GetOther()
                                    if other:GetResponsiveness() = other:GetPhysicsProperties():RESPONSIVE and not body:IsFastMoving() and not other:IsFastMoving()
                                        //nothing to do; one or both bodies is not flagged as needing TOI solving
                                    else
                                        boolean sensorA = not collision:GetItemA():IsPhysicsEnabled()
                                        boolean sensorB = not collision:GetItemB():IsPhysicsEnabled()
                                        if sensorA or sensorB
                                            //nothing to do; one or both bodies is not flagged as needing physics solving
                                        else
                                            backup1:Set(other:GetSweep())
                                            if not other:GetCollisionGroupFlag()
                                                other:Advance(minAlpha)
                                            end

                                            collision:DispatchCollision(collisionManager:GetCollisionListeners())

                                            if not collision:IsEnabled() or not collision:IsTouching()
                                                other:GetSweep():Set(backup1)
                                                other:SynchronizeTransform()
                                            else
                                                collision:SetInCollisionGroup(true)
                                                island:Add(collision)

                                                if not other:GetCollisionGroupFlag()
                                                    other:SetCollisionGroupFlag(true)

                                                    if other:GetResponsiveness() not= other:GetPhysicsProperties():UNMOVABLE
                                                        other:Simulate(true)
                                                    end

                                                    island:Add(other)
                                                end
                                            end
                                        end
                                    end
                                end
                                ce = ce:GetNext()
                            end
                        end
                        i = i + 1
                    end

                    substep:SetTimeStep((1.0 - minAlpha) * timeStep:GetTimeStep())
                    substep:SetInverseTimeStep(1 / substep:GetTimeStep())
                    substep:SetTimeStepRatio(1.0)
                    substep:SetPositionIterations(20)
                    substep:SetVelocityIterations(timeStep:GetVelocityIterations())
                    substep:SetWarmStarting(false)
                    island:SolveTimeOfImpact(substep, bA:GetCollisionGroupIndex(), bB:GetCollisionGroupIndex())

                    integer j = 0
                    repeat while j < island:GetItemCount()
                        Item2D body = island:GetItem(j)
                        body:SetCollisionGroupFlag(false)

                        if body:GetResponsiveness() = body:GetPhysicsProperties():RESPONSIVE
                            body:SynchronizeNodes()
                            
                            CollisionEdge2D ce = body:GetCollisionList()
                            repeat while ce not= undefined
                                ce:GetCollision():SetInCollisionGroup(false)
                                ce:GetCollision():SetTimeOfImpactSolved(false)
                                ce = ce:GetNext()
                            end
                        end
                        j = j + 1
                    end

                    collisionManager:FindNewCollisions()

                    if subStepping
                        stepComplete = false
                        continue = false
                    end
                end
            end
        end
    end

    action EnablePhysics(boolean flag)
        if not flag
            island = undefined
            joints = undefined
            
            toiIsland = undefined
            toiInput = undefined
            toiOutput = undefined
            substep = undefined
            tempBody0 = undefined
            tempBody1 = undefined
            backup1 = undefined
            backup2 = undefined
            toi = undefined
        else
            Array<Joint2D> joints2
            CollisionGroup2D island2
            island = island2
            joints = joints2
            
            CollisionGroup2D toiIsland2
            TimeOfImpactInput2D toiInput2
            TimeOfImpactOutput2D toiOutput2
            TimeStep substep2
            Item2D tempBody02
            Item2D tempBody12
            Sweep2D backup12
            Sweep2D backup22
            TimeOfImpact2D toi2
            
            toiIsland = toiIsland2
            toiInput = toiInput2
            toiOutput = toiOutput2
            substep = substep2
            tempBody0 = tempBody02
            tempBody1 = tempBody12
            backup1 = backup12
            backup2 = backup22
            toi = toi2
        end
        physicsEnabled = flag
    end

    action PhysicsEnabled returns boolean
        return physicsEnabled
    end

    action AddJoint(Joint2D joint)
        joints:Add(joint)

        joint:GetEdgeA():SetJoint(joint)
        joint:GetEdgeA():SetOther(joint:GetItemB())
        joint:GetEdgeA():SetPrevious(undefined)
        joint:GetEdgeA():SetNext(joint:GetItemA():GetJointList())
        if joint:GetItemA():GetJointList() not= undefined
            joint:GetItemA():GetJointList():SetPrevious(joint:GetEdgeA())
        end
        joint:GetItemA():SetJointList(joint:GetEdgeA())

        joint:GetEdgeB():SetJoint(joint)
        joint:GetEdgeB():SetOther(joint:GetItemA())
        joint:GetEdgeB():SetPrevious(undefined)
        joint:GetEdgeB():SetNext(joint:GetItemB():GetJointList())
        if joint:GetItemB():GetJointList() not= undefined
            joint:GetItemB():GetJointList():SetPrevious(joint:GetEdgeB())
        end
        joint:GetItemB():SetJointList(joint:GetEdgeB())

        //TODO: Collision filtering?
    end

    action RemoveJoint(Joint2D joint)
        joints:Remove(joint)

        Item2D itemA = joint:GetItemA()
        Item2D itemB = joint:GetItemB()

        itemA:Simulate(true)
        itemB:Simulate(true)

        if joint:GetEdgeA():GetPrevious() not= undefined
            joint:GetEdgeA():GetPrevious():SetNext(joint:GetEdgeA():GetNext())
        end

        if joint:GetEdgeA():GetNext() not= undefined
            joint:GetEdgeA():GetNext():SetPrevious(joint:GetEdgeA():GetPrevious())
        end

        if joint:GetEdgeA() = itemA:GetJointList()
            itemA:SetJointList(joint:GetEdgeA():GetNext())
        end

        joint:GetEdgeA():SetPrevious(undefined)
        joint:GetEdgeA():SetNext(undefined)

        if joint:GetEdgeB():GetPrevious() not= undefined
            joint:GetEdgeB():GetPrevious():SetNext(joint:GetEdgeB():GetNext())
        end

        if joint:GetEdgeB():GetNext() not= undefined
            joint:GetEdgeB():GetNext():SetPrevious(joint:GetEdgeB():GetPrevious())
        end

        if joint:GetEdgeB() = itemB:GetJointList()
            itemB:SetJointList(joint:GetEdgeB():GetNext())
        end

        joint:GetEdgeB():SetPrevious(undefined)
        joint:GetEdgeB():SetNext(undefined)

        //TODO: collision filtering?
    end

    action SetSimulationThreshold(number threshold)
        island:SetSimulationThreshold(threshold)
        toiIsland:SetSimulationThreshold(threshold)
    end

    action GetSimulationThreshold returns number
        return island:GetSimulationThreshold()
    end

    action Resize(ResizeEvent event)
        integer width = event:GetWidth()
        integer height = event:GetHeight()
        number xAdjust = (width - camera:GetWidth()) / 2.0
        number yAdjust = (height - camera:GetHeight()) / 2.0

        if GetViewportX() = 0 and GetViewportY() = 0 and GetViewportWidth() = camera:GetWidth() and GetViewportHeight() = camera:GetHeight()
            SetViewport(0, 0, width, height)
        end

        camera:Move(xAdjust, yAdjust, 0)
        camera:SetWidth(width)
        camera:SetHeight(height)

        camera:Update()

        if layerLayout not= undefined
            shouldLayout = true
        else
            integer counter = 0
            repeat while counter < items:GetSize()
                items:Get(counter):Resize()
                counter = counter + 1
            end
        end
    end

    action SetInterfaceScale(number scale)
        interfaceScale = scale
        integer counter = 0
        repeat while counter < controls:GetSize()
            controls:Get(counter):SetInterfaceScale(scale)
            counter = counter + 1
        end
        shouldLayout = true
    end

    action GetInterfaceScale returns number
        return interfaceScale
    end

    action ReloadControlGraphics
        integer counter = 0
        repeat while counter < controls:GetSize()
            controls:Get(counter):RequestReloadGraphics()
            counter = counter + 1
        end
        shouldLayout = true
    end

    /*

    */
    action SetLayout(Layout layout)
        layerLayout = layout
        shouldLayout = true
    end

    /*
    
    */
    action GetLayout returns Layout
        return layerLayout
    end

    /*
    This actions sets the viewport that will be used by this Layer, and adjusts
    the Layer's camera to match the dimensions of the viewport.
    */
    action SetViewportAndCamera(integer x, integer y, integer width, integer height)
        Camera camera = GetCamera()
        camera:SetSize(width, height)
        camera:Move((width - GetViewportWidth()) / 2.0, (height - GetViewportHeight()) / 2.0, 0)
        SetViewport(x, y, width, height)
    end

    action GetPainter returns Painter2D
        return painter
    end

    action SetPainter(Painter2D painter)
        me:painter = painter
    end

end
