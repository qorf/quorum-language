package Libraries.Game.Physics

use Libraries.Containers.Array
use Libraries.Compute.Vector3
use Libraries.Interface.Events.CollisionEvent3D
use Libraries.Interface.Item3D
use Libraries.Game.Collision.CollisionPoint3D
use Libraries.Compute.Matrix3
use Libraries.Game.Collision.LocalCollisionPoints3D
use Libraries.Game.Physics.Joints.Joint3D
use Libraries.Game.Collision.PhysicsPosition3D
use Libraries.Compute.Math
use Libraries.Compute.BitwiseOperations
use Libraries.Game.Physics.OrderIndex
use Libraries.Game.Physics.ConstraintDescription3D
use Libraries.Game.Physics.CollisionConstraint3D

/*
This class contains actions that is necessary to compute how objects will react
after a collision or after the objects have been constrained by a joint.
The objects' reaction to physics is simulated by applying impulses to the objects based on collision and constraints on the objects.
*/
class CollisionSolver3D
    constant integer MAX_SOLVER_POINTS = 16384
    Array<OrderIndex> gOrder
    
    Array<SolverItem3D> tempSolverBodyPool      //objects are only added to here if the object has collided with some other object
    Array<SolverConstraint3D> tempSolverConstraintPool
    Array<SolverConstraint3D> tempSolverFrictionConstraintPool
    Array<integer> orderTempConstraintPool
    Array<integer> orderFrictionConstraintPool

    integer seed = 0
    Math math

    on create
        repeat MAX_SOLVER_POINTS times
            OrderIndex i
            gOrder:Add(i)
        end
    end

    /*
    This action stores properties inside an Item3D class into a SolverItem3D
    so that you can access these properties quicker from the SolverItem3D.
    Attribute: Parameter solverItem The SolverItem3D that will store the properties.
    Attribute: Parameter originalItem The 3D object from which properties will be extracted from.
    */
    action InitializeSolverItem(SolverItem3D solverItem, Item3D originalItem)
        if originalItem:IsPhysicsEnabled()
            solverItem:GetAngularVelocity():Set(originalItem:GetAngularVelocity())
            solverItem:GetCenterOfMassPosition():Set(originalItem:GetCollisionTransform():GetOrigin())
            solverItem:SetFriction(originalItem:GetFriction())
            solverItem:SetInverseMass(originalItem:GetInverseMass())
            solverItem:GetLinearVelocity():Set(originalItem:GetLinearVelocity())
            solverItem:SetOriginalItem(originalItem)
            solverItem:SetAngularFactor(originalItem:GetAngularFactor())
        else
            solverItem:GetAngularVelocity():Set(0, 0, 0)
            solverItem:GetCenterOfMassPosition():Set(originalItem:GetCollisionTransform():GetOrigin())
            solverItem:SetFriction(originalItem:GetFriction())
            solverItem:SetInverseMass(0)
            solverItem:GetLinearVelocity():Set(0, 0, 0)
            solverItem:SetOriginalItem(undefined)
            solverItem:SetAngularFactor(1)
        end

        solverItem:GetPushVelocity():Set(0, 0, 0)
        solverItem:GetTurnVelocity():Set(0, 0, 0)
    end
    
    /*
    This action returns a restitution value that is correlated with the relative velocity for a more realistic simulation of physics.
    Attribute: Parameter restitution The original restitution.
    Attribute: Parameter relativeVelocity The relative velocity between two objects.
    */
    action RestitutionCurve(number relativeVelocity, number restitution) returns number
        return restitution * -relativeVelocity
    end

    /*
    This action finds the impulse to stop the two 3D objects from penetrating each other.
    */
    action ResolveSplitPenetrationImpulse(SolverItem3D body1, SolverItem3D body2, SolverConstraint3D contactConstraint, CollisionSolverInformation3D solverInfo)
        if contactConstraint:GetPenetration() < solverInfo:GetSplitImpulsePenetrationThreshold()
            number normalImpulse = 0
            number relvel = 0
            number vel1DotN = contactConstraint:GetContactNormal():DotProduct(body1:GetPushVelocity()) + contactConstraint:GetRelativePosition1CrossNormal():DotProduct(body1:GetTurnVelocity())
            number vel2DotN = contactConstraint:GetContactNormal():DotProduct(body2:GetPushVelocity()) + contactConstraint:GetRelativePosition2CrossNormal():DotProduct(body2:GetTurnVelocity())

            relvel = vel1DotN - vel2DotN

            number positionalError = -contactConstraint:GetPenetration() * solverInfo:GetErp2() / solverInfo:GetTimeStep()

            number velocityError = contactConstraint:GetRestitution() - relvel

            number penetrationImpulse = positionalError * contactConstraint:GetJacobianDiagonalABInverse()
            number velocityImpulse = velocityError * contactConstraint:GetJacobianDiagonalABInverse()
            normalImpulse = penetrationImpulse + velocityImpulse

            //clamping the accumulated impulse
            number oldNormalImpulse = contactConstraint:GetAppliedPushImpulse()
            number sum = oldNormalImpulse + normalImpulse
            contactConstraint:SetAppliedPushImpulse(sum)
            if sum < 0
                contactConstraint:SetAppliedPushImpulse(0)
            end

            normalImpulse = contactConstraint:GetAppliedPushImpulse() - oldNormalImpulse

            Vector3 temp
            temp:Set(contactConstraint:GetContactNormal()):Scale(body1:GetInverseMass())
            body1:InternalApplyPushImpulse(temp, contactConstraint:GetAngularComponentA(), normalImpulse)

            temp:Set(contactConstraint:GetContactNormal()):Scale(body2:GetInverseMass())
            body2:InternalApplyPushImpulse(temp, contactConstraint:GetAngularComponentB(), -normalImpulse)
        end
    end

    /*
    This action finds the impulse that should be applied to resolve collision
    for two objects by taking into account of friction and normal force.
    */
    action ResolveSingleCollisionCombined(SolverItem3D body1, SolverItem3D body2, SolverConstraint3D contactConstraint, CollisionSolverInformation3D solverInfo) returns number
        number normalImpulse = 0

        number relvel = 0
        number vel1DotN = contactConstraint:GetContactNormal():DotProduct(body1:GetLinearVelocity()) + contactConstraint:GetRelativePosition1CrossNormal():DotProduct(body1:GetAngularVelocity())
        number vel2DotN = contactConstraint:GetContactNormal():DotProduct(body2:GetLinearVelocity()) + contactConstraint:GetRelativePosition2CrossNormal():DotProduct(body2:GetAngularVelocity())

        relvel = vel1DotN - vel2DotN

        number positionalError = 0
        if not solverInfo:SplitImpulse() or (contactConstraint:GetPenetration() > solverInfo:GetSplitImpulsePenetrationThreshold())
            positionalError = -contactConstraint:GetPenetration() * solverInfo:GetErp() / solverInfo:GetTimeStep()
        end

        number velocityError = contactConstraint:GetRestitution() - relvel

        number penetrationImpulse = positionalError * contactConstraint:GetJacobianDiagonalABInverse()
        number velocityImpulse = velocityError * contactConstraint:GetJacobianDiagonalABInverse()
        normalImpulse = penetrationImpulse + velocityImpulse

        number oldNormalImpulse = contactConstraint:GetAppliedImpulse()
        number sum = oldNormalImpulse + normalImpulse
        contactConstraint:SetAppliedImpulse(sum)
        if 0 > sum
            contactConstraint:SetAppliedImpulse(0)
        end

        normalImpulse = contactConstraint:GetAppliedImpulse() - oldNormalImpulse

        Vector3 temp
        
        temp:Set(contactConstraint:GetContactNormal()):Scale(body1:GetInverseMass())
        body1:InternalApplyImpulse(temp, contactConstraint:GetAngularComponentA(), normalImpulse)

        temp:Set(contactConstraint:GetContactNormal()):Scale(body2:GetInverseMass())
        body2:InternalApplyImpulse(temp, contactConstraint:GetAngularComponentB(), -normalImpulse)

        return normalImpulse
    end

    /*
    This action finds the frictional impulse that should be applied at a point
    to separate the two colliding objects.
    This action is used by the "SolveGroupIterations" action and the "SolveFriction"
    action.
    */
    action ResolveSingleFriction(SolverItem3D body1, SolverItem3D body2, SolverConstraint3D contactConstraint, CollisionSolverInformation3D solverInfo, number appliedNormalImpulse) returns number
        number combinedFriction = contactConstraint:GetFriction()

        number limit = appliedNormalImpulse * combinedFriction

        if appliedNormalImpulse > 0
            number j1 = 0
            number relvel = 0
            number vel1DotN = contactConstraint:GetContactNormal():DotProduct(body1:GetLinearVelocity()) + contactConstraint:GetRelativePosition1CrossNormal():DotProduct(body1:GetAngularVelocity())
            number vel2DotN = contactConstraint:GetContactNormal():DotProduct(body2:GetLinearVelocity()) + contactConstraint:GetRelativePosition2CrossNormal():DotProduct(body2:GetAngularVelocity())
            relvel = vel1DotN - vel2DotN

            j1 = -relvel * contactConstraint:GetJacobianDiagonalABInverse()

            number oldTangentImpulse = contactConstraint:GetAppliedImpulse()
            contactConstraint:SetAppliedImpulse(oldTangentImpulse + j1)

            if limit < contactConstraint:GetAppliedImpulse()
                contactConstraint:SetAppliedImpulse(limit)
            else
                if contactConstraint:GetAppliedImpulse() < -limit
                    contactConstraint:SetAppliedImpulse(-limit)
                end
            end

            j1 = contactConstraint:GetAppliedImpulse() - oldTangentImpulse

            Vector3 temp
            
            temp:Set(contactConstraint:GetContactNormal()):Scale(body1:GetInverseMass())
            body1:InternalApplyImpulse(temp, contactConstraint:GetAngularComponentA(), j1)

            temp:Set(contactConstraint:GetContactNormal()):Scale(body2:GetInverseMass())
            body2:InternalApplyImpulse(temp, contactConstraint:GetAngularComponentB(), -j1)
        end

        return 0
    end

    /*
    This action makes a solver to take into account of the effects of friction during
    a collision.
    */
    action AddFrictionConstraint(Vector3 normalAxis, integer solverBodyIDA, integer solverBodyIDB, integer frictionIndex, CollisionPoint3D cp, Vector3 relativePosition1, 
                                 Vector3 relativePosition2, Item3D body0, Item3D body1, number relaxation)
        SolverConstraint3D solverConstraint
        tempSolverFrictionConstraintPool:Add(solverConstraint)

        solverConstraint:GetContactNormal():Set(normalAxis)

        solverConstraint:SetBodyIDA(solverBodyIDA)
        solverConstraint:SetBodyIDB(solverBodyIDB)
        solverConstraint:SetConstraintType(solverConstraint:SOLVER_FRICTION)
        solverConstraint:SetFrictionIndex(frictionIndex)

        solverConstraint:SetFriction(cp:GetCombinedFriction())
        solverConstraint:SetOriginalContactPoint(undefined)

        solverConstraint:SetAppliedImpulse(0)
        solverConstraint:SetAppliedPushImpulse(0)
        solverConstraint:SetPenetration(0)

        Vector3 torqueAxis1
        Matrix3 tempMatrix

        torqueAxis1:Set(relativePosition1):CrossProduct(solverConstraint:GetContactNormal())
        solverConstraint:GetRelativePosition1CrossNormal():Set(torqueAxis1)
        if body0:IsPhysicsEnabled()
            solverConstraint:GetAngularComponentA():Set(torqueAxis1)
            tempMatrix:Set(body0:GetInverseInertiaWorld()):Transform(solverConstraint:GetAngularComponentA())
        else
            solverConstraint:GetAngularComponentA():Set(0, 0, 0)
        end

        torqueAxis1:Set(relativePosition2):CrossProduct(solverConstraint:GetContactNormal())
        solverConstraint:GetRelativePosition2CrossNormal():Set(torqueAxis1)
        if body1:IsPhysicsEnabled()
            solverConstraint:GetAngularComponentB():Set(torqueAxis1)
            tempMatrix:Set(body1:GetInverseInertiaWorld()):Transform(solverConstraint:GetAngularComponentB())
        else
            solverConstraint:GetAngularComponentB():Set(0, 0, 0)
        end

        Vector3 vector
        number denom0 = 0
        number denom1 = 0
        if body0:IsPhysicsEnabled()
            vector:Set(solverConstraint:GetAngularComponentA()):CrossProduct(relativePosition1)
            denom0 = body0:GetInverseMass() + normalAxis:DotProduct(vector)
        end
        if body1:IsPhysicsEnabled()
            vector:Set(solverConstraint:GetAngularComponentB()):CrossProduct(relativePosition2)
            denom1 = body1:GetInverseMass() + normalAxis:DotProduct(vector)
        end

        number denom = relaxation / (denom0 + denom1)
        solverConstraint:SetJacobianDiagonalABInverse(denom)
    end

    /*
    This action computes the constraints of objects inside a CollisionGroup3D during a collision.
    */
    action SolveGroupSetup(Array<Item3D> bodies, integer numBodies, Array<LocalCollisionPoints3D> manifoldPtr, integer manifold_offset, integer numManifolds, 
                         Array<Joint3D> joints, integer joints_offset, integer numJoints, CollisionSolverInformation3D infoGlobal) returns number
        if numJoints + numManifolds = 0
            return 0
        end

        LocalCollisionPoints3D manifold = undefined   //PersistentManifold
        Item3D obj0 = undefined //CollisionObject
        Item3D obj1 = undefined

        PhysicsPosition3D tempTransform

        integer i = 0

        Vector3 relativePosition1
        Vector3 relativePosition2

        Vector3 position1
        Vector3 position2
        Vector3 velocity
        Vector3 torqueAxis0
        Vector3 torqueAxis1
        Vector3 velocity1
        Vector3 velocity2
        Vector3 frictionDirection1
        Vector3 frictionDirection2
        Vector3 vector

        Matrix3 tempMatrix

        repeat while i < numManifolds
            manifold = manifoldPtr:Get(manifold_offset + i)
            obj0 = manifold:GetBody0()
            obj1 = manifold:GetBody1()

            integer solverBodyIDA = -1
            integer solverBodyIDB = -1

            if manifold:GetPointCount() not= 0
                if obj0:GetCollisionGroupFlag() //if this object's physics needs to be updated
                    if obj0:GetCollisionGroupIndex() >= 0   //if this object has already been assigned a spot inside tempSolverBodyPool
                        solverBodyIDA = obj0:GetCollisionGroupIndex()
                    else
                        solverBodyIDA = tempSolverBodyPool:GetSize()    //add this object to the end of the tempSolverBodyPool
                        SolverItem3D solverBody
                        tempSolverBodyPool:Add(solverBody)
                        InitializeSolverItem(solverBody, obj0)
                        obj0:SetCollisionGroupIndex(solverBodyIDA)
                    end
                else    //if this object's physics doesn't need to be updated
                    solverBodyIDA = tempSolverBodyPool:GetSize()
                    SolverItem3D solverBody
                    tempSolverBodyPool:Add(solverBody)
                    InitializeSolverItem(solverBody, obj0)
                end

                if obj1:GetCollisionGroupFlag()
                    if obj1:GetCollisionGroupIndex() >= 0
                        solverBodyIDB = obj1:GetCollisionGroupIndex()
                    else
                        solverBodyIDB = tempSolverBodyPool:GetSize()
                        SolverItem3D solverBody
                        tempSolverBodyPool:Add(solverBody)
                        InitializeSolverItem(solverBody, obj1)
                        obj1:SetCollisionGroupIndex(solverBodyIDB)
                    end
                else
                    solverBodyIDB = tempSolverBodyPool:GetSize()
                    SolverItem3D solverBody
                    tempSolverBodyPool:Add(solverBody)
                    InitializeSolverItem(solverBody, obj1)
                end
            end

            number relaxation = 0

            integer j = 0
            repeat while j < manifold:GetPointCount()
                CollisionPoint3D cp = manifold:GetCollisionPoint(j)
                
                if cp:GetDistance() <= 0
                    position1:Set(cp:GetWorldPositionOnA())
                    position2:Set(cp:GetWorldPositionOnB())

                    tempTransform:Set(obj0:GetCollisionTransform())
                    relativePosition1:Set(position1):Subtract(tempTransform:GetOrigin())
                    tempTransform:Set(obj1:GetCollisionTransform())
                    relativePosition2:Set(position2):Subtract(tempTransform:GetOrigin())

                    relaxation = 1
                    number relativeVelocity = 0

                    integer frictionIndex = tempSolverConstraintPool:GetSize()

                    SolverConstraint3D solverConstraint
                    tempSolverConstraintPool:Add(solverConstraint)
                    
                    solverConstraint:SetBodyIDA(solverBodyIDA)
                    solverConstraint:SetBodyIDB(solverBodyIDB)
                    solverConstraint:SetConstraintType(solverConstraint:SOLVER_CONTACT)

                    solverConstraint:SetOriginalContactPoint(cp)

                    torqueAxis0:Set(relativePosition1):CrossProduct(cp:GetWorldNormalOnB())

                    if obj0:IsPhysicsEnabled()
                        solverConstraint:GetAngularComponentA():Set(torqueAxis0)
                        tempMatrix:Set(obj0:GetInverseInertiaWorld())
                        tempMatrix:Transform(solverConstraint:GetAngularComponentA())
                    else
                        solverConstraint:GetAngularComponentA():Set(0, 0, 0)
                    end

                    torqueAxis1:Set(relativePosition2):CrossProduct(cp:GetWorldNormalOnB())

                    if obj1:IsPhysicsEnabled()
                        solverConstraint:GetAngularComponentB():Set(torqueAxis1)
                        tempMatrix:Set(obj1:GetInverseInertiaWorld())
                        tempMatrix:Transform(solverConstraint:GetAngularComponentB())
                    else
                        solverConstraint:GetAngularComponentB():Set(0, 0, 0)
                    end

                    if solverConstraint:GetAngularComponentA():Length() > 5
//                        output "PRE Constraint A angular length = " + solverConstraint:GetAngularComponentA():Length()
                    end

                    if solverConstraint:GetAngularComponentB():Length() > 5
//                        output "PRE Constraint B angular length = " + solverConstraint:GetAngularComponentB():Length()
                    end

                    number denom0 = 0
                    number denom1 = 0
                    if obj0:IsPhysicsEnabled()
                        vector:Set(solverConstraint:GetAngularComponentA()):CrossProduct(relativePosition1)
                        denom0 = obj0:GetInverseMass() + cp:GetWorldNormalOnB():DotProduct(vector)
                    end

                    if obj1:IsPhysicsEnabled()
                        vector:Set(solverConstraint:GetAngularComponentB()):CrossProduct(relativePosition2)
                        denom1 = obj1:GetInverseMass() + cp:GetWorldNormalOnB():DotProduct(vector)
                    end

                    number denom = relaxation / (denom0 + denom1)
                    solverConstraint:SetJacobianDiagonalABInverse(denom)

                    solverConstraint:GetContactNormal():Set(cp:GetWorldNormalOnB())
                    solverConstraint:GetRelativePosition1CrossNormal():Set(relativePosition1):CrossProduct(cp:GetWorldNormalOnB())
                    solverConstraint:GetRelativePosition2CrossNormal():Set(relativePosition2):CrossProduct(cp:GetWorldNormalOnB())

                    if obj0:IsPhysicsEnabled()
                        velocity1:Set(obj0:GetLinearVelocityAtLocalPoint(relativePosition1))
                    else
                        velocity1:Set(0, 0, 0)
                    end

                    if obj1:IsPhysicsEnabled()
                        velocity2:Set(obj1:GetLinearVelocityAtLocalPoint(relativePosition2))
                    else
                        velocity2:Set(0, 0, 0)
                    end

                    velocity:Set(velocity1):Subtract(velocity2)

                    relativeVelocity = cp:GetWorldNormalOnB():DotProduct(velocity)


                    solverConstraint:SetPenetration(cp:GetDistance() + infoGlobal:GetLinearSlop())
                    if solverConstraint:GetPenetration() > 0
                        solverConstraint:SetPenetration(0)
                    end

                    solverConstraint:SetFriction(cp:GetCombinedFriction())
                    solverConstraint:SetRestitution(RestitutionCurve(relativeVelocity, cp:GetCombinedRestitution()))
                    if solverConstraint:GetRestitution() <= 0
                        solverConstraint:SetRestitution(0)
                    end

                    number penetrationVelocity = -solverConstraint:GetPenetration() / infoGlobal:GetTimeStep()

                    if solverConstraint:GetRestitution() > penetrationVelocity
                        solverConstraint:SetPenetration(0)
                    end

                    Vector3 temp

                    if infoGlobal:IsWarmStarting()
                        solverConstraint:SetAppliedImpulse(cp:GetAppliedImpulse() * infoGlobal:GetWarmStartingFactor())
                        if obj0:IsPhysicsEnabled()
                            temp:Set(solverConstraint:GetContactNormal()):Scale(obj0:GetInverseMass())
                            tempSolverBodyPool:Get(solverConstraint:GetBodyIDA()):InternalApplyImpulse(temp, solverConstraint:GetAngularComponentA(), solverConstraint:GetAppliedImpulse())
                        end
                        if obj1:IsPhysicsEnabled()
                            temp:Set(solverConstraint:GetContactNormal()):Scale(obj1:GetInverseMass())
                            tempSolverBodyPool:Get(solverConstraint:GetBodyIDB()):InternalApplyImpulse(temp, solverConstraint:GetAngularComponentB(), -solverConstraint:GetAppliedImpulse())
                        end
                    else
                        solverConstraint:SetAppliedImpulse(0)
                    end

                    solverConstraint:SetAppliedPushImpulse(0)

                    solverConstraint:SetFrictionIndex(tempSolverFrictionConstraintPool:GetSize())
                    if not cp:IsLateralFrictionInitialized()
                        cp:GetLateralFrictionDirectionA():Set(cp:GetWorldNormalOnB()):Scale(relativeVelocity)
                        Vector3 tempFrictionDirection
                        tempFrictionDirection:Set(cp:GetLateralFrictionDirectionA())
                        cp:GetLateralFrictionDirectionA():Set(velocity):Subtract(tempFrictionDirection)

                        number lateralRelativeVelocity = cp:GetLateralFrictionDirectionA():LengthSquared()
                        if lateralRelativeVelocity > 0.000000119209290
                            cp:GetLateralFrictionDirectionA():Scale(1.0 / math:SquareRoot(lateralRelativeVelocity))
                            AddFrictionConstraint(cp:GetLateralFrictionDirectionA(), solverBodyIDA, solverBodyIDB, frictionIndex, cp, relativePosition1, relativePosition2, obj0, obj1, relaxation)
                            cp:GetLateralFrictionDirectionB():Set(cp:GetLateralFrictionDirectionA()):CrossProduct(cp:GetWorldNormalOnB())
                            cp:GetLateralFrictionDirectionB():Normalize()
                            AddFrictionConstraint(cp:GetLateralFrictionDirectionB(), solverBodyIDA, solverBodyIDB, frictionIndex, cp, relativePosition1, relativePosition2, obj0, obj1, relaxation)
                        else
                            Vector3 n = cp:GetWorldNormalOnB()
                            Vector3 p = cp:GetLateralFrictionDirectionA()
                            Vector3 q = cp:GetLateralFrictionDirectionB()
                            if math:AbsoluteValue(n:GetZ()) > math:SquareRoot(0.5)
                                number a = n:GetY() * n:GetY() + n:GetZ() * n:GetZ()
                                number k = 1.0 / math:SquareRoot(a)
                                p:Set(0, -n:GetZ() * k, n:GetY() * k)
                                q:Set(a * k, -n:GetX() * p:GetZ(), n:GetX() * p:GetY())
                            else
                                number a = n:GetX() * n:GetX() + n:GetY() * n:GetY()
                                number k = 1.0 / math:SquareRoot(a)
                                p:Set(-n:GetY() * k, n:GetX() * k, 0)
                                q:Set(-n:GetZ() * p:GetY(), n:GetZ() * p:GetX(), a * k)
                            end
                            AddFrictionConstraint(cp:GetLateralFrictionDirectionA(), solverBodyIDA, solverBodyIDB, frictionIndex, cp, relativePosition1, relativePosition2, obj0, obj1, relaxation)
                            AddFrictionConstraint(cp:GetLateralFrictionDirectionB(), solverBodyIDA, solverBodyIDB, frictionIndex, cp, relativePosition1, relativePosition2, obj0, obj1, relaxation)
                        end
                        cp:SetLateralFrictionInitialized(true)
                    else
                        AddFrictionConstraint(cp:GetLateralFrictionDirectionA(), solverBodyIDA, solverBodyIDB, frictionIndex, cp, relativePosition1, relativePosition2, obj0, obj1, relaxation)
                        AddFrictionConstraint(cp:GetLateralFrictionDirectionB(), solverBodyIDA, solverBodyIDB, frictionIndex, cp, relativePosition1, relativePosition2, obj0, obj1, relaxation)
                    end

                    if solverConstraint:GetAngularComponentA():Length() > 5
//                        output "Constraint A angular length = " + solverConstraint:GetAngularComponentA():Length()
                    end

                    if solverConstraint:GetAngularComponentB():Length() > 5
//                        output "Constraint B angular length = " + solverConstraint:GetAngularComponentB():Length()
                    end

                    SolverConstraint3D frictionConstraint1 = tempSolverFrictionConstraintPool:Get(solverConstraint:GetFrictionIndex())
                    if infoGlobal:IsWarmStarting()
                        frictionConstraint1:SetAppliedImpulse(cp:GetAppliedImpulseLateralA() * infoGlobal:GetWarmStartingFactor())
                        if obj0:IsPhysicsEnabled()
                            temp:Set(frictionConstraint1:GetContactNormal()):Scale(obj0:GetInverseMass())
                            tempSolverBodyPool:Get(solverConstraint:GetBodyIDA()):InternalApplyImpulse(temp, frictionConstraint1:GetAngularComponentA(), frictionConstraint1:GetAppliedImpulse())
                        end
                        if obj1:IsPhysicsEnabled()
                            temp:Set(frictionConstraint1:GetContactNormal()):Scale(obj1:GetInverseMass())
                            tempSolverBodyPool:Get(solverConstraint:GetBodyIDB()):InternalApplyImpulse(temp, frictionConstraint1:GetAngularComponentB(), -frictionConstraint1:GetAppliedImpulse())
                        end
                    else
                        frictionConstraint1:SetAppliedImpulse(0)
                    end

                    SolverConstraint3D frictionConstraint2 = tempSolverFrictionConstraintPool:Get(solverConstraint:GetFrictionIndex() + 1)
                    if infoGlobal:IsWarmStarting()
                        frictionConstraint2:SetAppliedImpulse(cp:GetAppliedImpulseLateralB() * infoGlobal:GetWarmStartingFactor())
                        if obj0:IsPhysicsEnabled()
                            temp:Set(frictionConstraint2:GetContactNormal()):Scale(obj0:GetInverseMass())
                            tempSolverBodyPool:Get(solverConstraint:GetBodyIDA()):InternalApplyImpulse(temp, frictionConstraint2:GetAngularComponentA(), frictionConstraint2:GetAppliedImpulse())
                        end
                        if obj1:IsPhysicsEnabled()
                            temp:Set(frictionConstraint2:GetContactNormal()):Scale(obj1:GetInverseMass())
                            tempSolverBodyPool:Get(solverConstraint:GetBodyIDB()):InternalApplyImpulse(temp, frictionConstraint2:GetAngularComponentB(), -frictionConstraint2:GetAppliedImpulse())
                        end
                    else
                        frictionConstraint2:SetAppliedImpulse(0)
                    end
                end

                j = j + 1
            end
            i = i + 1
        end


        integer j = 0
        repeat while j < numJoints
            Joint3D joint = joints:Get(joints_offset + j)
            joint:BuildJacobian()
            j = j + 1
        end

//        j = 0
//        repeat while j < numJoints
//            Joint3D joint = joints:Get(joints_offset + j)
//            joint:GetInformation(infoGlobal)
//            j = j + 1
//        end

        integer numJointPool = tempSolverConstraintPool:GetSize()
        integer numFrictionPool = tempSolverFrictionConstraintPool:GetSize()

        orderTempConstraintPool:SetSize(numJointPool)
        orderFrictionConstraintPool:SetSize(numFrictionPool)

        j = 0
        repeat numJointPool times
            orderTempConstraintPool:Set(j, j)
            j = j + 1
        end
        j = 0
        repeat numFrictionPool times
            orderFrictionConstraintPool:Set(j, j)
            j = j + 1
        end
        
        return 0
    end

    /*
    This action is used by the action "SolveGroupInternal" to randomize the collision points
    and the constraints at these collision points in arrays.
    */
    action SolveGroupIterations(Array<Item3D> bodies, integer numBodies, Array<LocalCollisionPoints3D> manifoldPtr, integer manifold_offset, integer numManifolds, Array<Joint3D> joints, integer joints_offset, integer numJoints, CollisionSolverInformation3D infoGlobal) returns number
        integer numConstraintPool = tempSolverConstraintPool:GetSize()
        integer numFrictionPool = tempSolverFrictionConstraintPool:GetSize()

        integer iteration = 0
        repeat while iteration < infoGlobal:GetNumberIterations()
            integer j = 0
            if infoGlobal:RandomizeOrder()
                if bo:And(iteration, 7) = 0
                    j = 0
                    repeat while j < numConstraintPool
                        integer temp = orderTempConstraintPool:Get(j)
                        integer swapi = RandomInteger(j + 1)
                        orderTempConstraintPool:Set(j, orderTempConstraintPool:Get(swapi))
                        orderTempConstraintPool:Set(swapi, temp)

                        j = j + 1
                    end

                    j = 0
                    repeat while j < numFrictionPool
                        integer temp = orderFrictionConstraintPool:Get(j)
                        integer swapi = RandomInteger(j + 1)
                        orderFrictionConstraintPool:Set(j, orderFrictionConstraintPool:Get(swapi))
                        orderFrictionConstraintPool:Set(swapi, temp)

                        j = j + 1
                    end
                end
            end

            j = 0
            repeat while j < numJoints
                Joint3D joint = joints:Get(joints_offset + j)
                

                //if itemA needs to have physics updated && itemA has collided with someone
                if joint:GetItemA():GetCollisionGroupFlag() and joint:GetItemA():GetCollisionGroupIndex() >= 0
                    tempSolverBodyPool:Get(joint:GetItemA():GetCollisionGroupIndex()):WriteBackVelocity()
                end

                if joint:GetItemB():GetCollisionGroupFlag() and joint:GetItemB():GetCollisionGroupIndex() >= 0
                    tempSolverBodyPool:Get(joint:GetItemB():GetCollisionGroupIndex()):WriteBackVelocity()
                end

                joint:SolveJoint(infoGlobal:GetTimeStep())

                if joint:GetItemA():GetCollisionGroupFlag() and joint:GetItemA():GetCollisionGroupIndex() >= 0
                    tempSolverBodyPool:Get(joint:GetItemA():GetCollisionGroupIndex()):ReadVelocity()
                end

                if joint:GetItemB():GetCollisionGroupFlag() and joint:GetItemB():GetCollisionGroupIndex() >= 0
                    tempSolverBodyPool:Get(joint:GetItemB():GetCollisionGroupIndex()):ReadVelocity()
                end

                j = j + 1
            end

            integer numPoolConstraints = tempSolverConstraintPool:GetSize()
            j = 0
            repeat while j < numPoolConstraints
                SolverConstraint3D solverManifold = tempSolverConstraintPool:Get(orderTempConstraintPool:Get(j))
                ResolveSingleCollisionCombined(tempSolverBodyPool:Get(solverManifold:GetBodyIDA()), tempSolverBodyPool:Get(solverManifold:GetBodyIDB()), solverManifold, infoGlobal)

                j = j + 1
            end

            integer numFrictionPoolConstraints = tempSolverFrictionConstraintPool:GetSize()
            j = 0
            repeat while j < numFrictionPoolConstraints
                SolverConstraint3D solverManifold = tempSolverFrictionConstraintPool:Get(orderFrictionConstraintPool:Get(j))

                number totalImpulse = tempSolverConstraintPool:Get(solverManifold:GetFrictionIndex()):GetAppliedImpulse() + tempSolverConstraintPool:Get(solverManifold:GetFrictionIndex()):GetAppliedPushImpulse()

                ResolveSingleFriction(tempSolverBodyPool:Get(solverManifold:GetBodyIDA()), tempSolverBodyPool:Get(solverManifold:GetBodyIDB()), solverManifold, infoGlobal, totalImpulse)

                j = j + 1
            end            

            iteration = iteration + 1
        end

        if infoGlobal:SplitImpulse()
            iteration = 0
            repeat while iteration < infoGlobal:GetNumberIterations()
                integer numPoolConstraints = tempSolverConstraintPool:GetSize()
                integer j = 0
                repeat while j < numPoolConstraints
                    SolverConstraint3D solverManifold = tempSolverConstraintPool:Get(orderTempConstraintPool:Get(j))
                    ResolveSplitPenetrationImpulse(tempSolverBodyPool:Get(solverManifold:GetBodyIDA()), tempSolverBodyPool:Get(solverManifold:GetBodyIDB()), solverManifold, infoGlobal)

                    j = j + 1
                end
                iteration = iteration + 1
            end
        end

        return 0
    end

    /*
    This action is used to solve collision of objects inside a CollisionGroup3D.
    This action is used by the action "SolveGroup."
    */
    action SolveGroupInternal(Array<Item3D> bodies, integer numBodies, Array<LocalCollisionPoints3D> manifoldPtr, integer manifold_offset, integer numManifolds, Array<Joint3D> joints, integer joints_offset, integer numJoints, CollisionSolverInformation3D infoGlobal) returns number
        SolveGroupSetup(bodies, numBodies, manifoldPtr, manifold_offset, numManifolds, joints, joints_offset, numJoints, infoGlobal)
        SolveGroupIterations(bodies, numBodies, manifoldPtr, manifold_offset, numManifolds, joints, joints_offset, numJoints, infoGlobal)

        integer numPoolConstraints = tempSolverConstraintPool:GetSize()
        integer j = 0
        repeat while j < numPoolConstraints
            SolverConstraint3D solverManifold = tempSolverConstraintPool:Get(j)
            CollisionPoint3D pt = solverManifold:GetOriginalContactPoint()
            pt:SetAppliedImpulse(solverManifold:GetAppliedImpulse())
            pt:SetAppliedImpulseLateralA(tempSolverFrictionConstraintPool:Get(solverManifold:GetFrictionIndex()):GetAppliedImpulse())
            pt:SetAppliedImpulseLateralA(tempSolverFrictionConstraintPool:Get(solverManifold:GetFrictionIndex() + 1):GetAppliedImpulse())

            j = j + 1
        end

        if infoGlobal:SplitImpulse()
            integer i = 0
            repeat while i < tempSolverBodyPool:GetSize()
                tempSolverBodyPool:Get(i):WriteBackVelocity(infoGlobal:GetTimeStep())

                i = i + 1
            end
        else
            integer i = 0
            repeat while i < tempSolverBodyPool:GetSize()
                tempSolverBodyPool:Get(i):WriteBackVelocity()

                i = i + 1
            end
        end

        tempSolverBodyPool:Empty()
        tempSolverConstraintPool:Empty()
        tempSolverFrictionConstraintPool:Empty()

        return 0
    end

    /*
    This action solves the collision for a collision group.
    */
    action SolveGroup(Array<Item3D> bodies, integer numBodies, Array<LocalCollisionPoints3D> manifoldPtr, integer manifold_offset, integer numManifolds, Array<Joint3D> joints, integer joints_offset, integer numJoints, CollisionSolverInformation3D infoGlobal) returns number
        if infoGlobal:CacheFriendly()
            return SolveGroupInternal(bodies, numBodies, manifoldPtr, manifold_offset, numManifolds, joints, joints_offset, numJoints, infoGlobal)
        end

        CollisionSolverInformation3D info
        info:Set(infoGlobal)

        integer numIter = infoGlobal:GetNumberIterations()

        integer totalPoints = 0 //total number of collision points in this group
        integer j = 0
        repeat while j < numManifolds
            LocalCollisionPoints3D manifold = manifoldPtr:Get(manifold_offset + j)
            PrepareConstraints(manifold, info)

            integer p = 0
            repeat while p < manifold:GetPointCount()
                gOrder:Get(totalPoints):SetPointsIndex(j)
                gOrder:Get(totalPoints):SetPointIndex(p)
                totalPoints = totalPoints + 1
                p = p + 1
            end
            j = j + 1
        end

        j = 0
        repeat while j < numJoints
            Joint3D joint = joints:Get(joints_offset + j)
            joint:BuildJacobian()

            j = j + 1
        end

        integer iteration = 0
        repeat while iteration < numIter
            if infoGlobal:RandomizeOrder()
                if bo:And(iteration, 7) = 0
                    j = 0
                    repeat while j < totalPoints
                        OrderIndex temp = gOrder:Get(j)
                        integer swapi = RandomInteger(j + 1)
                        gOrder:Set(j, gOrder:Get(swapi))
                        gOrder:Set(swapi, temp)

                        j = j + 1
                    end
                end
            end

            j = 0
            repeat while j < numJoints
                Joint3D joint = joints:Get(joints_offset + j)
                joint:SolveJoint(info:GetTimeStep())

                j = j + 1
            end

            j = 0
            repeat while j < totalPoints
                LocalCollisionPoints3D manifold = manifoldPtr:Get(manifold_offset + gOrder:Get(j):GetPointsIndex())
                Solve(manifold:GetBody0(), manifold:GetBody1(), manifold:GetCollisionPoint(gOrder:Get(j):GetPointIndex()), info, iteration)

                j = j + 1
            end

            j = 0
            repeat while j < totalPoints
                LocalCollisionPoints3D manifold = manifoldPtr:Get(manifold_offset + gOrder:Get(j):GetPointsIndex())
                SolveFriction(manifold:GetBody0(), manifold:GetBody1(), manifold:GetCollisionPoint(gOrder:Get(j):GetPointIndex()), info, iteration)

                j = j + 1
            end
            iteration = iteration + 1
        end

        return 0
    end

    /*
    This action calculates the constraints between two colliding bodies that share
    the same LocalCollisionPoints3D.
    */
    action PrepareConstraints(LocalCollisionPoints3D manifold, CollisionSolverInformation3D info)
        Item3D body0 = manifold:GetBody0()
        Item3D body1 = manifold:GetBody1()

        integer numpoints = manifold:GetPointCount()

        Vector3 tempVector
        Matrix3 tempMatrix

        Vector3 pos1
        Vector3 pos2
        Vector3 relpos1
        Vector3 relpos2
        Vector3 vel1
        Vector3 vel2
        Vector3 vel
        Vector3 totalImpulse
        Vector3 torqueAxis0
        Vector3 torqueAxis1
        Vector3 ftorqueAxis0
        Vector3 ftorqueAxis1

        integer i = 0
        repeat while i < numpoints
            CollisionPoint3D cp = manifold:GetCollisionPoint(i)
            if cp:GetDistance() <= 0
                cp:GetPositionWorldOnA(pos1)
                cp:GetPositionWorldOnB(pos2)

                tempVector:Set(body0:GetCenterOfMassPosition())
                relpos1:Set(pos1):Subtract(tempVector)
                tempVector:Set(body1:GetCenterOfMassPosition())
                relpos2:Set(pos2):Subtract(tempVector)

                Matrix3 mat1
                mat1:Set(body0:GetCenterOfMassTransform():GetBasis())
                mat1:Transpose()

                Matrix3 mat2
                mat2:Set(body1:GetCenterOfMassTransform():GetBasis())
                mat2:Transpose()

                ConstraintDescription3D jac
                Vector3 inverseInertia0
                Vector3 inverseInertia1
                inverseInertia0:Set(body0:GetInverseInertiaLocal())
                inverseInertia1:Set(body1:GetInverseInertiaLocal())
                jac:Initialize(mat1, mat2, relpos1, relpos2, cp:GetWorldNormalOnB(), inverseInertia0, body0:GetInverseMass(), inverseInertia1, body1:GetInverseMass())
                number jacDiagAB = jac:GetDiagonal()

                CollisionPersistentData cpd = cp:GetPersistentData()
                if cpd not= undefined
                    cpd:SetPersistentLifeTime(cpd:GetPersistentLifeTime() + 1)
                    if cpd:GetPersistentLifeTime() not= cp:GetLifeTime()
                        cpd:Reset()
                        cpd:SetPersistentLifeTime(cp:GetLifeTime())
                    end
                else
                    CollisionPersistentData cpd1
                    cpd = cpd1
                    cp:SetPersistentData(cpd)
                    cpd:SetPersistentLifeTime(cp:GetLifeTime())
                end

                cpd:SetJacobianDiagonalABInverse(1.0 / jacDiagAB)

                vel1:Set(body0:GetLinearVelocityAtLocalPoint(relpos1))
                vel2:Set(body1:GetLinearVelocityAtLocalPoint(relpos2))
                vel:Set(vel1):Subtract(vel2)

                number relvel = cp:GetWorldNormalOnB():DotProduct(vel)

                number combinedRestitution = cp:GetCombinedRestitution()

                cpd:SetPenetration(cp:GetDistance())
                cpd:SetFriction(cp:GetCombinedFriction())
                cpd:SetRestitution(RestitutionCurve(relvel, combinedRestitution))
                if cpd:GetRestitution() <= 0
                    cpd:SetRestitution(0)
                end

                number penvel = -cpd:GetPenetration() / info:GetTimeStep()

                if cpd:GetRestitution() > penvel
                    cpd:SetPenetration(0)
                end

                number relaxation = info:GetDamping()
                if info:IsWarmStarting()
                    cpd:SetAppliedImpulse(cpd:GetAppliedImpulse() * relaxation)
                else
                    cpd:SetAppliedImpulse(0)
                end

                cpd:SetPreviousAppliedImpulse(cpd:GetAppliedImpulse())

                Vector3 n = cp:GetWorldNormalOnB()
                Vector3 p = cpd:GetFrictionWorldTangential0()
                Vector3 q = cpd:GetFrictionWorldTangential1()

                if math:AbsoluteValue(n:GetZ()) > math:SquareRoot(0.5)
                    number a = n:GetY() * n:GetY() + n:GetZ() * n:GetZ()
                    number k = 1.0 / math:SquareRoot(a)
                    p:Set(0, -n:GetZ() * k, n:GetY() * k)
                    q:Set(a * k, -n:GetX() * p:GetZ(), n:GetX() * p:GetY())
                else
                    number a = n:GetX() * n:GetX() + n:GetY() * n:GetY()
                    number k = 1.0 / math:SquareRoot(a)
                    p:Set(-n:GetY() * k, n:GetX() * k, 0)
                    q:Set(-n:GetZ() * p:GetY(), n:GetZ() * p:GetX(), a * k)
                end

                cpd:SetAccumulatedTangentImpulse0(0)
                cpd:SetAccumulatedTangentImpulse1(0)

                number denom0 = body0:ComputeImpulseDenominator(pos1, cpd:GetFrictionWorldTangential0())
                number denom1 = body1:ComputeImpulseDenominator(pos2, cpd:GetFrictionWorldTangential0())
                number denom = relaxation / (denom0 + denom1)
                cpd:SetJacobianDiagonalABInverseTangent0(denom)

                denom0 = body0:ComputeImpulseDenominator(pos1, cpd:GetFrictionWorldTangential1())
                denom1 = body1:ComputeImpulseDenominator(pos2, cpd:GetFrictionWorldTangential1())
                denom = relaxation / (denom0 + denom1)
                cpd:SetJacobianDiagonalABInverseTangent1(denom)

                totalImpulse:Set(cp:GetWorldNormalOnB()):Scale(cpd:GetAppliedImpulse())

                torqueAxis0:Set(relpos1):CrossProduct(cp:GetWorldNormalOnB())

                cpd:GetAngularComponentA():Set(torqueAxis0)
                tempMatrix:Set(body0:GetInverseInertiaWorld()):Transform(cpd:GetAngularComponentA())

                torqueAxis1:Set(relpos2):CrossProduct(cp:GetWorldNormalOnB())

                cpd:GetAngularComponentB():Set(torqueAxis1)
                tempMatrix:Set(body1:GetInverseInertiaWorld()):Transform(cpd:GetAngularComponentB())

                ftorqueAxis0:Set(relpos1):CrossProduct(cpd:GetFrictionWorldTangential0())

                cpd:GetFrictionAngularComponent0A():Set(ftorqueAxis0)
                tempMatrix:Set(body0:GetInverseInertiaWorld()):Transform(cpd:GetFrictionAngularComponent0A())

                ftorqueAxis1:Set(relpos1):CrossProduct(cpd:GetFrictionWorldTangential1())

                cpd:GetFrictionAngularComponent1A():Set(ftorqueAxis1)
                tempMatrix:Set(body0:GetInverseInertiaWorld()):Transform(cpd:GetFrictionAngularComponent1A())

                ftorqueAxis0:Set(relpos2):CrossProduct(cpd:GetFrictionWorldTangential0())

                cpd:GetFrictionAngularComponent0B():Set(ftorqueAxis0)
                tempMatrix:Set(body1:GetInverseInertiaWorld()):Transform(cpd:GetFrictionAngularComponent0B())

                ftorqueAxis1:Set(relpos2):CrossProduct(cpd:GetFrictionWorldTangential1())

                cpd:GetFrictionAngularComponent1B():Set(ftorqueAxis1)
                tempMatrix:Set(body1:GetInverseInertiaWorld()):Transform(cpd:GetFrictionAngularComponent1B())
//                output "CollisionSolver3D: PrepareConstraints"
                body0:ApplyLinearImpulse(totalImpulse, relpos1)

                tempVector:Set(totalImpulse):Scale(-1)
                body1:ApplyLinearImpulse(tempVector, relpos2)

            end

            i = i + 1
        end
    end

    /*
    This action finds the impulse that should be applied to resolve collision
    for two objects taking into account of friction and normal force such that the impulse can only be greater than or equal to 0.
    */
    action SolveCombinedContactFriction(Item3D body0, Item3D body1, CollisionPoint3D cp, CollisionSolverInformation3D info, integer iteration) returns number
        number maxImpulse = 0

        if cp:GetDistance() <= 0
            CollisionConstraint3D constraint
            number impulse = constraint:ResolveSingleCollisionCombined(body0, body1, cp, info)

            if maxImpulse < impulse
                maxImpulse = impulse
            end
        end

        return maxImpulse
    end

    /*
    This action finds the impulse that should be applied to resolve collision
    for two objects without taking into account of friction such that the impulse
    can only be greater than 0.
    */
    action Solve(Item3D body0, Item3D body1, CollisionPoint3D cp, CollisionSolverInformation3D info, integer iteration) returns number
        number maxImpulse = 0

        if cp:GetDistance() <= 0
            CollisionPersistentData cpd = cp:GetPersistentData()
            number impulse = cpd:GetContactSolver():ResolveSingleCollision(body0, body1, cp, info)
            
            if maxImpulse < impulse
                maxImpulse = impulse
            end
        end

        return maxImpulse
    end

    /*
    This action finds the frictional impulse that should be applied at a point
    to separate the two colliding objects.
    */
    action SolveFriction(Item3D body0, Item3D body1, CollisionPoint3D cp, CollisionSolverInformation3D info, integer iteration) returns number
        if cp:GetDistance() <= 0
            CollisionPersistentData cpd = cp:GetPersistentData()
            cpd:GetFrictionSolver():ResolveSingleFriction(body0, body1, cp, info)
        end

        return 0
    end

    /*
    This action sets the starting point of a bunch of random numbers is 0.
    */
    action Reset
        seed = 0
    end

    BitwiseOperations bo

    /*
    This action returns a random integer.
    */
    private action Random returns integer
        seed = bo:And((1664525 * seed + 1013904223), seed:GetMaximumValue())
        return seed
    end

    /*
    This action returns a random integer that is between 0 and "integer n"-1.
    */
    private action RandomInteger(integer n) returns integer
        integer un = n
        integer r = Random()
        
        if un < 65536
            r = bo:ExclusiveOr(r, bo:ShiftRightPositive(r, 16))
            if un <= 256
                r = bo:ExclusiveOr(r, bo:ShiftRightPositive(r, 8))
                if un <= 16
                    r = bo:ExclusiveOr(r, bo:ShiftRightPositive(r, 4))
                    if un <= 4
                        r = bo:ExclusiveOr(r, bo:ShiftRightPositive(r, 2))
                        if un <= 2
                            r = bo:ExclusiveOr(r, bo:ShiftRightPositive(r, 1))
                        end
                    end
                end
            end
        end

        return math:AbsoluteValue(r mod un)
    end
end