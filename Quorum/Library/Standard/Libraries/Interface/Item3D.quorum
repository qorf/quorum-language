package Libraries.Interface

use Libraries.Interface.Item
use Libraries.Containers.Array
use Libraries.Containers.Iterator
use Libraries.Compute.Matrix4
use Libraries.Compute.Vector3
use Libraries.Compute.Ray
use Libraries.Compute.Math
use Libraries.Interface.Events.TouchEvent
use Libraries.Interface.Events.MouseEvent
use Libraries.Interface.Events.MouseListener
use Libraries.Interface.Events.MouseMovementListener
use Libraries.Interface.Events.MouseWheelListener
use Libraries.Interface.Events.TouchListener
use Libraries.Game.Graphics.Painter3D
use Libraries.Game.Graphics.Light
use Libraries.Game.Graphics.PointLight
use Libraries.Game.Graphics.Camera
use Libraries.Game.Layer3D
use Libraries.Game.GameStateManager
use Libraries.Game.FocusManager
use Libraries.Game.Collision.Shapes.all
use Libraries.Game.Collision.Item3DNode
use Libraries.Game.Collision.BroadphaseCollision3D
use Libraries.Game.Collision.CollisionEdge3D
use Libraries.Game.BoundingBox
use Libraries.Game.Collision.PhysicsPosition3D
use Libraries.Compute.Quaternion
use Libraries.Compute.Matrix3
use Libraries.Game.Physics.PhysicsProperties3D
use Libraries.Game.Physics.all
use Libraries.Game.Physics.Joints.JointEdge3D
use Libraries.Game.Shapes.Rectangle

/*
    The Item3D class represents any object that has a position in 3D space.
    They have X, Y, and Z coordinates, as well as width, height, and depth.
    Combined, these form a simple cube in 3D space. Note that items on their own
    can't be seen on the screen. To make an Item3D that can be drawn directly on
    the screen, use a Libraries.Game.Graphics.Model instead.
    
    Attribute: Author William Allee

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        
        myItem:SetPosition(3, -1, 4)
        myItem:SetDimensions(5, 5, 5)
        myItem:Scale(1.5, 1, 0.8)
*/
class Item3D is Item

    constant text PHYSICS_ERROR_MESSAGE = "Enable physics to use this action"

    number x = 0
    number y = 0
    number z = 0
    number width = 0
    number height = 0
    number depth = 0
    number offsetX = 0
    number offsetY = 0
    number offsetZ = 0
    Matrix4 transform
    Math math
    Layer3D layer = undefined

    boolean collidable = false

    boolean collideWithChildren = false
    boolean hasMoved = false

    PhysicsPosition3D collisionTransform        //projected position
    PhysicsPosition3D collisionTransform0       //previous position
    PhysicsPosition3D interpolationTransform

    CollisionShape3D shape = undefined
    Array<Item3DNode> nodes
    integer nodeCount = 0

    CollisionEdge3D collisionList = undefined
    JointEdge3D jointList = undefined

    private Item3D parentItem = undefined
    private Array<Item3D> children

    private boolean widthSet = false
    private boolean heightSet = false
    private boolean depthSet = false
    private boolean layerSet = false
    private boolean nodesSet = false

    boolean physicsEnabled = false
    PhysicsProperties3D properties = undefined

    boolean updateTransform = true

    number timeOfImpact = 1

    GameStateManager manager

    private action GetChildAsItem(integer index) returns Item
        return children:Get(index)
    end

    /*
    This action sets the X coordinate of the Item.

    Attribute: Parameter setX The new x coordinate for this Item.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetX(35.0)
    */
    action SetX(number setX)
        MoveX(setX - x)
    end

    /*
    This action sets the Y coordinate of the Item.

    Attribute: Parameter setY The new y coordinate for this Item.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetY(210.0)
    */
    action SetY(number setY)
        MoveY(setY - y)
    end

    /*
    This action sets the Z coordinate of the Item.

    Attribute: Parameter setZ The new z coordinate for this Item.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetZ(210.0)
    */
    action SetZ(number setZ)
        MoveZ(setZ - z)
    end

    /*
    This action sets the x, y, and z coordinates of the Item3D.

    Attribute: Parameter setX The new x coordinate for this Item.
    Attribute: Parameter setY The new y coordinate for this Item.
    Attribute: Parameter setZ The new z coordinate for this Item.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetPosition(50, 200, 35)
    */
    action SetPosition(number setX, number setY, number setZ)
        Move(setX - x, setY - y, setZ - z)
    end

    /*
    This action sets the x, y, and z coordinates of the Item3D.

    Attribute: Parameter vector The new position for this Item.

    Attribute: Example

        use Libraries.Interface.Item3D
        use Libraries.Compute.Vector3
        Item3D myItem
        Vector3 vector
        vector:Set(50, 200, 35)
        myItem:SetPosition(vector)
    */
    action SetPosition(Vector3 vector)
        SetPosition(vector:GetX(), vector:GetY(), vector:GetZ())
    end

    /*
    GetX will return the X coordinate of this Item3D in 3D space. Note that if
    if this object has been added to an Item3D, then this coordinate is 
    relative to the parent item - to get the non-relative X coordinate, use the
    GetGlobalX() action instead.

    Attribute: Returns The current x coordinate of this Item, relative to the parent Item (if there is one).

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D myItem
        myItem:SetX(50)
        number x = myItem:GetX()
    */
    action GetX returns number
        return x
    end

    /*
    GetY will return the Y coordinate of this Item3D in 3D space. Note that if
    if this object has been added to an Item3D, then this coordinate is 
    relative to the parent item - to get the non-relative Y coordinate, use the
    GetGlobalY() action instead.

    Attribute: Returns The current y coordinate of this Item, relative to the parent Item (if there is one).

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D myItem
        myItem:SetY(50)
        number y = myItem:GetY()
    */
    action GetY returns number
        return y
    end

    /*
    GetZ will return the Z coordinate of this Item3D in 3D space. Note that if
    if this object has been added to an Item3D, then this coordinate is 
    relative to the parent item - to get the non-relative Z coordinate, use the
    GetGlobalZ() action instead.

    Attribute: Returns The current z coordinate of this Item, relative to the parent Item (if there is one).

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D myItem
        myItem:SetZ(50)
        number z = myItem:GetZ()
    */
    action GetZ returns number
        return z
    end

    /*
    GetPosition will return a Vector3 object containing the X, Y, and Z
    coordinates of this Item3D object. Note that if this object has been
    added to an Item3D, then this coordinate is relative to the parent item -
    to get the non-relative coordinates, use the GetGlobalPosition() action
    instead.

    Attribute: Returns A new Vector3 object containing the x, y, and z coordinates of this Item, relative to the parent Item (if there is one).

    Attribute: Example

        use Libraries.Interface.Item3D
        use Libraries.Compute.Vector3

        Item3D myItem
        myItem:SetX(50)
        Vector3 vector = myItem:GetPosition()
    */
    action GetPosition returns Vector3
        Vector3 position
        position:Set(x, y, z)
        return position
    end

    /*
    This action sets the width of the Item.

    Attribute: Parameter setWidth The new width.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetWidth(35.0)
    */
    action SetWidth(number setWidth)
        width = setWidth
        widthSet = true

        if widthSet and heightSet and depthSet
            Box box
            box:Set(width, height, depth)
            SetShape(box)
        end
    end

    /*
    This action sets the height of the Item.

    Attribute: Parameter setHeight The new height.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetHeight(210.0)
    */
    action SetHeight(number setHeight)
        height = setHeight
        heightSet = true

        if widthSet and heightSet and depthSet
            Box box
            box:Set(width, height, depth)
            SetShape(box)
        end
    end

    /*
    This action sets the depth the Item.

    Attribute: Parameter setDepth The new depth.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetDepth(210.0)
    */
    action SetDepth(number setDepth)
        depth = setDepth
        depthSet = true

        if widthSet and heightSet and depthSet
            Box box
            box:Set(width, height, depth)
            SetShape(box)
        end
    end

    /*
    This action sets the width, height, and depth of the Item3D.

    Attribute: Parameter setWidth The new width.
    Attribute: Parameter setHeight The new height.
    Attribute: Parameter setDepth The new depth.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetDimensions(50, 200, 35)
    */
    action SetDimensions(number setWidth, number setHeight, number setDepth)
        width = setWidth
        height = setHeight
        depth = setDepth

        widthSet = true
        heightSet = true
        depthSet = true

        Box box
        box:Set(width, height, depth)
        SetShape(box)
    end

    /*
    This action sets the width, height, and depth of the Item3D.

    Attribute: Parameter vector A vector containing the new width, height, and depth.

    Attribute: Example

        use Libraries.Interface.Item3D
        use Libraries.Compute.Vector3
        Item3D myItem
        Vector3 vector
        vector:Set(50, 200, 35)
        myItem:SetDimensions(vector)
    */
    action SetDimensions(Vector3 vector)
        width = vector:GetX()
        height = vector:GetY()
        depth = vector:GetZ()

        widthSet = true
        heightSet = true
        depthSet = true

        Box box
        box:Set(width, height, depth)
        SetShape(box)
    end

    /*
    GetWidth will return the width of this Item3D.

    Attribute: Returns The width of this item.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D myItem
        myItem:SetWidth(50)
        number width = myItem:GetWidth()
    */
    action GetWidth returns number
        return width
    end

    /*
    GetHeight will return the height of this Item3D.

    Attribute: Returns The height of this item.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D myItem
        myItem:SetHeight(50)
        number height = myItem:GetHeight()
    */
    action GetHeight returns number
        return height
    end

    /*
    GetDepth will return the depth of this Item3D. 

    Attribute: Returns The depth of this item.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D myItem
        myItem:SetDepth(50)
        number depth = myItem:GetDepth()
    */
    action GetDepth returns number
        return depth
    end

    /*
    GetDimensions will return a Vector3 object containing the width, height, and
    depth of this Item3D object. 

    Attribute: Returns A new Vector3 object containing the width, height, and depth of this item.

    Attribute: Example

        use Libraries.Interface.Item3D
        use Libraries.Compute.Vector3

        Item3D myItem
        myItem:SetWidth(50)
        Vector3 vector = myItem:GetDimensions()
    */
    action GetDimensions returns Vector3
        Vector3 dimensions
        dimensions:Set(width, height, depth)
        return dimensions
    end

    /*
    This action will increase the x-coordinate of this Item by the given amount.

    Attribute: Parameter xAmount How much to increase the current x coordinate of this item by.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D myItem
        myItem:SetX(50)
        myItem:MoveX(25)
    */
    action MoveX(number xAmount)
        transform:Translate(xAmount, 0, 0)
        if updateTransform
            collisionTransform:GetOrigin():Add(xAmount, 0, 0)
            collisionTransform0:Set(collisionTransform)
        end

        x = x + xAmount
        SetOffsetX(offsetX)
        hasMoved = true
    end

    /*
    This action will increase the y-coordinate of this Item by the given amount.

    Attribute: Parameter yAmount How much to increase the current y coordinate of this item by.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D myItem
        myItem:SetY(50)
        myItem:MoveY(25)
    */
    action MoveY(number yAmount)
        transform:Translate(0, yAmount, 0)
        if updateTransform
            collisionTransform:GetOrigin():Add(0, yAmount, 0)
            collisionTransform0:Set(collisionTransform)
        end

        y = y + yAmount
        SetOffsetY(offsetY)
        hasMoved = true
    end

    /*
    This action will increase the z-coordinate of this Item by the given amount.

    Attribute: Parameter zAmount How much to increase the current z coordinate of this item by.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D myItem
        myItem:SetZ(50)
        myItem:MoveZ(25)
    */
    action MoveZ(number zAmount)
        transform:Translate(0, 0, zAmount)
        if updateTransform
            collisionTransform:GetOrigin():Add(0, 0, zAmount)
            collisionTransform0:Set(collisionTransform)
        end
        //transform:Translate(0, 0, -zAmount)

        z = z + zAmount
        SetOffsetZ(offsetZ)
        hasMoved = true
    end

    /*
    This action will increase the x, y, and z coordinates of this Item by the 
    given amounts.

    Attribute: Parameter xAmount How much to increase the current x coordinate of this item by.
    Attribute: Parameter yAmount How much to increase the current y coordinate of this item by.
    Attribute: Parameter zAmount How much to increase the current z coordinate of this item by.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D myItem
        myItem:SetPosition(50, 25, 80)
        myItem:Move(25, 15, -20)
    */
    action Move(number xAmount, number yAmount, number zAmount)
        transform:Translate(xAmount, yAmount, zAmount)
        if updateTransform
            collisionTransform:GetOrigin():Add(xAmount, yAmount, zAmount)
            collisionTransform0:Set(collisionTransform)
        end
        //transform:Translate(xAmount, yAmount, -zAmount)

        x = x + xAmount
        y = y + yAmount
        z = z + zAmount
        SetOffset(offsetX, offsetY, offsetZ)
        hasMoved = true
    end

    /*
    This action will increase the x, y, and z coordinates of this Item by the 
    values inside the given Vector3.

    Attribute: Parameter vector A vector describing how much to increase the current x, y, and z coordinates of this item by.

    Attribute: Example

        use Libraries.Interface.Item3D
        use Libraries.Compute.Vector3

        Item3D myItem
        Vector3 vector
        vector:Set(25, 15, -20)
        myItem:SetPosition(50, 25, 80)
        myItem:Move(vector)
    */
    action Move(Vector3 vector)
        transform:Translate(vector)
        if updateTransform
            collisionTransform:GetOrigin():Add(vector)
            collisionTransform0:Set(collisionTransform)
        end
        //transform:Translate(vector:GetX(), vector:GetY(), vector:GetZ() * -1)

        x = x + vector:GetX()
        y = y + vector:GetY()
        z = z + vector:GetZ()
        SetOffset(offsetX, offsetY, offsetZ)
    end

    /* 
    This action sets the X offset of the Item. The offset tells the Item
    where to relate its X position to. In other words, the X offset is where an
    X coordinate of 0 is for this Item. This is automatically set when using an
    action to add an Item to another Item.

    Attribute: Parameter xAmount The new X offset.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetOffsetX(100)
    */
    action SetOffsetX(number xAmount)
        if xAmount not= offsetX
            number adjust = xAmount - offsetX

            transform:Translate(adjust, 0, 0)
            if updateTransform
                collisionTransform:GetOrigin():Add(adjust, 0, 0)
                collisionTransform0:Set(collisionTransform)
            end
        end

        offsetX = xAmount

        integer counter = 0
        repeat children:GetSize() times
            children:Get(counter):SetOffsetX(x + xAmount)
            counter = counter + 1
        end
    end

    /* 
    This action sets the Y offset of the item. The offset tells the Item
    where to relate its Y position to. In other words, the Y offset is where a
    Y coordinate of 0 is for this item. This is automatically set when using an
    action to add an Item to another Item.

    Attribute: Parameter yAmount The new Y offset.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetOffsetY(75)
    */
    action SetOffsetY(number yAmount)
        if yAmount not= offsetY
            number adjust = yAmount - offsetY
        
            transform:Translate(0, adjust, 0)
            if updateTransform
                collisionTransform:GetOrigin():Add(0, adjust, 0)
                collisionTransform0:Set(collisionTransform)
            end
        end

        offsetY = yAmount

        integer counter = 0
        repeat children:GetSize() times
            children:Get(counter):SetOffsetY(y + yAmount)
            counter = counter + 1
        end
    end

    /* 
    This action sets the Z offset of the item. The offset tells the Item
    where to relate its Z position to. In other words, the Z offset is where a
    Z coordinate of 0 is for this item. This is automatically set when using an
    action to add an Item to another Item.

    Attribute: Parameter zAmount The new Z offset.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetOffsetZ(75)
    */
    action SetOffsetZ(number zAmount)
        if zAmount not= offsetZ
            number adjust = zAmount - offsetZ
        
            transform:Translate(0, 0, adjust)
            if updateTransform
                collisionTransform:GetOrigin():Add(0, 0, adjust)
                collisionTransform0:Set(collisionTransform)
            end
            //transform:Translate(0, 0, -adjust)
        end

        offsetZ = zAmount

        integer counter = 0
        repeat children:GetSize() times
            children:Get(counter):SetOffsetZ(z + zAmount)
            counter = counter + 1
        end
    end

    /* 
    This action sets the offsets of the item. The offsets tell the Item
    where to relate its position to. In other words, the offsets determine where
    each coordinate of 0 is for this item. This is automatically set when using an
    action to add an Item to another Item.

    Attribute: Parameter xAmount The new X offset.
    Attribute: Parameter yAmount The new Y offset.
    Attribute: Parameter zAmount The new Z offset.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetOffset(75, 40, 35)
    */
    action SetOffset(number xAmount, number yAmount, number zAmount)
        if xAmount not= offsetX or yAmount not= offsetY or zAmount not= offsetZ
            transform:Translate(xAmount - offsetX, yAmount - offsetY, zAmount - offsetZ)
            if updateTransform
                collisionTransform:GetOrigin():Add(xAmount - offsetX, yAmount - offsetY, zAmount - offsetZ)
                collisionTransform0:Set(collisionTransform)
            end
            //transform:Translate(xAmount - offsetX, yAmount - offsetY, -(zAmount - offsetZ))
        end

        offsetX = xAmount
        offsetY = yAmount
        offsetZ = zAmount

        integer counter = 0
        repeat children:GetSize() times
            children:Get(counter):SetOffset(x + xAmount, y + yAmount, z + zAmount)
            counter = counter + 1
        end
    end

    /* 
    This action sets the offsets of the item. The offsets tell the Item
    where to relate its position to. In other words, the offsets determine where
    each coordinate of 0 is for this item. This is automatically set when using an
    action to add an Item to another Item.

    Attribute: Parameter vector A Vector3 containing the new x, y, and z offsets.

    Attribute: Example

        use Libraries.Interface.Item3D
        use Libraries.Compute.Vector3
        Item3D myItem
        Vector3 vector
        vector:Set(75, 40, 35)
        myItem:SetOffset(vector)
    */
    action SetOffset(Vector3 vector)
        SetOffset(vector:GetX(), vector:GetY(), vector:GetZ())
    end

    /* 
    This action returns the X offset of the Item. The offset tells the Item
    where to relate its X position to. In other words, the X offset is where an
    X coordinate of 0 is for this Item. This is automatically set when using an
    action to add an Item to another Item.

    Attribute: Returns The current X offset.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetOffsetX(100)
        number offset = myItem:GetOffsetX()
    */
    action GetOffsetX returns number
        return offsetX
    end

    /* 
    This action returns the Y offset of the item. The offset tells the Item
    where to relate its Y position to. In other words, the Y offset is where a
    Y coordinate of 0 is for this item. This is automatically set when using an
    action to add an Item to another Item.

    Attribute: Returns The current Y offset.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetOffsetY(75)
        number offset = myItem:GetOffsetY()
    */
    action GetOffsetY returns number
        return offsetY
    end

    /* 
    This action returns the Z offset of the item. The offset tells the Item
    where to relate its Z position to. In other words, the Z offset is where a
    Z coordinate of 0 is for this item. This is automatically set when using an
    action to add an Item to another Item.

    Attribute: Returns The current Z offset.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:SetOffsetZ(75)
        number offset = myItem:GetOffsetZ()
    */
    action GetOffsetZ returns number
        return offsetZ
    end

    /*
    This action will return the global x coordinate of the Item3D. This is the 
    item's position plus any offset applied by its relation to its parent (if it
    has one).

    Attribute: Returns The global X coordinate of this Item (not relative to any parent).

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        Item3D parentItem
        parentItem:SetX(50)
        myItem:SetX(25)
        parentItem:Add(myItem)
        number x = myItem:GetGlobalX()
    */
    action GetGlobalX returns number
        return transform:row0column3
    end

    /*
    This action will return the global y coordinate of the Item3D. This is the 
    item's position plus any offset applied by its relation to its parent (if it
    has one).

    Attribute: Returns The global Y coordinate of this Item (not relative to any parent).

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        Item3D parentItem
        parentItem:SetY(50)
        myItem:SetY(25)
        parentItem:Add(myItem)
        number y = myItem:GetGlobalY()
    */
    action GetGlobalY returns number
        return transform:row1column3
    end

    /*
    This action will return the global z coordinate of the Item3D. This is the 
    item's position plus any offset applied by its relation to its parent (if it
    has one).

    Attribute: Returns The global Z coordinate of this Item (not relative to any parent).

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        Item3D parentItem
        parentItem:SetZ(50)
        myItem:SetZ(25)
        parentItem:Add(myItem)
        number z = myItem:GetGlobalZ()
    */
    action GetGlobalZ returns number
        return transform:row2column3
        //return transform:row2column3 * -1
    end

    /*
    This action will return the global position of the Item3D as a Vector3.
    This is the item's position plus any offset applied by its relation to its
    parent (if it has one).

    Attribute: Returns A new Vector3 object containing the global coordinates of this Item (not relative to any parent).

    Attribute: Example

        use Libraries.Interface.Item3D
        use Libraries.Compute.Vector3
        Item3D myItem
        Item3D parentItem
        parentItem:SetPosition(50, 40, 30)
        myItem:SetPosition(25, 30, 45)
        parentItem:Add(myItem)
        Vector3 position = myItem:GetGlobalPosition()
    */
    action GetGlobalPosition returns Vector3
        Vector3 vector
        vector:Set(transform:GetTranslation())
        // vector:Scale(1, 1, -1)
        return vector
    end

    /*
    This action sets a reference to the parent item. It is called automatically
    when an Item3D is added as a child to another Item3D. Most users will not
    need to use this action directly.
    
    Attribute: Parameter newItem The parent item.
    */
    action SetParent(Item3D newItem)
        parentItem = newItem
    end

    /*  
    This action returns the parent of this Item3D. An Item3D gets a parent when
    it is added to another Item using the Add action.

    Attribute: Returns The parent Item.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D parentItem
        Item3D child
        parentItem:Add(child)
        Item3D item = child:GetParent()
        
    */
    action GetParent returns Item3D
        return parentItem
    end

    action GetAccessibleParent returns Item
        Item3D par = GetParent()
        repeat while par not= undefined
            if par:IsAccessibleParent()
                return par
            end
            par = par:GetParent()
        end
        return undefined
    end

    /*
    This action will return the Matrix4 containing the transformations applied
    to the Item3D, including its global position, rotation, and scaling.

    Attribute: Returns The Matrix4 used by this item to store and calculate transformations.

    Attribute: Example

        use Libraries.Interface.Item3D
        use Libraries.Compute.Matrix4
        Item3D myItem
        Matrix4 matrix = myItem:GetTransform()
    */
    action GetTransform returns Matrix4
        return transform
    end

    /*  
    This action adds a different Item3D into this one. This makes a few things happen.
        1. The added item will get this item as its parent.
        2. The added item's x, y, and z coordinates will become relative to this Item.
        3. Most actions on this Item will also affect the added Item.

    Attribute: Parameter newItem The item to add as a child to this Item3D.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D parentItem
        Item3D child
        parentItem:Add(child)
        
    */
    action Add(Item3D newItem)
        children:Add(newItem)
        newItem:SetParent(me)
        newItem:SetLayer(layer)
        newItem:SetOffset(x + offsetX, y + offsetY, z + offsetZ)

        if layer not= undefined
            layer:EnableItemLighting(newItem)
            layer:SetNewItemAdded(true)

            AccessibilityManager accessibility = manager:GetAccessibilityManager()
            if accessibility not= undefined
                accessibility:Add(newItem)
            end
        end
    end

    /*  
    This action adds a different Item3D into this one, storing the added Item3D
    at a specific index in the internal array.

    Attribute: Parameter index The index to store the child item at.
    Attribute: Parameter newItem The item to add as a child to this Item3D.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D parentItem
        Item3D child
        parentItem:Add(0, child)
        
    */
    action Add(integer index, Item3D newItem)
        children:Add(index, newItem)
        newItem:SetParent(me)
        newItem:SetLayer(layer)
        newItem:SetOffset(x + offsetX, y + offsetY, z + offsetZ)

        if layer not= undefined
            layer:EnableItemLighting(newItem)
            layer:SetNewItemAdded(true)

            AccessibilityManager accessibility = manager:GetAccessibilityManager()
            if accessibility not= undefined
                accessibility:Add(newItem)
            end
        end
    end

    /*  
    This action removes an Item3D that was previously added to this Item3D. 

    Attribute: Parameter The item to be removed from the children array.

    Attribute: Returns Whether or not the item was found and removed.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D parentItem
        Item3D child1
        Item3D child2
        parentItem:Add(child1)
        parentItem:Add(child2)
        parentItem:Remove(child1)
    */
    action Remove(Item3D removed) returns boolean
        boolean success = children:Remove(removed)

        CollisionEdge3D edge = removed:collisionList
        repeat while edge not= undefined
            CollisionEdge3D edge0 = edge
            edge = edge:GetNext()
            layer:GetCollisionManager():Destroy(edge0:GetCollision())
        end
        removed:collisionList = undefined

        removed:DestroyNodes(layer:GetCollisionManager():GetBroadphase())
        removed:SetCollidable(false)

        removed:SetParent(undefined)
        removed:SetLayer(undefined)
        removed:SetOffset(0, 0, 0)

        if layer not= undefined
            layer:DisableItemLighting(removed)

            AccessibilityManager accessibility = manager:GetAccessibilityManager()
            if accessibility not= undefined
                accessibility:Remove(removed)
            end
        end

        return success
    end

    /*  
    This action removes an Item that was previously added to this Item by
    finding it at the given index in the internal array of children Items.

    Attribute: Parameter index The index to remove from the children array.

    Attribute: Returns The Item that was removed.

    Attribute: Example

        use Libraries.Interface.Item

        Item parentItem
        Item child1
        Item child2
        parentItem:Add(child1)
        parentItem:Add(child2)
        parentItem:Remove(0)
    */
    action Remove(integer index) returns Item3D
        Item3D temp = children:RemoveAt(index)

        CollisionEdge3D edge = temp:collisionList
        repeat while edge not= undefined
            CollisionEdge3D edge0 = edge
            edge = edge:GetNext()
            layer:GetCollisionManager():Destroy(edge0:GetCollision())
        end
        temp:collisionList = undefined

        temp:DestroyNodes(layer:GetCollisionManager():GetBroadphase())
        temp:SetCollidable(false)

        temp:SetParent(undefined)
        temp:SetLayer(undefined)
        temp:SetOffset(0, 0, 0)

        if layer not= undefined
            layer:DisableItemLighting(temp)

            AccessibilityManager accessibility = manager:GetAccessibilityManager()
            if accessibility not= undefined
                accessibility:Remove(temp)
            end
        end

        return temp
    end

    /*  
    This action returns an Item3D that was previously added to this Item3D by
    finding it at the given index in the internal array of children Items.

    Attribute: Parameter index The index to retrieve from the children array.
    Attribute: Returns The child Item stored at the index.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D parentItem
        Item3D child1
        Item3D child2
        parentItem:Add(child1)
        parentItem:Add(child2)
        Item3D temp = parentItem:GetItem(0)
    */
    action GetItem(integer index) returns Item3D
        return children:Get(index)
    end

    /*  
    This action returns an iterator containing all the items contained in
    this Item3D.

    Attribute: Returns An iterator containing all children in this Item3D.

    Attribute: Example

        use Libraries.Interface.Item3D
        use Libraries.Containers.Iterator

        Item3D parentItem
        Item3D child1
        Item3D child2
        parentItem:Add(child1)
        parentItem:Add(child2)
        Iterator<Item3D> iterator = parentItem:GetItems()
    */
    action GetItems returns Iterator<Item3D>
        return children:GetIterator()
    end

    /*  
    This action returns the number of items contained in this Item3D.

    Attribute: Returns The number of children in this Item3D.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D parentItem
        Item3D child1
        Item3D child2
        parentItem:Add(child1)
        parentItem:Add(child2)
        integer size = parentItem:GetItemCount()
    */
    action GetItemCount returns integer
        return children:GetSize()
    end

    /*  
    This action sets a value inside the internal item array of this Item3D.

    Attribute: Parameter index The index to set within the children array.
    Attribute: Parameter newItem The item to store in the given index.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D parentItem
        Item3D child1
        Item3D child2
        parentItem:Add(child1)
        parentItem:SetItem(0, child2)
    */
    action SetItem(integer index, Item3D newItem)
        Item3D oldItem = children:Get(index)
        if oldItem not= undefined
            oldItem:SetParent(undefined)
            oldItem:SetLayer(undefined)
            oldItem:SetOffset(0, 0, 0)
            if layer not= undefined
                layer:DisableItemLighting(oldItem)
                
                AccessibilityManager accessibility = manager:GetAccessibilityManager()
                if accessibility not= undefined
                    accessibility:Remove(oldItem)
                end
            end
        end

        children:Set(index, newItem)
        newItem:SetParent(me)
        newItem:SetLayer(layer)
        newItem:SetOffset(x + offsetX, y + offsetY, z + offsetZ)

        if layer not= undefined
            layer:EnableItemLighting(newItem)
            layer:SetNewItemAdded(true)

            AccessibilityManager accessibility = manager:GetAccessibilityManager()
            if accessibility not= undefined
                accessibility:Add(newItem)
            end
        end
    end

    /*
    This action will remove all Items from this Item's children hierarchy. Note
    that this will not empty the hierarchies of the contained Items.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D parentItem
        Item3D child1
        Item3D child2
        Item3D grandchild
        parentItem:Add(child1)
        parentItem:Add(child2)
        child1:Add(grandChild)
        parentItem:Empty()
    */
    action Empty
        repeat while children:IsEmpty() = false
            Item3D item = children:GetFromEnd()
            Remove(item)
        end
    end

    /*  
    This action returns whether or not any items are contained in this Item.

    Attribute: Returns Whether or not this item contains any children.

    Attribute: Example

        use Libraries.Interface.Item3D

        Item3D parentItem
        Item3D child1
        parentItem:Add(child1)
        boolean wasEmpty = parentItem:IsEmpty()
    */
    action IsEmpty returns boolean
        return children:IsEmpty()
    end

    /*
    This action will take a TouchEvent and distribute it to any TouchListeners
    that have been added to this Item3D. This action will also set the event to
    the "handled" state.

    Attribute: Parameter event The TouchEvent to process.

    Attribute: Example

    use Libraries.Interface.Item2D
    use Libraries.Interface.Events.TouchEvent
    use Libraries.Interface.Events.TouchListener
    Item2D myItem
    TouchListener listener
    myItem:AddTouchListener(listener)
    TouchEvent event
    event:eventType = event:BEGAN
    myItem:ProcessTouchEvent(event)

    */
    action ProcessTouchEvent(TouchEvent event)
        event:SetEventHandled(true)

        Iterator<TouchListener> iterator = GetTouchListeners()
        if event:eventType = event:BEGAN
            repeat while iterator:HasNext()
                iterator:Next():BeganTouch(event)
            end

        elseif event:eventType = event:MOVED or event:eventType = event:STATIONARY
            repeat while iterator:HasNext()
                iterator:Next():ContinuedTouch(event)
            end

        elseif event:eventType = event:ENDED or event:eventType = event:CANCELLED
            repeat while iterator:HasNext()
                iterator:Next():EndedTouch(event)
            end

        end

    end

    /*  
    This action takes a MouseEvent and distributes it to any MouseListeners,
    MouseMovementListeners, and MouseWheelListeners that have been added to this
    Item3D. This action will also set the event to the "handled" state.

    Attribute: Example

    use Libraries.Interface.Item2D
    use Libraries.Interface.Events.MouseEvent
    use Libraries.Interface.Events.MouseListener
    Item2D myItem
    MouseListener listener
    myItem:AddMouseListener(listener)
    MouseEvent event
    event:eventType = event:CLICKED_MOUSE
    myItem:ProcessMouseEvent(event)
    
    */
    action ProcessMouseEvent(MouseEvent event)

        event:SetEventHandled(true)

        if event:eventType = event:MOVED_MOUSE
            Iterator<MouseMovementListener> iterator = GetMouseMovementListeners()

            repeat while iterator:HasNext()
                iterator:Next():MovedMouse(event)
            end

        elseif event:eventType = event:DRAGGED_MOUSE
            Iterator<MouseMovementListener> iterator = GetMouseMovementListeners()

            repeat while iterator:HasNext()
                iterator:Next():DraggedMouse(event)
            end

        elseif event:eventType = event:CLICKED_MOUSE
            Iterator<MouseListener> iterator = GetMouseListeners()

            repeat while iterator:HasNext()
                iterator:Next():ClickedMouse(event)
            end

        elseif event:eventType = event:RELEASED_MOUSE
            Iterator<MouseListener> iterator = GetMouseListeners()

            repeat while iterator:HasNext()
                iterator:Next():ReleasedMouse(event)
            end

        elseif event:eventType = event:SCROLLED_MOUSE
            Iterator<MouseWheelListener> iterator = GetMouseWheelListeners()

            repeat while iterator:HasNext()
                iterator:Next():ScrolledMouse(event)
            end
        end
    end

    /*
    This action will rotate the Item3D about an axis represented by the given
    Vector3. The axis is essentially a ray that starts at the center of the item
    and points outward. The item will then rotate clockwise around that ray.
    The item will be rotated by an angle given in degrees. If the 
    Item3D has any children items, they will also be rotated, and their offsets 
    will be adjusted to maintain the same relative position to this item.

    Attribute: Parameter vector The axis or ray to rotate around.
    Attribute: Parameter degrees How many degrees to rotate (clockwise).

    Attribute: Example

    use Libraries.Interface.Item3D
    use Libraries.Compute.Vector3
    Item3D myItem
    Vector3 vector

    // This will rotate the item 90 degrees clockwise around a ray passing 
    // through the item's center and pointing to the right.
    vector:Set(1, 0, 0)
    myItem:Rotate(vector, 90)

    // This will rotate the item 45 degrees clockwise around a ray passing 
    // through the item's center and pointing straight down.
    vector:Set(0, -1, 0)
    myItem:Rotate(vector, 45)

    // This will rotate the item 60 degrees counter-clockwise around a ray  
    // passing through the item's center and pointing to the right.
    vector:Set(1, 0, 0)
    myItem:Rotate(vector, -60)

    // When setting the vector with multiple non-zero values, each value is
    // relative to each other. Since this vector is set with a larger x
    // value than y value, this ray points mostly left and a little upwards.
    vector:Set(3, 1, 0)
    myItem:Rotate(vector, 45)

    // Because the values are relative to each other, this code has the same
    // effect as the last Rotate call we used (because the x value is still
    // 3 times larger than the y value).
    vector:Set(9, 3, 0)
    myItem:Rotate(vector, 45)
    */
    action Rotate(Vector3 vector, number degrees)
        Rotate(vector, degrees, true)
    end

    /*
    This action will rotate the Item3D about an axis represented by the given
    Vector3. The item will be rotated by an angle given in degrees. If the
    boolean parameter is set to true, and if the Item3D has any children items, 
    they will also be rotated, and their offsets will be adjusted to maintain
    the same relative position to this item. If the boolean parameter is set to
    false, only this Item will be rotated.

    Attribute: Parameter vector The axis or ray to rotate around.
    Attribute: Parameter degrees How many degrees to rotate (clockwise).
    Attribute: Parameter rotateChildren Whether or not children should be rotated around the parent.

    Attribute: Example

    use Libraries.Interface.Item3D
    use Libraries.Compute.Vector3
    Item3D myItem
    Vector3 vector
    vector:Set(5, 2, 1)
    myItem:Rotate(vector, 90, false)

    */
    action Rotate(Vector3 vector, number degrees, boolean rotateChildren)
        transform:Rotate(vector:GetX(), vector:GetY(), -vector:GetZ(), degrees)
        if updateTransform
            if shape not= undefined
                Vector3 scale
                shape:GetLocalScaling(scale)
                Matrix3 tempMatrix
                tempMatrix:row0column0 = transform:row0column0 / scale:GetX()
                tempMatrix:row0column1 = transform:row0column1 / scale:GetX()
                tempMatrix:row0column2 = transform:row0column2 / scale:GetX()

                tempMatrix:row1column0 = transform:row1column0 / scale:GetY()
                tempMatrix:row1column1 = transform:row1column1 / scale:GetY()
                tempMatrix:row1column2 = transform:row1column2 / scale:GetY()

                tempMatrix:row2column0 = transform:row2column0 / scale:GetZ()
                tempMatrix:row2column1 = transform:row2column1 / scale:GetZ()
                tempMatrix:row2column2 = transform:row2column2 / scale:GetZ()
                collisionTransform:GetBasis():Set(tempMatrix)
            end
        end
        if rotateChildren
            RotateChildren(vector, degrees)
        end
    end

    /*
    This action will rotate the Item3D about an axis. The axis is essentially a 
    ray that starts at the center of the item and points outward. The item will 
    then rotate clockwise around that ray. The ray is defined using three
    numbers, representing which way it points on the x, y, and z planes,
    respectively. The item will be rotated by an angle given in degrees. If the 
    Item3D has any children items, they will also be rotated, and their offsets 
    will be adjusted to maintain the same relative position to this item.

    Attribute: Parameter rotateX The x component of the ray to rotate around.
    Attribute: Parameter rotateY The y component of the ray to rotate around.
    Attribute: Parameter rotateZ The z component of the ray to rotate around.
    Attribute: Parameter degrees How many degrees to rotate (clockwise).

    Attribute: Example

    use Libraries.Interface.Item3D
    Item3D myItem

    // This will rotate the item 90 degrees clockwise around a ray passing 
    // through the item's center and pointing to the right.
    myItem:Rotate(1, 0, 0, 90)

    // This will rotate the item 45 degrees clockwise around a ray passing 
    // through the item's center and pointing straight down.
    myItem:Rotate(0, -1, 0, 45)

    // This will rotate the item 60 degrees counter-clockwise around a ray  
    // passing through the item's center and pointing to the right.
    myItem:Rotate(1, 0, 0, -60)

    // When setting the ray with multiple non-zero values, each value is
    // relative to each other. Since this vector is set with a larger x
    // value than y value, this ray points mostly left and a little upwards.
    myItem:Rotate(3, 1, 0, 45)

    // Because the values are relative to each other, this code has the same
    // effect as the last Rotate call we used (because the x value is still
    // 3 times larger than the y value).
    myItem:Rotate(9, 3, 0, 45)

    */
    action Rotate(number rotateX, number rotateY, number rotateZ, number degrees)
        Vector3 vector
        vector:Set(rotateX, rotateY, rotateZ)
        Rotate(vector, degrees, true)
    end

    /*
    This action will rotate the Item3D about an axis represented by the first 3
    given number values. The item will be rotated by an angle given in degrees. If the
    boolean parameter is set to true, and if the Item3D has any children items, 
    they will also be rotated, and their offsets will be adjusted to maintain
    the same relative position to this item. If the boolean parameter is set to
    false, only this Item will be rotated.

    Attribute: Parameter rotateX The x component of the ray to rotate around.
    Attribute: Parameter rotateY The y component of the ray to rotate around.
    Attribute: Parameter rotateZ The z component of the ray to rotate around.
    Attribute: Parameter degrees How many degrees to rotate (clockwise).
    Attribute: Parameter rotateChildren Whether or not children should be rotated around the parent.

    Attribute: Example

    use Libraries.Interface.Item3D
    Item3D myItem
    myItem:Rotate(5, 2, 1, 90, false)

    */
    action Rotate(number rotateX, number rotateY, number rotateZ, number degrees, boolean rotateChildren)
        Vector3 vector
        vector:Set(rotateX, rotateY, rotateZ)
        Rotate(vector, degrees, rotateChildren)
    end

    /*
    This action will rotate all of the children of this Item3D clockwise about 
    an axis passing through this item. The direction of the axis is represented 
    by the given Vector3, and the children will be rotated by the given number
    of degrees. 

    Attribute: Parameter vector The axis or ray to rotate around.
    Attribute: Parameter degrees How many degrees to rotate (clockwise).

    Attribute: Example

    use Libraries.Interface.Item3D
    use Libraries.Compute.Vector3
    Item3D parentItem
    Item3D child1
    Item3D child2

    parentItem:Add(child1)
    parentItem:Add(child2)

    Vector3 axis

    // This will rotate the item's children 90 degrees clockwise around a ray passing 
    // through the item's center and pointing to the right.
    axis:Set(1, 0, 0)
    myItem:RotateChildren(axis, 90)

    // This will rotate the item's children 45 degrees clockwise around a ray passing 
    // through the item's center and pointing straight down.
    axis:Set(0, -1, 0)
    myItem:RotateChildren(axis, 45)

    // This will rotate the item's children 60 degrees counter-clockwise around a ray  
    // passing through the item's center and pointing to the right.
    axis:Set(1, 0, 0)
    myItem:RotateChildren(axis, -60)

    // When setting the ray with multiple non-zero values, each value is
    // relative to each other. Since this vector is set with a larger x
    // value than y value, this ray points mostly left and a little upwards.
    axis:Set(3, 1, 0)
    myItem:Rotate(axis, 45)

    // Because the values are relative to each other, this code has the same
    // effect as the last Rotate call we used (because the x value is still
    // 3 times larger than the y value).
    axis:Set(9, 3, 0)
    myItem:RotateChildren(axis, 45)

    */
    action RotateChildren(Vector3 vector, number degrees)
        if not children:IsEmpty()

//            integer counter = 0
//            number radians = math:DegreesToRadians(degrees)
//            number cos = math:Cosine(radians)
//            number sin = math:Sine(radians)
//            Item3D child = undefined

            Vector3 globalOffset = GetGlobalPosition()
//            Vector3 rotation
//            Vector3 temp
//            Vector3 vector3
//            vector3:Set(vector)
//            vector3:Scale(-1, -1, -1)
//            vector3:Normalize()

            Array<Item3D> allChildren
            GetAllChildren(allChildren)

            RotateItemArray(allChildren, globalOffset, vector, degrees)

            /*
            We store the offsets we'll be using before manipulating anything.
            This ensures we use the original data, and there's no risk of using
            data that's been modified on the fly (e.g., updating a parent item
            will affect the position of the child item).
            */
//            Array<Vector3> localOffsets
//            repeat allChildren:GetSize() times
//                Vector3 newLocalOffset = allChildren:Get(counter):GetGlobalPosition()
//                localOffsets:Add(newLocalOffset)
//                counter = counter + 1
//            end
//
//            counter = 0
//
//            /*
//            Set the children's offset using Rodrigues' Rotation Formula.
//            */
//            repeat allChildren:GetSize() times
//                child = allChildren:Get(counter)
//                //Vector3 localOffset = child:GetGlobalPosition()
//                Vector3 localOffset = localOffsets:Get(counter)
//                localOffset:Subtract(globalOffset)
//                
//                temp:Set(vector3):CrossProduct(localOffset):Scale(sin)
//                rotation = localOffset:Scale(cos)
//                rotation:Add(temp)
//                temp:Set(vector3)
//                temp:Scale((1 - cos) * temp:DotProduct(localOffset))
//                rotation:Add(temp)
//                
//                rotation:Add(globalOffset):Subtract(child:GetPosition())
//
//                child:SetOffset(rotation)
//                child:Rotate(vector, degrees, false)
//
//                counter = counter + 1
//            end
        end
    end

    /*
    This action will rotate all of the children of this Item3D clockwise about 
    an axis passing through this item. The direction of the axis is represented 
    by the given Vector3, and the children will be rotated by the given number
    of degrees. 

    Attribute: Parameter rotateX The x component of the ray to rotate around.
    Attribute: Parameter rotateY The y component of the ray to rotate around.
    Attribute: Parameter rotateZ The z component of the ray to rotate around.
    Attribute: Parameter degrees How many degrees to rotate (clockwise).

    Attribute: Example

    use Libraries.Interface.Item3D
    Item3D parentItem
    Item3D child1
    Item3D child2

    parentItem:Add(child1)
    parentItem:Add(child2)

    Vector3 axis

    // This will rotate the item's children 90 degrees clockwise around a ray passing 
    // through the item's center and pointing to the right.
    myItem:RotateChildren(1, 0, 0, 90)

    // This will rotate the item's children 45 degrees clockwise around a ray passing 
    // through the item's center and pointing straight down.
    myItem:RotateChildren(0, -1, 0, 45)

    // This will rotate the item's children 60 degrees counter-clockwise around a ray  
    // passing through the item's center and pointing to the right.
    myItem:RotateChildren(1, 0, 0, -60)

    // When setting the ray with multiple non-zero values, each value is
    // relative to each other. Since this vector is set with a larger x
    // value than y value, this ray points mostly left and a little upwards.
    myItem:Rotate(3, 1, 0, 45)

    // Because the values are relative to each other, this code has the same
    // effect as the last Rotate call we used (because the x value is still
    // 3 times larger than the y value).
    myItem:RotateChildren(9, 3, 0, 45)

    */
    action RotateChildren(number rotateX, number rotateY, number rotateZ, number degrees)
        Vector3 axis
        axis:Set(rotateX, rotateY, rotateZ)
        RotateChildren(axis, degrees)
    end

    /*
    This action will rotate this Item3D clockwise about an axis passing through
    the given point. The direction of the axis is represented by the given
    Vector3 object. The children of this Item3D will also be rotated.

    Attribute: Parameter point The point in space to rotate around.
    Attribute: Parameter axis The axis that determines the direction to rotate in.
    Attribute: Parameter degrees How many degrees to rotate (clockwise) around the axis.

    Attribute: Example

    use Libraries.Interface.Item3D
    use Libraries.Compute.Vector3
    Item3D parentItem
    Item3D child1
    Item3D child2

    parentItem:Add(child1)
    parentItem:Add(child2)

    // We will rotate about the point 0, 0, 0 for this example.
    Vector3 point
    point:Set(0, 0, 0)

    Vector3 axis

    // This will rotate the item and its children 90 degrees clockwise around a ray passing 
    // through the given point and pointing to the right.
    axis:Set(1, 0, 0)
    myItem:RotateAround(point, axis, 90)

    // This will rotate the item and its children 45 degrees clockwise around a ray passing 
    // through the given point and pointing straight down.
    axis:Set(0, -1, 0, 45)
    myItem:RotateAround(point, axis, 45)

    // This will rotate the item and its children 60 degrees counter-clockwise around a ray  
    // passing through the given point and pointing to the right.
    axis:Set(1, 0, 0)
    myItem:RotateAround(point, axis, -60)

    // When setting the ray with multiple non-zero values, each value is
    // relative to each other. Since this vector is set with a larger x
    // value than y value, this ray points mostly left and a little upwards.
    axis:Set(3, 1, 0)
    myItem:RotateAround(point, axis, 45)

    // Because the values are relative to each other, this code has the same
    // effect as the last Rotate call we used (because the x value is still
    // 3 times larger than the y value).
    axis:Set(9, 3, 0)
    myItem:RotateAround(point, axis, 45)

    */
    action RotateAround(Vector3 point, Vector3 axis, number degrees)
        RotateAround(point, axis, degrees, true)
    end

    /*
    This action will rotate this Item3D clockwise about an axis passing through
    the given point. The direction of the axis is represented by the given
    Vector3 object. The last parameter is a boolean that determines whether or
    not children should also be rotated - a value of true will rotate the
    children, a value of false will not. Note that the children will still 
    maintain relative position to this item, regardless of the boolean passed.

    Attribute: Parameter point The point in space to rotate around.
    Attribute: Parameter axis The axis that determines the direction to rotate in.
    Attribute: Parameter degrees How many degrees to rotate (clockwise) around the axis.
    Attribute: Parameter rotateChildren Whether or not to also rotate this item's children.

    Attribute: Example

    use Libraries.Interface.Item3D
    use Libraries.Compute.Vector3
    Item3D parentItem
    Item3D child1
    Item3D child2

    parentItem:Add(child1)
    parentItem:Add(child2)

    // We will rotate about the point 0, 0, 0 for this example.
    Vector3 point
    point:Set(0, 0, 0)

    Vector3 axis

    // This will rotate the item and its children 90 degrees clockwise around a ray passing 
    // through the given point and pointing to the right.
    axis:Set(1, 0, 0)
    myItem:RotateAround(point, axis, 90, true)

    // This will rotate the item and its children 45 degrees clockwise around a ray passing 
    // through the given point and pointing straight down.
    axis:Set(0, -1, 0, 45)
    myItem:RotateAround(point, axis, 45, true)

    // This will rotate the item (but not its children) 60 degrees counter-clockwise around a ray  
    // passing through the given point and pointing to the right.
    axis:Set(1, 0, 0)
    myItem:RotateAround(point, axis, -60, false)

    // When setting the ray with multiple non-zero values, each value is
    // relative to each other. Since this vector is set with a larger x
    // value than y value, this ray points mostly left and a little upwards.
    axis:Set(3, 1, 0)
    myItem:RotateAround(point, axis, 45, true)

    // Because the values are relative to each other, this code has the same
    // effect as the last Rotate call we used (because the x value is still
    // 3 times larger than the y value).
    axis:Set(9, 3, 0)
    myItem:RotateAround(point, axis, 45, true)

    */
    action RotateAround(Vector3 point, Vector3 axis, number degrees, boolean rotateChildren)
        Array<Item3D> array
        array:Add(me)

        if rotateChildren and not children:IsEmpty()
            GetAllChildren(array)
        end

        RotateItemArray(array, point, axis, degrees)
    end

    /*
    A private action used to gather up the entire children hierarchy into a
    single array for easy iteration.
    */
    private action GetAllChildren(Array<Item3D> items)
        Array<Item3D> unprocessedItems

        integer counter = 0
        repeat children:GetSize() times
            unprocessedItems:Add(children:Get(counter))
            counter = counter + 1
        end

        repeat while not unprocessedItems:IsEmpty()
            Item3D temp = unprocessedItems:RemoveFromFront()
            counter = 0
            repeat while counter < temp:GetItemCount()
                unprocessedItems:Add(temp:GetItem(counter))
                counter = counter + 1
            end
            
            items:Add(temp)
        end
    end

    /*
    This action is used to rotate items around a point. It is used by the
    Rotate, RotateChildren, and RotateAround actions.
    */
    private action RotateItemArray(Array<Item3D> array, Vector3 point, Vector3 axis, number degrees)

        integer counter = 0
        number radians = math:DegreesToRadians(degrees)
        number cos = math:Cosine(radians)
        number sin = math:Sine(radians)
        Item3D child = undefined

        Vector3 rotation
        Vector3 temp
        Vector3 vector3
        vector3:Set(axis)
        vector3:Scale(-1, -1, -1)
        vector3:Normalize()

        /*
        We store the offsets we'll be using before manipulating anything.
        This ensures we use the original data, and there's no risk of using
        data that's been modified on the fly (e.g., updating a parent item
        will affect the position of the child item).
        */
        Array<Vector3> localOffsets
        repeat array:GetSize() times
            Vector3 newLocalOffset = array:Get(counter):GetGlobalPosition()
            localOffsets:Add(newLocalOffset)
            counter = counter + 1
        end

        counter = 0

        /*
        Set each item's offset using Rodrigues' Rotation Formula.
        */
        repeat array:GetSize() times
            child = array:Get(counter)
            //Vector3 localOffset = child:GetGlobalPosition()
            Vector3 localOffset = localOffsets:Get(counter)
            localOffset:Subtract(point)

            temp:Set(vector3):CrossProduct(localOffset):Scale(sin)
            rotation = localOffset:Scale(cos)
            rotation:Add(temp)
            temp:Set(vector3)
            temp:Scale((1 - cos) * temp:DotProduct(localOffset))
            rotation:Add(temp)

            rotation:Add(point):Subtract(child:GetPosition())

            child:SetOffset(rotation)
            child:Rotate(axis, degrees, false)

            counter = counter + 1
        end

    end

    /*
    This action will scale the Item3D by the values of the given Vector3. If the 
    Item3D has any children items, they will also be scaled, and their offsets 
    will be adjusted to maintain the same relative position to this item.

    Attribute: Parameter vector A Vector3 object describing how much to scale the Item3D by along the x, y, and z axes.

    Attribute: Example

    use Libraries.Interface.Item3D
    use Libraries.Compute.Vector3
    Item3D myItem
    Vector3 vector
    vector:Set(5, 2, 1)
    myItem:Scale(vector)

    */
    action Scale(Vector3 vector)
        Scale(vector, true)
    end

    /*
    This action will scale the Item3D by values of the given Vector3. If the
    boolean parameter is set to true, and if the Item3D has any children items, 
    they will also be scaled, and their offsets will be adjusted to maintain
    the same relative position to this item. If the boolean parameter is set to
    false, only this Item will be scaled.

    Attribute: Parameter vector A Vector3 object describing how much to scale the Item3D by along the x, y, and z axes.
    Attribute: Parameter scaleChildren Whether or not children objects should also be scaled.

    Attribute: Example

    use Libraries.Interface.Item3D
    use Libraries.Compute.Vector3
    Item3D myItem
    Vector3 vector
    vector:Set(5, 2, 1)
    myItem:Scale(vector, false)

    */
    action Scale(Vector3 vector, boolean scaleChildren)
        //transform:Scale(vector)
        transform:row0column0 = transform:row0column0 * vector:GetX()
        transform:row0column1 = transform:row0column1 * vector:GetX()
        transform:row0column2 = transform:row0column2 * vector:GetX()

        transform:row1column0 = transform:row1column0 * vector:GetY()
        transform:row1column1 = transform:row1column1 * vector:GetY()
        transform:row1column2 = transform:row1column2 * vector:GetY()

        transform:row2column0 = transform:row2column0 * vector:GetZ()
        transform:row2column1 = transform:row2column1 * vector:GetZ()
        transform:row2column2 = transform:row2column2 * vector:GetZ()

        if shape not= undefined
            shape:Scale(vector)
        end

        if scaleChildren and not children:IsEmpty()
            Matrix4 transform = undefined
            integer counter = 0
            repeat children:GetSize() times
                Item3D child = children:Get(counter)
                transform = child:GetTransform()

                Vector3 temp = child:GetPosition()
                Vector3 scale
                scale:Set(transform:GetScaleX(), transform:GetScaleY(), transform:GetScaleZ())
                scale:Scale(vector)
                temp:Scale(scale)
                temp:Subtract(child:GetPosition())
                temp:Add(GetGlobalPosition())
                child:SetOffset(temp)


                child:Scale(vector, true)

                counter = counter + 1
            end
        end
    end

    /*
    This action will scale the Item3D by the given values. If the 
    Item3D has any children items, they will also be scaled, and their offsets 
    will be adjusted to maintain the same relative position to this item.

    Attribute: Parameter scaleX How much to scale the Item3D along the x-axis.
    Attribute: Parameter scaleY How much to scale the Item3D along the y-axis.
    Attribute: Parameter scaleZ How much to scale the Item3D along the z-axis.

    Attribute: Example

    use Libraries.Interface.Item3D
    Item3D myItem
    myItem:Scale(5, 2, 1)

    */
    action Scale(number scaleX, number scaleY, number scaleZ)
        Vector3 vector
        vector:Set(scaleX, scaleY, scaleZ)
        Scale(vector, true)
    end

    /*
    This action will scale the Item3D by the given values. If the
    boolean parameter is set to true, and if the Item3D has any children items, 
    they will also be scaled, and their offsets will be adjusted to maintain
    the same relative position to this item. If the boolean parameter is set to
    false, only this Item will be scaled.

    Attribute: Parameter scaleX How much to scale the Item3D along the x-axis.
    Attribute: Parameter scaleY How much to scale the Item3D along the y-axis.
    Attribute: Parameter scaleZ How much to scale the Item3D along the z-axis.
    Attribute: Parameter scaleChildren Whether or not children objects should also be scaled.

    Attribute: Example

        use Libraries.Interface.Item3D
        Item3D myItem
        myItem:Scale(5, 2, 1, false)

    */
    action Scale(number scaleX, number scaleY, number scaleZ, boolean scaleChildren)
        Vector3 vector
        vector:Set(scaleX, scaleY, scaleZ)
        Scale(vector, scaleChildren)
    end

    /*
    This action is used to draw this Item on the screen, and then draw all of
    the Item's children hierarchy on the screen. Note that Items themselves can
    not be drawn, but some classes that extend the Item class, such as the
    Libraries.Game.Graphics.Model class, can be. To see how they draw, see
    their documentation.
    */
    action Draw(Painter3D painter)
        if not IsShowing()
            return now
        end

        integer counter = 0
        repeat children:GetSize() times
            children:Get(counter):Draw(painter)
            counter = counter + 1
        end
    end

    /*
    This action will return an array of all Light objects contained in the
    children hierarchy of this Item3D. If this object is a Light, it will
    also be included as the first item in the array.

    Attribute: Returns An array of all Lights stored in this Item3D.

    Attribute: Example

    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.PointLight
    use Libraries.Game.Graphics.Light
    use Libraries.Containers.Array

    Item3D item
    PointLight light1
    PointLight light2
    item:Add(light1)
    item:Add(light2)
    Array<Light> lightArray = item:GetLights()

    */
    action GetLights returns Array<Light>
        Array<Light> array
        GetLights(array)
        return array
    end

    /*
    This action will find all of the Light objects contained in the
    children hierarchy of this Item3D and add it to the end of the given array.
    If this object is a Light, it will be added to the array first before
    adding any descendents where are Lights.

    Attribute: Example

    use Libraries.Interface.Item3D
    use Libraries.Game.Graphics.PointLight
    use Libraries.Game.Graphics.Light
    use Libraries.Containers.Array

    Item3D item
    PointLight light1
    PointLight light2
    item:Add(light1)
    item:Add(light2)
    Array<Light> lightArray
    item:GetLights(lightArray)

    */
    action GetLights(Array<Light> array)
        if me is PointLight
            PointLight temp = cast(PointLight, me)
            array:Add(temp)
        end

        integer counter = 0
        repeat children:GetSize() times
            children:Get(counter):GetLights(array)
            counter = counter + 1
        end
    end

    /*
    This action is used by the Game libraries to create a reference to the layer
    that this Item3D exists on. It is automatically called as needed by the
    Layer3D class. Most users will never need to use this action directly.

    Attribute: Parameter parentLayer The layer to keep a reference to.
    */
    action SetLayer(Layer3D parentLayer)
        layer = parentLayer

        integer i = 0
        repeat children:GetSize() times
            children:Get(i):SetLayer(parentLayer)
            i = i + 1
        end

        if layer not= undefined
            layerSet = true

            if shape not= undefined
                if collidable
                    if not nodesSet
                        CreateNodes(layer:GetCollisionManager():GetBroadphase(), collisionTransform)
                    end
                else
                    if nodesSet
                        DestroyNodes(layer:GetCollisionManager():GetBroadphase())
                    end
                end
            end
        else
            layerSet = false
        end
    end

    /*
    This action returns the current Layer3D that this Item3D is a part of in the
    Game libraries. 

    Attribute: Returns The current Layer3D that this Item3D is attached to (if any).
    */
    action GetLayer returns Layer3D
        return layer
    end

    action SynchronizeNodes
        PhysicsPosition3D xf1
        
        Vector3 origin
        Matrix3 basis = collisionTransform:GetBasis()
        Vector3 center = collisionTransform:GetOrigin()
        origin:SetX(center:GetX() - basis:row2column1 - basis:row1column2)
        origin:SetY(center:GetY() - basis:row0column2 - basis:row2column0)
        origin:SetZ(center:GetZ() - basis:row1column0 - basis:row0column1)
        xf1:Set(basis, origin)

        Synchronize(layer:GetCollisionManager():GetBroadphase(), xf1, collisionTransform)

        integer i = 0
        repeat children:GetSize() times
            Item3D child = children:Get(i)
            child:SynchronizeNodes()
            i = i + 1
        end
    end

    action GetShapeType returns integer
        return shape:GetType()
    end

    action SetShape(CollisionShape3D shape)
        me:shape = shape:Copy()

        if layerSet
            if collidable
                if not nodesSet
                    CreateNodes(layer:GetCollisionManager():GetBroadphase(), collisionTransform)
                end
            else
                if nodesSet
                    DestroyNodes(layer:GetCollisionManager():GetBroadphase())
                end
            end
        end
    end

    action GetShape returns CollisionShape3D
        return shape
    end

    action GetBoundingBox(integer childIndex) returns BoundingBox
        return nodes:Get(childIndex):GetBoundingBox()
    end

    action CreateNodes(BroadphaseCollision3D broadphase, PhysicsPosition3D transform)
        if nodesSet or not collidable
            DestroyNodes(broadphase)
        end

        if collidable
            nodeCount = shape:GetChildCount()
            integer i = 0
            repeat while i < nodeCount
                Item3DNode node
                shape:ComputeBoundingBox(node:GetBoundingBox(), transform)
                node:SetNodeID(broadphase:CreateNode(node:GetBoundingBox(), node))
                node:SetItem(me)
                node:SetChildIndex(i)
                nodes:Add(node)
                i = i + 1
            end
            nodesSet = true
        end
    end

    action GetNodeCount returns integer
        return nodeCount
    end

    action DestroyNodes(BroadphaseCollision3D broadphase)
        integer i = 0
        repeat while i < nodeCount
            Item3DNode node = nodes:Get(i)
            broadphase:DestroyNode(node:GetNodeID())
            node:SetNodeID(-1)
            nodes:Remove(node)
            i = i + 1
        end

        nodeCount = 0
        nodesSet = false
    end

    private action Synchronize(BroadphaseCollision3D broadphase, PhysicsPosition3D transform1, PhysicsPosition3D transform2)
        if nodeCount = 0
            return now
        end

        integer i = 0
        repeat while i < nodeCount
            Item3DNode node = nodes:Get(i)
            
            BoundingBox boundingBox1
            BoundingBox boundingBox2

            shape:ComputeBoundingBox(boundingBox1, transform1)
            shape:ComputeBoundingBox(boundingBox2, transform2)

            Vector3 minimum = node:GetBoundingBox():GetMinimum()
            Vector3 maximum = node:GetBoundingBox():GetMaximum()

            if boundingBox1:GetMinimum():GetX() < boundingBox2:GetMinimum():GetX()
                minimum:SetX(boundingBox1:GetMinimum():GetX())
            else
                minimum:SetX(boundingBox2:GetMinimum():GetX())
            end

            if boundingBox1:GetMinimum():GetY() < boundingBox2:GetMinimum():GetY()
                minimum:SetY(boundingBox1:GetMinimum():GetY())
            else
                minimum:SetY(boundingBox2:GetMinimum():GetY())
            end

            if boundingBox1:GetMinimum():GetZ() < boundingBox2:GetMinimum():GetZ()
                minimum:SetZ(boundingBox1:GetMinimum():GetZ())
            else
                minimum:SetZ(boundingBox2:GetMinimum():GetZ())
            end

            if boundingBox1:GetMaximum():GetX() > boundingBox2:GetMaximum():GetX()
                maximum:SetX(boundingBox1:GetMaximum():GetX())
            else
                maximum:SetX(boundingBox2:GetMaximum():GetX())
            end

            if boundingBox1:GetMaximum():GetY() > boundingBox2:GetMaximum():GetY()
                maximum:SetY(boundingBox1:GetMaximum():GetY())
            else
                maximum:SetY(boundingBox2:GetMaximum():GetY())
            end

            if boundingBox1:GetMaximum():GetZ() > boundingBox2:GetMaximum():GetZ()
                maximum:SetZ(boundingBox1:GetMaximum():GetZ())
            else
                maximum:SetZ(boundingBox2:GetMaximum():GetZ())
            end

            Vector3 displacement
            displacement:SetX(transform2:GetOrigin():GetX() - transform1:GetOrigin():GetX())
            displacement:SetY(transform2:GetOrigin():GetY() - transform1:GetOrigin():GetY())
            displacement:SetZ(transform2:GetOrigin():GetZ() - transform1:GetOrigin():GetZ())

            broadphase:MoveNode(node:GetNodeID(), node:GetBoundingBox(), displacement)

            i = i + 1
        end
    end

    action GetNodes returns Array<Item3DNode>
        return nodes
    end

    action GetNode(integer index) returns Item3DNode
        return nodes:Get(index)
    end

    action SetCollidable(boolean flag)
        if collidable = flag
            return now
        end

        collidable = flag

        if collidable
            if layerSet and shape not= undefined
                BroadphaseCollision3D broadphase = layer:GetCollisionManager():GetBroadphase()
                CreateNodes(broadphase, collisionTransform)
            end
        else
            if layerSet
                BroadphaseCollision3D broadphase = layer:GetCollisionManager():GetBroadphase()
                DestroyNodes(broadphase)
                CollisionEdge3D edge = collisionList
                repeat while edge not= undefined
                    CollisionEdge3D edge0 = edge
                    edge = edge:GetNext()
                    layer:GetCollisionManager():Destroy(edge0:GetCollision())
                end
                collisionList = undefined
            end
        end
    end

    action IsCollidable returns boolean
        return collidable
    end

    action GetCollisionTransform returns PhysicsPosition3D
        return collisionTransform
    end

    action GetInterpolationTransform returns PhysicsPosition3D
        return interpolationTransform
    end

    action SetCollisionTransform(PhysicsPosition3D transform)
        collisionTransform:Set(transform)
    end

    action SetInterpolationTransform(PhysicsPosition3D transform)
        interpolationTransform:Set(transform)
    end

    action GetCollisionList returns CollisionEdge3D
        return collisionList
    end

    action SetCollisionList(CollisionEdge3D list)
        collisionList = list
    end

    action GetJointList returns JointEdge3D
        return jointList
    end

    action SetJointList(JointEdge3D list)
        jointList = list
    end

    action IsPhysicsEnabled returns boolean
        return physicsEnabled
    end

    action EnablePhysics(boolean flag)
        physicsEnabled = flag
    
        if physicsEnabled
            SetCollidable(true)
            PhysicsProperties3D properties
            me:properties = properties
            properties:SetItem(me)
            interpolationTransform:Set(collisionTransform)
            collisionTransform0:Set(collisionTransform)
        end
    end

    action SetLinearVelocity(Vector3 linearVelocity)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetLinearVelocity(linearVelocity)
    end

    action SetLinearVelocityX(number linearVelocityX)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetLinearVelocityX(linearVelocityX)
    end

    action SetLinearVelocityY(number linearVelocityY)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetLinearVelocityY(linearVelocityY)
    end

    action SetLinearVelocityZ(number linearVelocityZ)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetLinearVelocityZ(linearVelocityZ)
    end

    action GetLinearVelocity returns Vector3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetLinearVelocity()
    end

    action SetAngularVelocity(Vector3 angularVelocity)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetAngularVelocity(angularVelocity)
    end

    action GetAngularVelocity returns Vector3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetAngularVelocity()
    end

    action SetForce(Vector3 force)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetForce(force)
    end

    action GetForce returns Vector3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetForce()
    end

    action SetTorque(Vector3 torque)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetTorque(torque)
    end

    action GetTorque returns Vector3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetTorque()
    end

    action ApplyForce(Vector3 force, Vector3 point)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:ApplyForce(force, point)
    end

    action ApplyForceToCenter(Vector3 force)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:ApplyForceToCenter(force)
    end

    action ApplyTorque(Vector3 torque)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:ApplyTorque(torque)
    end

    action ApplyLinearImpulse(Vector3 impulse, Vector3 point)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:ApplyLinearImpulse(impulse, point)
    end

    action ApplyAngularImpulse(Vector3 impulse)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:ApplyAngularImpulse(impulse)
    end

    action GetMass returns number
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetMass()
    end

    action SetMass(number mass)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetMass(mass)
    end

    action GetInverseMass returns number
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetInverseMass()
    end

    action GetInverseInertiaWorld returns Matrix3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetInverseInertiaWorld()
    end

    action GetLinearDamping returns number
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetLinearDamping()
    end

    action SetLinearDamping(number linearDamping)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetLinearDamping(linearDamping)
    end

    action GetAngularDamping returns number
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetAngularDamping()
    end

    action SetAngularDamping(number angularDamping)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetAngularDamping(angularDamping)
    end

    action GetResponsiveness returns integer
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetResponsiveness()
    end

    action SetResponsiveness(integer type)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetResponsiveness(type)
    end

    action SetFriction(number friction)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetFriction(friction)
    end

    action GetFriction returns number
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetFriction()
    end

    action SetRestitution(number restitution)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetRestitution(restitution)
    end

    action GetRestitution returns number
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetRestitution()
    end

    /*
    This action lets the 3D collision solver actions (inside the class CollisionSolver3D) know that if this object needs its physics to be updated.
    Attribute: Parameter flag True if physics needs to be updated; false if physics doesn't need to be updated, which is when this object is a "unmovable" object in the physics space.
    */
    action SetCollisionGroupFlag(boolean flag)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetCollisionGroupFlag(flag)
    end

    action GetCollisionGroupFlag returns boolean
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end
        return properties:GetCollisionGroupFlag()
    end

    /*
    This action sets where in the "list of objects that needs to be updated because collision happened" that this object resides in.
    This "list of objects that needs to be updated because collision happened" is stored inside the CollisionSolver3D class as tempSolverBodyPool.
    Attribute: Parameter index the index at which this object resides in in the tempSolverBodyPool.
    */
    action SetCollisionGroupIndex(integer index)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetCollisionGroupIndex(index)
    end

    action GetCollisionGroupIndex returns integer
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetCollisionGroupIndex()
    end

    action IsFastMoving returns boolean
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:IsFastMoving()
    end

    action FastMoving(boolean flag)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:FastMoving(flag)
    end

    action RequireSimulation(boolean flag)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:RequireSimulation(flag)
    end

    action IsSimulationRequired returns boolean
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:IsSimulationRequired()
    end

    action Simulate(boolean flag)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:Simulate(flag)
    end

    action IsSimulated returns boolean
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:IsSimulated()
    end

    action CanRotate(boolean flag)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:CanRotate(flag)
        ResetMass()
    end

    action IsRotationAllowed returns boolean
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:IsRotationAllowed()
    end

    action SetSleepTime(number time)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetSleepTime(time)
    end

    action GetSleepTime returns number
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetSleepTime()
    end

    action SetResponsive
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetResponsiveness(properties:RESPONSIVE)
    end

    action IsResponsive returns boolean
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetResponsiveness() = properties:RESPONSIVE
    end

    action SetNonResponsive
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetResponsiveness(properties:NON_RESPONSIVE)
    end

    action IsNonResponsive returns boolean
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetResponsiveness() = properties:NON_RESPONSIVE
    end

    action SetUnmovable
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetResponsiveness(properties:UNMOVABLE)
    end

    action IsUnmovable returns boolean
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetResponsiveness() = properties:UNMOVABLE
    end

    action GetPhysicsProperties returns PhysicsProperties3D
        return properties
    end

    action SetPhysicsProperties(PhysicsProperties3D properties)
        me:properties = properties:Copy()
        me:properties:SetItem(me)
    end

    action ResetMass

    end

    action ShouldCollide(Item3D otherItem) returns boolean
        if not collideWithChildren
            if otherItem = parentItem
                return false
            end
            integer i = 0
            repeat children:GetSize() times
                Item3D child = children:Get(i)
                if child = otherItem
                    return false
                end
                i = i + 1
            end
        end

        return true
    end

    action CollideWithChildren returns boolean
        return collideWithChildren
    end

    action SetCollideWithChildren(boolean flag)
        me:collideWithChildren = flag
    end

    action HasMoved returns boolean
        return hasMoved
    end

    action SetHasMoved(boolean flag)
        hasMoved = flag
    end

    action IntegrateVelocities(number seconds)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        if not IsResponsive()
            return now
        end

        properties:IntegrateVelocities(seconds)
    end

    action ApplyDamping(number seconds)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:ApplyDamping(seconds)
    end

    action PredictIntegratedTransform(number seconds, PhysicsPosition3D predictedTransform)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:IntegrateTransform(collisionTransform, seconds, predictedTransform)
    end

    action GetInterpolationWorldTransform returns PhysicsPosition3D
        return interpolationTransform
    end

    action SetCenterOfMassTransform(PhysicsPosition3D transform)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        if not IsResponsive()
            interpolationTransform:Set(collisionTransform)
            collisionTransform0:Set(collisionTransform)
        else
            interpolationTransform:Set(transform)
            collisionTransform0:Set(transform)
        end

        properties:GetInterpolatedLinearVelocity():Set(properties:GetLinearVelocity())
        properties:GetInterpolatedAngularVelocity():Set(properties:GetAngularVelocity())
        collisionTransform:Set(transform)
        UpdateInertia()
    end

    action UpdateInertia
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:UpdateInertia(collisionTransform:GetBasis())
    end

    action GetCenterOfMassPosition returns Vector3
        return collisionTransform:GetOrigin()
    end

    action GetOrientation returns Quaternion
        Matrix3 basis = collisionTransform:GetBasis()
        Quaternion quaternion
        number trace = basis:row0column0 + basis:row1column1 + basis:row2column2

        Array<number> temp
        temp:SetSize(4)

        if trace > 0
            number s = math:SquareRoot(trace + 1)
            temp:Set(3, s * 0.5)
            s = 0.5 / s

            temp:Set(0, ((basis:row2column1 - basis:row1column2) * s))
            temp:Set(1, ((basis:row0column2 - basis:row2column0) * s))
            temp:Set(2, ((basis:row1column0 - basis:row0column1) * s))
        else
            integer i = 0
            if basis:row0column0 < basis:row1column1
                if basis:row1column1 < basis:row2column2
                    i = 2
                else
                    i = 1
                end
            else
                if basis:row0column0 < basis:row2column2
                    i = 2
                else
                    i = 0
                end
            end

            integer j = (i + 1) mod 3
            integer k = (i + 2) mod 3

            number s = math:SquareRoot(basis:GetElement(i, i) - basis:GetElement(j, j) - basis:GetElement(k, k) + 1)
            temp:Set(i, s * 0.5)
            s = 0.5 / s

            temp:Set(3, (basis:GetElement(k, j) - basis:GetElement(j, k)) * s)
            temp:Set(j, (basis:GetElement(j, i) + basis:GetElement(i, j)) * s)
            temp:Set(k, (basis:GetElement(k, i) + basis:GetElement(i, k)) * s)
        end
        quaternion:Set(temp:Get(0), temp:Get(1), temp:Get(2), temp:Get(3)) 
        return quaternion
    end

    action GetCenterOfMassTransform returns PhysicsPosition3D
        return collisionTransform
    end

    action GetLinearVelocityAtLocalPoint(Vector3 relativePosition) returns Vector3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetLinearVelocityAtLocalPoint(relativePosition)
    end

    action ComputeImpulseDenominator(Vector3 position, Vector3 normal) returns number
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        Vector3 r0
        r0:Set(position):Subtract(GetCenterOfMassPosition())

        Vector3 c0
        c0:Set(r0):CrossProduct(normal)

        Vector3 temp
        Matrix3 mat = properties:GetInverseInertiaWorld()
        Vector3 dest = temp
        Vector3 vector = c0
        number x = mat:row0column0 * vector:GetX() + mat:row1column0 * vector:GetY() + mat:row2column0 * vector:GetZ()
        number y = mat:row0column1 * vector:GetX() + mat:row1column1 * vector:GetY() + mat:row2column1 * vector:GetZ()
        number z = mat:row0column2 * vector:GetX() + mat:row1column2 * vector:GetY() + mat:row2column2 * vector:GetZ()
        dest:SetX(x)
        dest:SetY(y)
        dest:SetZ(z)

        Vector3 vec
        vec:Set(temp):CrossProduct(r0)

        return properties:GetInverseMass() + normal:DotProduct(vec)
    end

    action ComputeAngularImpulseDenominator(Vector3 axis) returns number
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        Vector3 vec
        Matrix3 mat = properties:GetInverseInertiaWorld()
        Vector3 dest = vec
        Vector3 vector = axis
        number x = mat:row0column0 * vector:GetX() + mat:row1column0 * vector:GetY() + mat:row2column0 * vector:GetZ()
        number y = mat:row0column1 * vector:GetX() + mat:row1column1 * vector:GetY() + mat:row2column1 * vector:GetZ()
        number z = mat:row0column2 * vector:GetX() + mat:row1column2 * vector:GetY() + mat:row2column2 * vector:GetZ()
        dest:SetX(x)
        dest:SetY(y)
        dest:SetZ(z)

        return axis:DotProduct(vec)
    end

    action SetInterpolatedLinearVelocity(Vector3 velocity)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetInterpolatedLinearVelocity(velocity)
    end

    action GetInterpolatedLinearVelocity returns Vector3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetInterpolatedLinearVelocity()
    end

    action SetInterpolatedAngularVelocity(Vector3 velocity)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:SetInterpolatedAngularVelocity(velocity)
    end

    action GetInterpolatedAngularVelocity returns Vector3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetInterpolatedAngularVelocity()
    end

    action SaveKinematicState(number time)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        if time not= 0
            properties:SaveKinematicState(time)
        end
    end

    action GetInverseInertiaLocal returns Vector3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetInverseInertiaLocal()
    end

    action InternalApplyImpulse(Vector3 linearComponent, Vector3 angularComponent, number impulseMagnitude)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:InternalApplyImpulse(linearComponent, angularComponent, impulseMagnitude)
    end


    /*
    ACTIONS MADE FOR JOINTS.
    */
    action ApplyLinearImpulseToCenter(Vector3 impulse)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:ApplyLinearImpulseToCenter(impulse)  //exists
    end

    action ApplyImpulse(Vector3 impulse, Vector3 localPositionToApply)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:ApplyLinearImpulse(impulse, localPositionToApply)
    end

    action ApplyTorqueImpulse(Vector3 torque)
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        properties:ApplyTorque(torque)
    end



    action GetPushVelocity returns Vector3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetPushVelocity()
    end

    action GetTurnVelocity returns Vector3
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetTurnVelocity()
    end

    action ProceedToTransform(PhysicsPosition3D transform)
        SetCenterOfMassTransform(transform)
    end

    action SetCollisionTransform0(PhysicsPosition3D transform)
        me:collisionTransform0 = transform
    end

    action GetCollisionTransform0 returns PhysicsPosition3D
        return me:collisionTransform0
    end

    action SetScreenPositionFromPhysicsPosition
        me:updateTransform = false

        Vector3 vector
        shape:GetLocalScaling(vector)

        Matrix3 tempMatrix
        tempMatrix:Set(collisionTransform:GetBasis())

        // Conversion between left-handed coordinate system and right-handed
        // coordinate system rotation matrices is achieved via the following:
        //    If the matrix M = [mij], 0 <= i <= 2, 0 <= j <= 2, is a rotation
        //    in a left- (right-) handed coordinate system, then to convert it
        //    to a right- (left-) handed coordinate system, change the signs of
        //    m02, m12, m20, m21.
        // Source: http://answers.unity3d.com/storage/temp/12048-lefthandedtorighthanded.pdf
        Matrix4 matrix
        matrix:IdentityMatrix()
        matrix:row0column0 = tempMatrix:row0column0 * vector:GetX()
        matrix:row0column1 = tempMatrix:row0column1 * vector:GetX()
        matrix:row0column2 = -tempMatrix:row0column2 * vector:GetX()

        matrix:row1column0 = tempMatrix:row1column0 * vector:GetY()
        matrix:row1column1 = tempMatrix:row1column1 * vector:GetY()
        matrix:row1column2 = -tempMatrix:row1column2 * vector:GetY()

        matrix:row2column0 = -tempMatrix:row2column0 * vector:GetZ()
        matrix:row2column1 = -tempMatrix:row2column1 * vector:GetZ()
        matrix:row2column2 = tempMatrix:row2column2 * vector:GetZ()

        matrix:row0column3 = collisionTransform:GetOrigin():GetX()
        matrix:row1column3 = collisionTransform:GetOrigin():GetY()
        matrix:row2column3 = collisionTransform:GetOrigin():GetZ()

        transform:Set(matrix)

        me:x = collisionTransform:GetOrigin():GetX()
        me:y = collisionTransform:GetOrigin():GetY()
        me:z = collisionTransform:GetOrigin():GetZ()

        me:updateTransform = true
    end

    action GetTimeOfImpact returns number
        return timeOfImpact
    end

    action SetTimeOfImpact(number timeOfImpact)
        me:timeOfImpact = timeOfImpact
    end

    action GetAngularFactor returns number
        if properties = undefined
            alert(PHYSICS_ERROR_MESSAGE)
        end

        return properties:GetAngularFactor()
    end

    /*
    This action returns the x coordinate of the Item on the screen. If the Item
    hasn't been attached to a Layer, this will return a "Not a Number" value
    instead.
    */
    action GetScreenX returns number
        if layer not= undefined
            Camera camera = layer:GetCamera()
            if camera not= undefined
                Vector3 vector = GetGlobalPosition()
                // The WorldToScreenCoordinates action modifies the values
                // of the passed Vector3 parameter.
                camera:WorldToScreenCoordinates(vector)
                return camera:GetWidth() - vector:GetX()
            end
        end

        // Return NaN if the Item isn't on a layer with a camera (and thus can't
        // actually be on the screen).
        return z:GetNotANumberValue()
    end

    /*
    This action returns the y coordinate of the Item on the screen. If the Item
    hasn't been attached to a Layer, this will return a "Not a Number" value
    instead.
    */
    action GetScreenY returns number
        if layer not= undefined
            Camera camera = layer:GetCamera()
            if camera not= undefined
                Vector3 vector = GetGlobalPosition()
                // The WorldToScreenCoordinates action modifies the values
                // of the passed Vector3 parameter.
                camera:WorldToScreenCoordinates(vector)
                return vector:GetY()
            end
        end

        // Return NaN if the Item isn't on a layer with a camera (and thus can't
        // actually be on the screen).
        return z:GetNotANumberValue()
    end

    /*
    This action returns a 2D rectangle describing the approximate bounds of this
    Item3D on the screen. The rectangle isn't rotated (i.e. the rectangle's
    edges are aligned with the screen's edges), so the rectangle may be
    significantly larger than the space taken by the Item3D on the screen in
    some cases.
    */
    action GetScreenBounds returns Rectangle
        if layer = undefined or layer:GetCamera() = undefined
            return undefined
        end

        Camera camera = layer:GetCamera()

        number minX = 0
        number minY = 0
        number maxX = 0
        number maxY = 0
        number width = camera:GetWidth()
        Vector3 calcVector
        Vector3 minimum = undefined
        Vector3 maximum = undefined

        Rectangle rectangle

        if not nodes:IsEmpty()
            BoundingBox box = GetBoundingBox(0)
            minimum = box:GetMinimum()
            maximum = box:GetMaximum()
        else
            Vector3 minVector
            minVector:Set(GetGlobalX() - GetWidth() / 2.0, GetGlobalY() - GetHeight() / 2.0, GetGlobalZ() - GetDepth() / 2.0)
            minimum = minVector
            
            Vector3 maxVector
            maxVector:Set(GetGlobalX() + GetWidth() / 2.0, GetGlobalY() + GetHeight() / 2.0, GetGlobalZ() + GetDepth() / 2.0)
            maximum = maxVector
        end

        calcVector:Set(minimum:GetX(), minimum:GetY(), minimum:GetZ())
        camera:WorldToScreenCoordinates(calcVector)
        minX = width - calcVector:GetX()
        minY = calcVector:GetY()
        maxX = minX
        maxY = minY

        calcVector:Set(minimum:GetX(), minimum:GetY(), maximum:GetZ())
        camera:WorldToScreenCoordinates(calcVector)
        if (width - calcVector:GetX()) < minX
            minX = width - calcVector:GetX()
        end
        if (width - calcVector:GetX()) > maxX
            maxX = width - calcVector:GetX()
        end
        if calcVector:GetY() < minY
            minY = calcVector:GetY()
        end
        if calcVector:GetY() > maxY
            maxY = calcVector:GetY()
        end

        calcVector:Set(minimum:GetX(), maximum:GetY(), minimum:GetZ())
        camera:WorldToScreenCoordinates(calcVector)
        if (width - calcVector:GetX()) < minX
            minX = width - calcVector:GetX()
        end
        if (width - calcVector:GetX()) > maxX
            maxX = width - calcVector:GetX()
        end
        if calcVector:GetY() < minY
            minY = calcVector:GetY()
        end
        if calcVector:GetY() > maxY
            maxY = calcVector:GetY()
        end

        calcVector:Set(minimum:GetX(), maximum:GetY(), maximum:GetZ())
        camera:WorldToScreenCoordinates(calcVector)
        if (width - calcVector:GetX()) < minX
            minX = width - calcVector:GetX()
        end
        if (width - calcVector:GetX()) > maxX
            maxX = width - calcVector:GetX()
        end
        if calcVector:GetY() < minY
            minY = calcVector:GetY()
        end
        if calcVector:GetY() > maxY
            maxY = calcVector:GetY()
        end

        calcVector:Set(maximum:GetX(), minimum:GetY(), minimum:GetZ())
        camera:WorldToScreenCoordinates(calcVector)
        if (width - calcVector:GetX()) < minX
            minX = width - calcVector:GetX()
        end
        if (width - calcVector:GetX()) > maxX
            maxX = width - calcVector:GetX()
        end
        if calcVector:GetY() < minY
            minY = calcVector:GetY()
        end
        if calcVector:GetY() > maxY
            maxY = calcVector:GetY()
        end

        calcVector:Set(maximum:GetX(), minimum:GetY(), maximum:GetZ())
        camera:WorldToScreenCoordinates(calcVector)
        if (width - calcVector:GetX()) < minX
            minX = width - calcVector:GetX()
        end
        if (width - calcVector:GetX()) > maxX
            maxX = width - calcVector:GetX()
        end
        if calcVector:GetY() < minY
            minY = calcVector:GetY()
        end
        if calcVector:GetY() > maxY
            maxY = calcVector:GetY()
        end

        calcVector:Set(maximum:GetX(), maximum:GetY(), minimum:GetZ())
        camera:WorldToScreenCoordinates(calcVector)
        if (width - calcVector:GetX()) < minX
            minX = width - calcVector:GetX()
        end
        if (width - calcVector:GetX()) > maxX
            maxX = width - calcVector:GetX()
        end
        if calcVector:GetY() < minY
            minY = calcVector:GetY()
        end
        if calcVector:GetY() > maxY
            maxY = calcVector:GetY()
        end

        calcVector:Set(maximum:GetX(), maximum:GetY(), maximum:GetZ())
        camera:WorldToScreenCoordinates(calcVector)
        if (width - calcVector:GetX()) < minX
            minX = width - calcVector:GetX()
        end
        if (width - calcVector:GetX()) > maxX
            maxX = width - calcVector:GetX()
        end
        if calcVector:GetY() < minY
            minY = calcVector:GetY()
        end
        if calcVector:GetY() > maxY
            maxY = calcVector:GetY()
        end

        rectangle:SetRectangle(minX, minY, maxX - minX, maxY - minY)

        return rectangle
    end
end
