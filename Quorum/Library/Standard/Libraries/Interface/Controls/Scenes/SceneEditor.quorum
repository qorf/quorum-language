package Libraries.Interface.Controls.Scenes

use Libraries.Interface.Controls.Control
use Libraries.Interface.Layouts.FlowLayout
use Libraries.Interface.Views.LabelBoxView
use Libraries.Game.Graphics.Color
use Libraries.Game.Graphics.Camera
use Libraries.Game.Layer3D
use Libraries.Compute.Vector2
use Libraries.Compute.Vector3
use Libraries.Containers.Array
use Libraries.Interface.Item
use Libraries.Interface.Item2D
use Libraries.Interface.Item3D
use Libraries.Game.Graphics.Model
use Libraries.Compute.Math
use Libraries.Game.GameStateManager
use Libraries.Compute.Matrix4
use Libraries.Interface.Accessibility
use Libraries.Interface.Events.FocusListener
use Libraries.Interface.Events.FocusEvent
use Libraries.Game.Graphics.Drawable
use Libraries.Containers.HashTable
use Libraries.Game.Game
use Libraries.System.File
use Libraries.Interface.Controls.Button
use Libraries.Interface.Controls.Scenes.Items.EditorItem
use Libraries.Interface.Controls.Scenes.Items.Previews.ItemPreview
use Libraries.Interface.Controls.Scenes.Layers.EditorLayer
use Libraries.Interface.Controls.Scenes.Items.EditorCursor
use Libraries.Interface.Selections.SceneEditorSelection
use Libraries.Interface.Events.SceneEditorChangeListener
use Libraries.Interface.Undo.SceneEditorEditManager
use Libraries.Interface.Controls.Scenes.Items.Highlights.SelectionHighlight
use Libraries.Interface.Controls.Scenes.Items.EditorCursor2D
use Libraries.Interface.Controls.Scenes.Items.EditorCursor3D
use Libraries.Interface.Controls.Scenes.Layers.EditorLayer2D
use Libraries.Interface.Controls.Scenes.Layers.EditorLayer3D
use Libraries.Interface.Controls.Scenes.Items.Highlights.SelectionHighlight2D
use Libraries.Interface.Controls.Scenes.Items.Highlights.SelectionHighlight3D
use Libraries.Interface.Controls.Scenes.Items.Highlights.PointLightSelectionHighlight
use Libraries.Interface.Controls.Scenes.Items.Highlights.Audio3DSelectionHighlight
use Libraries.Interface.Controls.Scenes.Items.Highlights.ModelSelectionHighlight
use Libraries.Interface.Controls.Scenes.Items.EditorPointLight
use Libraries.Interface.Controls.Scenes.Items.EditorModel
use Libraries.Interface.Controls.Scenes.Items.EditorAudio3D
use Libraries.Interface.Undo.SceneEditorDeleteEdit
use Libraries.Interface.Events.SceneEditorChangeEvent
use Libraries.Interface.Undo.SceneEditorInsertEdit
use Libraries.Interface.Controls.Scenes.Items.Previews.ItemPreview2D
use Libraries.Interface.Controls.Scenes.Items.Previews.ItemPreview3D
use Libraries.Interface.Controls.Scenes.Items.Previews.ModelPreview
use Libraries.Interface.Controls.Scenes.Items.Previews.PointLightPreview
use Libraries.Interface.Controls.Scenes.Blueprints.PointLightBlueprint
use Libraries.Interface.Controls.Scenes.Items.Previews.Audio3DPreview
use Libraries.Interface.Controls.Scenes.Blueprints.Audio3DBlueprint
use Libraries.Interface.Controls.Scenes.Items.Previews.Custom3DPrimitivePreview
use Libraries.Interface.Controls.Scenes.Blueprints.Custom3DPrimitiveBlueprint
use Libraries.Interface.Controls.Scenes.Blueprints.CustomModelBlueprint
use Libraries.Interface.Controls.Scenes.Blueprints.ModelBlueprint
use Libraries.Interface.Controls.Scenes.Blueprints.ItemBlueprint
use Libraries.Interface.Controls.Scenes.Blueprints.DrawableBlueprint
use Libraries.Interface.Controls.Scenes.Items.CameraItem2D
use Libraries.Interface.Controls.Scenes.Items.CameraItem3D
use Libraries.Interface.Controls.Scenes.Items.EditorItem2D
use Libraries.Interface.Controls.Scenes.Items.CameraItem
use Libraries.Interface.Controls.Scenes.Items.EditorItem3D
use Libraries.Game.Scenes.DefaultSceneManager
use Libraries.Game.Scenes.SceneProperties
use Libraries.Game.Scenes.Scene
use Libraries.Interface.Controls.Scenes.Items.Previews.CameraPreview2D
use Libraries.Game.Layer
use Libraries.Data.Formats.JavaScriptObjectNotation
use Libraries.Containers.Number32BitArray
use Libraries.Interface.Controls.Scenes.Items.Grid3D
use Libraries.Interface.Controls.Scenes.Dialogs.Item3DPropertiesDialog
use Libraries.Interface.Controls.Scenes.Dialogs.Item2DPropertiesDialog
use Libraries.Interface.Controls.Scenes.Dialogs.Camera2DPropertiesDialog
use Libraries.Interface.Controls.Scenes.Dialogs.Camera3DPropertiesDialog
use Libraries.Interface.Controls.Scenes.Dialogs.PointLightPropertiesDialog
use Libraries.Interface.Controls.Scenes.Dialogs.Audio3DPropertiesDialog
use Libraries.Interface.Controls.Scenes.Dialogs.PropertiesDialog
use Libraries.Interface.Controls.Scenes.Dialogs.SceneEditorFindDialog


/*
SceneEditor is the main Control that enables adding a functional scene editor
to a Game. 

Attribute: Example

TODO
need to implement more to understand how to structure examples.

*/
class SceneEditor is Control, DefaultSceneManager

    File file = undefined
    File projectLocation = undefined
    GameStateManager manager
    SceneProperties properties

    Array<EditorLayer> layers

    SceneConstants constants
    SceneEditorSelection selection

    Array<SceneEditorChangeListener> sceneEditorChangeListeners

    SceneEditorEditManager editManager

    // The rotational speed measured in degrees,
    // and the directional speed, measured in 3D world units.
    public constant number CAMERA_ROTATIONAL_SPEED_3D = 15
    public constant number CAMERA_DIRECTIONAL_SPEED_3D = 1

    public constant number SELECTION_ROTATIONAL_SPEED_3D = 90
    public constant number SELECTION_DIRECTIONAL_SPEED_3D = 5

    public constant number CAMERA_ROTATIONAL_SPEED_2D = 90
    public constant number CAMERA_DIRECTIONAL_SPEED_2D = 600
    public constant number SELECTION_ROTATIONAL_SPEED_2D = 90
    public constant number SELECTION_DIRECTIONAL_SPEED_2D = 600

    /*
    Velocities of the layer's camera.
    Directions are always -1, 0, or 1, and are multiplied by either the rotational
    or directional speed during the Update to produce the per-frame velocity.
    */
    integer yawDirection = 0
    integer pitchDirection = 0
    integer rollDirection = 0
    integer forwardDirection = 0
    integer strafeDirection = 0
    integer verticalDirection = 0

    // The velocity of the currently selected item on each axis.
    integer selectionXDirection = 0
    integer selectionYDirection = 0
    integer selectionZDirection = 0
    integer selectionYawDirection = 0
    integer selectionPitchDirection = 0
    integer selectionRollDirection = 0

    // Vectors which are constantly reused for frequent calculations.
    Vector2 workVector2
    Vector3 workVector3

    Accessibility accessibility = undefined
    Math math
    Color color

    /*
    A subset of the items, filtered in some way (e.g., the items in view of
    the camera). These can be iterated over to query for more information or to
    modify the elements.
    */
    Array<Item> filteredItems = undefined

    /*
    "Highlight" drawables used to show which items have been filtered.
    */
    Array<SelectionHighlight> filterHighlights

    /*
    Tracks how many times each name has been used from the palette.
    Used to add numbers to the end of the names of duplicate items.
    */
    HashTable<text, integer> nameCounts

    // Used for when a movement key is held and the grid lock is enabled.
    number gridMoveTimer = 0
    number gridMoveTimerMax = 0.5

    // A reference to the property dialogs for this controller.
    Item3DPropertiesDialog item3dPropertiesDialog
    Item2DPropertiesDialog item2dPropertiesDialog
    Camera2DPropertiesDialog camera2dPropertiesDialog
    Camera3DPropertiesDialog camera3dPropertiesDialog
    PointLightPropertiesDialog pointLightPropertiesDialog
    Audio3DPropertiesDialog audio3DPropertiesDialog

    // An array containing the different property dialogs.
    Array<PropertiesDialog> propertiesDialogs

    // A reference to the find dialog for this controller.
    SceneEditorFindDialog findDialog

    // Used to forcibly change the focus and send information via the screen reader.
    Item2D dummyItem


    on create
        FlowLayout layout
        SetLayout(layout)
        SetPercentageWidth(1.0)
        SetPercentageHeight(1.0)
        
        LabelBoxView view
        view:Initialize(color:CustomColor(0.9, 0.9, 0.925, 1), color:CustomColor(0.9, 0.9, 0.925, 1))
        SetView2D(view)

        SetInputGroup("SceneEditor")
        SetName("Scene Editor")
        SetFocusable(true)
        SetAccessibilityCode(parent:Item:CUSTOM)

        accessibility = manager:GetAccessibility()

        selection:Initialize(me)
        findDialog:Initialize(me)

        propertiesDialogs:Add(item2dPropertiesDialog)
        propertiesDialogs:Add(item3dPropertiesDialog)
        propertiesDialogs:Add(camera2dPropertiesDialog)
        propertiesDialogs:Add(camera3dPropertiesDialog)
        propertiesDialogs:Add(pointLightPropertiesDialog)
        propertiesDialogs:Add(audio3DPropertiesDialog)

        integer counter = 0
        repeat while counter < propertiesDialogs:GetSize()
            propertiesDialogs:Get(counter):Initialize(me)
            counter = counter + 1
        end
    end

    action GetFile returns File
        return file
    end

    action SetFile(File file)
        me:file = file
    end

    action GetProjectLocation returns File
        return projectLocation
    end

    action SetProjectLocation(File file)
        me:projectLocation = file
    end

    /*
    This action returns the relative path to reach the provided file
    from the project location associated with this tab.
    */
    action GetProjectPathToFile(File file) returns text
        text projectPath = projectLocation:GetAbsolutePath()
        text goalPath = file:GetAbsolutePath()

        Array<text> start = undefined
        Array<text> goal = undefined
        // The "Contains" action can correctly test for backslashes, but the "Split" command requires the escape character "\\", or it crashes
        if projectPath:Contains("\")
            start = projectPath:Split("\\")
            goal = goalPath:Split("\\")
        else
            start = projectPath:Split("/")
            goal = goalPath:Split("/")
        end

        /*
        Steps:
        1. Remove all common elements between the two paths
        2. For each element remaining in the source, prepend "../"
        3. For each element remaining in the goal, append it to the end
        */

        text result = ""
        boolean taskDone = false
        repeat until start:IsEmpty() or goal:IsEmpty() or taskDone
            text chunk1 = start:GetFromFront()
            text chunk2 = goal:GetFromFront()

            if chunk1 = chunk2
                start:RemoveFromFront()
                goal:RemoveFromFront()
            else
                taskDone = true
            end
        end

        repeat start:GetSize() times
            result = result + "../"
        end

        repeat until goal:IsEmpty()
            result = result + goal:RemoveFromFront()
            if goal:IsEmpty() = false
                result = result + "/"
            end
        end

        return result
    end

    action Load
        Scene scene
        scene:Load(file)
        SetName(file:GetPath())
        Load(scene)
    end

    /*
    This action returns the description of the item currently focused by the cursor on
    the current layer. If there is no item at the cursor this action returns the position
    of the cursor. If there are multiple items this action will return the names of each item
    at the current cursor position.

    Attribute: Returns The affine as the identy matrix

    */
    action GetDescription returns text
        if GetSelectedLayer() not= undefined
            EditorCursor cursor = GetSelectedLayer():GetCursor()
            text position = ""

            if cursor is EditorCursor2D
                EditorCursor2D cursor2D = cast(EditorCursor2D, cursor)
                position = cast(integer, cursor2D:GetX()) + " " + cast(integer, cursor2D:GetY())
            elseif cursor is EditorCursor3D
                EditorCursor3D cursor3D = cast(EditorCursor3D, cursor)
                position = cast(integer, cursor3D:GetX()) + " " + cast(integer, cursor3D:GetY()) + " " + cast(integer, cursor3D:GetZ())
            end

            Array<Item> items = cursor:GetItemsAtCursor()
            if items:GetSize() = 0
                return position
            elseif items:GetSize() <= 3
                integer counter = items:GetSize()
                text names = ""
                repeat while counter > 0
                    counter = counter - 1
                    names = names + items:Get(counter):GetName() + ", "
                end
                return names + position + ", press Enter to select items"
            else
                integer counter = items:GetSize()
                text names = ""
                repeat while counter > items:GetSize() - 3
                    counter = counter - 1
                    names = names + items:Get(counter):GetName() + ", "
                end
                return names + items:GetSize() + " items, " + position + ", press Enter to select items"
            end
        end

        return parent:Item:GetDescription()
    end


    /*
    This action is called automatically by the system. This resize adjusts the size of the
    viewports, camera, and grid.
    */
    action Resize
        parent:Control:Resize()

        integer counter = 0
        repeat while counter < layers:GetSize()
            EditorLayer layer = layers:Get(counter)
            layer:SetViewport(cast(integer, GetGlobalX()), cast(integer, GetGlobalY()), cast(integer, GetWidth()), cast(integer, GetHeight()))
            Camera camera = layer:GetCamera()
            camera:SetSize(GetWidth(), GetHeight())
            counter = counter + 1

            if layer is EditorLayer2D
                EditorLayer2D layer2D = cast(EditorLayer2D, layer)
                layer2D:UpdateGridSize()
            end
        end
    end


    /*
        This action takes every dialog added to this Scene Editor and hides all of them.
    */
    action HideDialogs
        integer counter = 0
        repeat while counter < propertiesDialogs:GetSize()
            propertiesDialogs:Get(counter):Hide()
            counter = counter + 1
        end
    end

    action GetEditorTag returns text
        return constants:EDITOR_TAG
    end

    action GetSceneConstants returns SceneConstants
        return constants
    end

    action SetProperties3DDialog(Item3DPropertiesDialog dialog)
        item3dPropertiesDialog = dialog
    end

    action GetProperties3DDialog returns Item3DPropertiesDialog
        return item3dPropertiesDialog
    end

    action SetProperties2DDialog(Item2DPropertiesDialog dialog)
        item2dPropertiesDialog = dialog
    end

    action SetCameraProperties2DDialog(Camera2DPropertiesDialog dialog)
        camera2dPropertiesDialog = dialog
    end

    action GetCameraProperties2DDialog returns Camera2DPropertiesDialog
        return camera2dPropertiesDialog
    end

    action SetCameraProperties3DDialog(Camera3DPropertiesDialog dialog)
        camera3dPropertiesDialog = dialog
    end

    action GetCameraProperties3DDialog returns Camera3DPropertiesDialog
        return camera3dPropertiesDialog
    end

    action GetProperties2DDialog returns Item2DPropertiesDialog
        return item2dPropertiesDialog
    end

    action GetPointLightPropertiesDialog returns PointLightPropertiesDialog
        return pointLightPropertiesDialog
    end

    action SetPointLightPropertiesDialog(PointLightPropertiesDialog pointLightPropertiesDialog)
        me:pointLightPropertiesDialog = pointLightPropertiesDialog
    end

    action FocusItemProperties
        integer counter = 0
        repeat while counter < propertiesDialogs:GetSize()
            PropertiesDialog dialog = propertiesDialogs:Get(counter)
            if dialog:IsShowing()
                dialog:FocusField()
                return now
            end
            counter = counter + 1
        end
    end

    action UpdateActivePropertiesDialog(EditorItem item)
        integer counter = 0
        repeat while counter < propertiesDialogs:GetSize()
            PropertiesDialog dialog = propertiesDialogs:Get(counter)
            if dialog:IsShowing()
                dialog:SetFields(item)
                return now
            end
            counter = counter + 1
        end
    end

    action UpdateEditorCameraTarget
        Item item = GetSelectedItem()
        EditorLayer layer = GetSelectedLayer()
        if item is Item2D or layer is EditorLayer2D
            // We currently only support this feature for 3D.
            return now
        end

        EditorLayer3D layer3D = cast(EditorLayer3D, layer)

        if item = undefined and IsFocused()
            item = layer3D:GetCursor()
        end
        
        layer3D:GetEditorCamera():SetTarget(cast(Item3D, item))
    end

    action UpdateEditorCameraPosition
        if GetSelectedLayer() is EditorLayer3D
            EditorLayer3D layer = cast(EditorLayer3D, GetSelectedLayer())
            layer:GetEditorCamera():UpdateCameraPosition()
        else
            // Do nothing -- we currently don't support this for 2D
        end
    end

    action GetFindDialog returns SceneEditorFindDialog
        return findDialog
    end

    action GetEditManager returns SceneEditorEditManager
        return editManager
    end

    action IsFocused returns boolean
        // Although we can get the focus directly from the manager, we request
        // it from the Game instead. This allows the Game to do any necessary
        // additional book-keeping.
        return parent:Item:IsFocused() or (dummyItem not= undefined and dummyItem:IsFocused())
    end

action Update(number seconds)
        if layers:IsEmpty() or GetSelectedLayer() = undefined
            return now
        end

        Camera camera = GetSelectedLayer():GetCamera()
        boolean moved = false
        boolean isCursor = false
        Item movedItem = undefined

        if GetSelectedLayer() is EditorLayer3D

            EditorLayer3D layer = cast(EditorLayer3D, GetSelectedLayer())

            if (yawDirection not= 0 or pitchDirection not= 0 or rollDirection not= 0)
                number yaw = layer:GetCameraYaw() + (yawDirection * CAMERA_ROTATIONAL_SPEED_3D * seconds)
                number pitch = layer:GetCameraPitch() + (pitchDirection * CAMERA_ROTATIONAL_SPEED_3D * seconds)
                if pitch > 90.0
                    pitch = 90.0
                elseif pitch < -90.0
                    pitch = -90.0
                end
                number roll = layer:GetCameraRoll() + (rollDirection * CAMERA_ROTATIONAL_SPEED_3D * seconds)
                
//                layer:SetCameraYawPitchRoll(yaw, pitch, roll)
            end
    
            if forwardDirection not= 0
                workVector3:Set(camera:GetDirection())
                workVector3:Scale(forwardDirection * CAMERA_DIRECTIONAL_SPEED_3D * seconds)
//                camera:Move(workVector3)
            end
    
            if strafeDirection not= 0
                workVector3:Set(camera:GetDirection())
                workVector3:CrossProduct(camera:GetUp())
//                camera:Move(workVector3:Scale(strafeDirection * CAMERA_DIRECTIONAL_SPEED_3D * seconds))
            end
    
            if verticalDirection not= 0
                workVector3:Set(camera:GetUp())
                workVector3:Scale(verticalDirection * CAMERA_DIRECTIONAL_SPEED_3D * seconds)
//                camera:Move(workVector3)
            end
    
            if IsFocused() or manager:GetFocus() is EditorItem3D
                moved = false
                workVector3:Set(0, 0, 0)

                EditorItem3D focus = undefined

                if IsFocused()
                    isCursor = true
                    focus = cast(EditorItem3D, cast(Object, layer:GetCursor()))
                else
                    focus = cast(EditorItem3D, manager:GetFocus())
                end
    
                boolean gridSnapEnabled = IsGridSnapping()
    
                if gridSnapEnabled = false
                    if selectionXDirection not= 0
                        workVector3:SetX(selectionXDirection * SELECTION_DIRECTIONAL_SPEED_3D * seconds)
                        moved = true
                    end
    
                    if selectionYDirection not= 0
                        workVector3:SetY(selectionYDirection * SELECTION_DIRECTIONAL_SPEED_3D * seconds)
                        moved = true
                    end
    
                    if selectionZDirection not= 0
                        workVector3:SetZ(selectionZDirection * -SELECTION_DIRECTIONAL_SPEED_3D * seconds)
                        moved = true
                    end
    
                    if moved
                        focus:Move(workVector3)
                    end
                else
                    if selectionXDirection not= 0 or selectionYDirection not= 0 or selectionZDirection not= 0
                        if gridMoveTimer <= 0
                            gridMoveTimer = gridMoveTimerMax

                            if focus is CameraItem3D
                                CameraItem3D cameraItem = cast(CameraItem3D, focus)
                                if selectionXDirection not= 0
                                    cameraItem:SetYaw(cameraItem:GetYaw() + selectionXDirection * CAMERA_ROTATIONAL_SPEED_3D)
                                end

                                if selectionYDirection not= 0
                                    cameraItem:SetPitch(cameraItem:GetPitch() + selectionYDirection * CAMERA_ROTATIONAL_SPEED_3D)
                                end

                                if selectionZDirection not= 0
                                    cameraItem:SetDistance(cameraItem:GetDistance() - selectionZDirection * CAMERA_DIRECTIONAL_SPEED_3D)
                                end
                            else
                                moved = true
                                number x = focus:GetGlobalX()
                                number y = focus:GetGlobalY()
                                number z = focus:GetGlobalZ()
        
                                if selectionXDirection < 0
                                    x = layer:GetPreviousGridCoordinate(x)
                                elseif selectionXDirection > 0
                                    x = layer:GetNextGridCoordinate(x)
                                end
        
                                if selectionYDirection < 0
                                    y = layer:GetPreviousGridCoordinate(y)
                                elseif selectionYDirection > 0
                                    y = layer:GetNextGridCoordinate(y)
                                end
        
                                if selectionZDirection < 0
                                    z = layer:GetPreviousGridCoordinate(z)
                                elseif selectionZDirection > 0
                                    z = layer:GetNextGridCoordinate(z)
                                end
        
                                focus:Move(x - focus:GetGlobalX(), y - focus:GetGlobalY(), z - focus:GetGlobalZ())
                                Grid3D grid = layer:GetGrid()
                                grid:SetPosition(grid:GetNearestGridCoordinate(focus:GetGlobalX()),
                                    0,
                                    grid:GetNearestGridCoordinate(focus:GetGlobalZ()))
                            end
                        else
                            gridMoveTimer = gridMoveTimer - seconds
                        end
                    else
                        gridMoveTimer = 0
                    end
                end

                if moved
                    movedItem = focus
                end

                if IsSelectionRotating()
                    workVector3:Set(focus:GetYaw(), focus:GetPitch(), focus:GetRoll())
                    workVector3:Add(seconds * selectionYawDirection * SELECTION_ROTATIONAL_SPEED_3D, seconds * selectionPitchDirection * SELECTION_ROTATIONAL_SPEED_3D, seconds * selectionRollDirection * SELECTION_ROTATIONAL_SPEED_3D)
                    focus:SetRotation(workVector3)
                end
            end

        elseif GetSelectedLayer() is EditorLayer2D
            EditorLayer2D layer = cast(EditorLayer2D, GetSelectedLayer())

            if (rollDirection not= 0)
                number roll = layer:GetCameraRoll() + (rollDirection * CAMERA_ROTATIONAL_SPEED_2D * seconds)
                layer:SetCameraRoll(roll)
            end
    
            if strafeDirection not= 0
                workVector3:Set(camera:GetDirection())
                workVector3:CrossProduct(camera:GetUp())
                camera:Move(workVector3:Scale(-strafeDirection * CAMERA_DIRECTIONAL_SPEED_2D * seconds))
                moved = true
            end
    
            if forwardDirection not= 0
                workVector3:Set(camera:GetUp())
                workVector3:Scale(forwardDirection * CAMERA_DIRECTIONAL_SPEED_2D * seconds)
                camera:Move(workVector3)
                moved = true
            end

            if moved
                layer:UpdateGridPosition()
            end
    
            if IsFocused() or manager:GetFocus() is EditorItem2D
                moved = false
                workVector2:Set(0, 0)

                Item2D target = undefined
                
                if IsFocused()
                    isCursor = true
                    target = cast(Item2D, cast(Object, layer:GetCursor()))
                else
                    target = cast(Item2D, manager:GetFocus())
                end
    
                boolean gridSnapEnabled = IsGridSnapping()
    
                if gridSnapEnabled = false
                    if selectionXDirection not= 0
                        workVector2:SetX(selectionXDirection * SELECTION_DIRECTIONAL_SPEED_2D * seconds)
                        moved = true
                    end
    
                    if selectionYDirection not= 0
                        workVector2:SetY(selectionYDirection * SELECTION_DIRECTIONAL_SPEED_2D * seconds)
                        moved = true
                    end
    
                    if moved
                        target:Move(workVector2)
                    end
                else
                    if selectionXDirection not= 0 or selectionYDirection not= 0
                        if gridMoveTimer <= 0
                            gridMoveTimer = gridMoveTimerMax
    
                            number x = target:GetGlobalX()
                            number y = target:GetGlobalY()
    
                            if selectionXDirection < 0
                                x = layer:GetPreviousGridCoordinate(x)
                            elseif selectionXDirection > 0
                                x = layer:GetNextGridCoordinate(x)
                            end
    
                            if selectionYDirection < 0
                                y = layer:GetPreviousGridCoordinate(y)
                            elseif selectionYDirection > 0
                                y = layer:GetNextGridCoordinate(y)
                            end
    
                            target:Move(x - target:GetGlobalX(), y - target:GetGlobalY())
                            moved = true
                        else
                            gridMoveTimer = gridMoveTimer - seconds
                        end
                    else
                        gridMoveTimer = 0
                    end
                end

                if moved
                    movedItem = target
                end

                if GetSelectionRollDirection() not= 0 and isCursor = false
                    number angle = target:GetRotation()
                    angle = angle + (seconds * selectionRollDirection * SELECTION_ROTATIONAL_SPEED_2D)
                    target:SetRotation(angle)
                end
            end
        end

        if moved
            if movedItem not= undefined and movedItem is EditorItem
                UpdateActivePropertiesDialog(cast(EditorItem, movedItem))
                UpdateEditorCameraPosition()
            end

            if isCursor
                if accessibility not= undefined
                    Item2D newDummy
                    text describe = GetDescription()
                    newDummy:SetProperty(constants:EDITOR_TAG, undefined)
                    newDummy:SetFocusable(true)
                    newDummy:SetAccessibilityCode(dummyItem:parent:Item:ITEM)
                    newDummy:SetName(describe)
                    newDummy:SetInputGroup("PassthroughInput")
    
                    Add(newDummy)
                    if dummyItem not= undefined
                        Remove(dummyItem)
                    end
                    dummyItem = newDummy
                    newDummy:Focus()
                end
            end
        end
    end

    action SetFilteredItems(Array<Item> items, boolean moveFocus)
        filteredItems = items

        // Remove previous highlights.
        repeat while filterHighlights:IsEmpty() = false
            SelectionHighlight highlight = filterHighlights:RemoveFromEnd()
            if highlight is SelectionHighlight3D
                SelectionHighlight3D highlight3D = cast(SelectionHighlight3D, highlight)
                highlight3D:GetLayer():Remove(highlight3D)
            elseif highlight is SelectionHighlight2D
                SelectionHighlight2D highlight2D = cast(SelectionHighlight2D, highlight)
                highlight2D:GetLayer():Remove(highlight2D)
            end
        end

        // Display selection highlighting around the items.
        
        EditorLayer currentLayer = GetSelectedLayer()

        if currentLayer is EditorLayer3D
            EditorLayer3D layer = cast(EditorLayer3D, currentLayer)
            integer counter = 0
            repeat while counter < filteredItems:GetSize()
                Item3D item = cast(Item3D, filteredItems:Get(counter))
                SelectionHighlight3D highlight = undefined
                if item is EditorPointLight
                    PointLightSelectionHighlight light
                    highlight = light
                elseif item is EditorAudio3D
                    Audio3DSelectionHighlight light
                    highlight = light
                else
                    ModelSelectionHighlight model
                    highlight = model
                end
                highlight:Load(cast(EditorModel, item), me)
                filterHighlights:Add(highlight)
                layer:Add(highlight)
    
                counter = counter + 1
            end
        else
            EditorLayer2D layer = cast(EditorLayer2D, currentLayer)
            integer counter = 0
            repeat while counter < filteredItems:GetSize()
                Item2D item = cast(Item2D, filteredItems:Get(counter))
                SelectionHighlight2D highlight
                highlight:Load(item, me)
                filterHighlights:Add(highlight)
                layer:Add(highlight)
    
                counter = counter + 1
            end
        end

        SetFilterHighlightData()

        if moveFocus
            if filterHighlights:IsEmpty()
                Focus()
            else
                filterHighlights:Get(0):Focus()
            end
        else
            if filterHighlights:IsEmpty()
                SetSelectedItem(undefined)
            else
                SetSelectedItem(filterHighlights:Get(0))
            end
        end
    end

    private action EmptyFilteredItems(boolean moveFocus)
        filteredItems = undefined

        // Remove previous highlights.
        repeat while filterHighlights:IsEmpty() = false
            SelectionHighlight highlight = filterHighlights:RemoveFromEnd()
            if highlight is SelectionHighlight3D
                SelectionHighlight3D highlight3D = cast(SelectionHighlight3D, highlight)
                highlight3D:GetLayer():Remove(highlight3D)
            else
                SelectionHighlight2D highlight2D = cast(SelectionHighlight2D, highlight)
                highlight2D:GetLayer():Remove(highlight2D)
            end
        end

        SetFilterHighlightData()

        if moveFocus
            Focus()
        else
            SetSelectedItem(undefined)
        end
    end

    private action SetFilterHighlightData
        integer counter = 0
        repeat while counter < filterHighlights:GetSize()
            SelectionHighlight highlight = filterHighlights:Get(counter)
            Item item = highlight:GetItem()

            if counter = 0
                highlight:SetPreviousFocus(filterHighlights:GetFromEnd())
            else
                highlight:SetPreviousFocus(filterHighlights:Get(counter - 1))
            end

            if counter = filterHighlights:GetSize() - 1
                highlight:SetNextFocus(filterHighlights:GetFromFront())
            else
                highlight:SetNextFocus(filterHighlights:Get(counter + 1))
            end 

            number x = math:Round(item:GetGlobalX(), 2)
            number y = math:Round(item:GetGlobalY(), 2)
            number z = math:Round(item:GetGlobalZ(), 2)

            highlight:SetName(item:GetName())
            highlight:SetDescription((counter + 1) + " of " + filterHighlights:GetSize() + ": " + x + ", " + y + ", " + z)
            counter = counter + 1
        end

        if filterHighlights:IsEmpty() = false
            SetPreviousFocus(filterHighlights:Get(filterHighlights:GetSize() - 1))
            SetNextFocus(filterHighlights:Get(0))
        else
            SetPreviousFocus(undefined)
            SetNextFocus(undefined)
        end
    end

    // Removes the item that is selected by the given highlight, along with the highlight itself.
    action Delete(SelectionHighlight highlight)
        Item nextFocus = undefined

        if highlight:IsFocused()
            // If we're deleting the focused item, move the focus.
            if highlight:GetPreviousFocus() not= undefined and (highlight:GetPreviousFocus():Equals(highlight) = false)
                nextFocus = highlight:GetPreviousFocus()
            else
                SetCursorToItem(highlight)
                nextFocus = me
            end
        end

        EditorLayer resultLayer = undefined

        if highlight is SelectionHighlight3D
            SelectionHighlight3D highlight3D = cast(SelectionHighlight3D, highlight)
            EditorLayer3D layer = cast(EditorLayer3D, highlight3D:GetLayer())
            resultLayer = layer
            layer:Remove(highlight3D)
            layer:Remove(cast(Item3D, highlight3D:GetItem()))
        else
            SelectionHighlight2D highlight2D = cast(SelectionHighlight2D, highlight)
            EditorLayer2D layer = cast(EditorLayer2D, highlight2D:GetLayer())
            resultLayer = layer
            layer:Remove(highlight2D)
            layer:Remove(cast(Item2D, highlight2D:GetItem()))
        end

        integer index = filterHighlights:GetFirstLocation(highlight)
        if index >= 0
            filterHighlights:RemoveAt(index)

            // Refresh filter highlight focus order and descriptions.
            SetFilterHighlightData()
        end

        if nextFocus not= undefined
            nextFocus:Focus()
        end

        SceneEditorDeleteEdit edit
        edit:Create(me, resultLayer, highlight:GetItem())
        editManager:Add(edit)

        SceneEditorChangeEvent event
        event:Set(me, highlight:GetItem(), undefined, resultLayer, event:REMOVED)
        NotifySceneEditorChangeListeners(event)
    end

    /*
    This action will delete an item that has been added to the scene.
    */
    action Delete(Item item)
        EditorLayer resultLayer = undefined

        if item is Item2D
            Item2D item2D = cast(Item2D, item)
            EditorLayer2D layer = cast(EditorLayer2D, item2D:GetLayer())
            resultLayer = layer
            if layer = undefined
                return now
            end
            layer:Remove(item2D)
        elseif item is Item3D
            Item3D item3D = cast(Item3D, item)
            EditorLayer3D layer = cast(EditorLayer3D, item3D:GetLayer())
            resultLayer = layer
            if layer = undefined
                return now
            end
            layer:Remove(item3D)
        end

        integer index = 0
        repeat while index < filterHighlights:GetSize()
            SelectionHighlight highlight = filterHighlights:Get(index)
            if highlight:GetItem() = item
                filterHighlights:RemoveAt(index)
                if resultLayer is EditorLayer2D
                    EditorLayer2D layer = cast(EditorLayer2D, resultLayer)
                    layer:Remove(cast(SelectionHighlight2D, highlight))
                elseif resultLayer is EditorLayer3D
                    EditorLayer3D layer = cast(EditorLayer3D, resultLayer)
                    layer:Remove(cast(SelectionHighlight3D, highlight))
                end

                // Manually set the index so we'll escape the loop early.
                index = filterHighlights:GetSize()

                // Refresh filter highlight focus order and descriptions.
                SetFilterHighlightData()
            end

            index = index + 1
        end

        SceneEditorDeleteEdit edit
        edit:Create(me, resultLayer, item)
        editManager:Add(edit)

        SceneEditorChangeEvent event
        event:Set(me, item, undefined, resultLayer, event:REMOVED)
        NotifySceneEditorChangeListeners(event)
    end

    action CreateItemPreview(ItemBlueprint schematic)
        CreateItemPreview(schematic, undefined)
    end

    action CreateItemPreview(ItemBlueprint schematic, File asset)
        if schematic is DrawableBlueprint
            DrawableBlueprint drawableBlueprint = cast(DrawableBlueprint, schematic)
            if not (GetSelectedLayer() is EditorLayer2D)
                integer counter = 0
                boolean found = false
                repeat while counter < layers:GetSize()
                    EditorLayer layer = layers:Get(counter)
                    if layer is EditorLayer2D
                        SetSelectedLayer(layer)
                        counter = layers:GetSize()
                        found = true
                    end
                    counter = counter + 1
                end

                if not found
                    return now
                end
            end

            EditorLayer2D layer = cast(EditorLayer2D, GetSelectedLayer())

            if drawableBlueprint:GetPreferredGridWidth() not= 0 and drawableBlueprint:GetPreferredGridHeight() not= 0
                // TO-DO: Consider both width and height when setting grid unit size.
                layer:SetGridUnitSize(drawableBlueprint:GetPreferredGridWidth())
                layer:UpdateGridPosition()
            end

            ItemPreview2D preview
            preview:Load(me, drawableBlueprint)
            // TO-DO: Position preview to match cursor

            layer:Add(preview)
            preview:Focus()
        elseif schematic is ModelBlueprint or schematic is PointLightBlueprint or schematic is Audio3DBlueprint
            
            if not (GetSelectedLayer() is EditorLayer3D)
                integer counter = 0
                boolean found = false
                repeat while counter < layers:GetSize()
                    EditorLayer layer = layers:Get(counter)
                    if layer is EditorLayer3D
                        SetSelectedLayer(layer)
                        counter = layers:GetSize()
                        found = true
                    end
                    counter = counter + 1
                end

                if not found
                    return now
                end
            end

            EditorLayer3D layer = cast(EditorLayer3D, GetSelectedLayer())

            // TO-DO: Consider modifying grid size for 3D objects here, same as with 2D objects above.

            ItemPreview3D preview = undefined
            if asset = undefined
                if schematic is ModelBlueprint
                    ModelPreview modelPreview
                    preview = modelPreview
                    ModelBlueprint modelBlueprint = cast(ModelBlueprint, schematic)
                    modelPreview:Load(me, modelBlueprint)
                elseif schematic is PointLightBlueprint
                    PointLightPreview lightPreview
                    preview = lightPreview
                    PointLightBlueprint lightBlueprint = cast(PointLightBlueprint, schematic)
                    lightPreview:Load(me, lightBlueprint)
                else
                    Audio3DPreview audioPreview
                    preview = audioPreview
                    Audio3DBlueprint audioBlueprint = cast(Audio3DBlueprint, schematic)
                    audioPreview:Load(me, audioBlueprint)
                end
            else
                if schematic is Custom3DPrimitiveBlueprint
                    Custom3DPrimitivePreview primitivePreview
                    preview = primitivePreview
                    Custom3DPrimitiveBlueprint primitiveBlueprint = cast(Custom3DPrimitiveBlueprint, schematic)
                    primitivePreview:Load(me, primitiveBlueprint, asset)
                elseif schematic is CustomModelBlueprint
                    CustomModelBlueprint newBlueprint = cast(CustomModelBlueprint, schematic)
                    newBlueprint:SetFile(asset)
                    ModelPreview modelPreview
                    preview = modelPreview
                    modelPreview:Load(me, newBlueprint)
                end
            end

            layer:Add(preview)
            preview:Focus()
        end
    end

    action CancelItemPreview(ItemPreview preview)
        if preview is ItemPreview3D
            ItemPreview3D preview3D = cast(ItemPreview3D, preview)
            EditorLayer3D layer = cast(EditorLayer3D, GetSelectedLayer())
            layer:Remove(preview3D)
        else
            ItemPreview2D preview2D = cast(ItemPreview2D, preview)
            EditorLayer2D layer = cast(EditorLayer2D, GetSelectedLayer())
            layer:Remove(preview2D)
        end
    end

    action SelectEditorCamera(EditorLayer layer)
        if layer is EditorLayer2D
            EditorLayer2D layer2D = cast(EditorLayer2D, layer)
            CameraItem2D item
            item:Load(layer:GetCamera(), me)
            layer2D:Add(item)
            SetSelection(layer2D, item)

            item:Focus()
        elseif layer is EditorLayer3D
            EditorLayer3D layer3D = cast(EditorLayer3D, layer)
            CameraItem3D item
            item:Load(layer3D:GetEditorCamera(), me)
            layer3D:Add(item)
            SetSelection(layer3D, item)

            item:Focus()
        end
    end

    action DeselectEditorCamera
        // Was already empty
    end

    Matrix4 previewTransform = undefined
    action GetPreviewTransform returns Matrix4
        return previewTransform
    end

    action SetPreviewTransform(Matrix4 transform)
        previewTransform = transform
    end

    action GetDefaultItemName(integer type) returns text
        if type = 0
            return "Box"
        elseif type = 1
            return "Sphere"
        elseif type = 2
            return "Cylinder"
        end

        return "Item"
    end

    action ConfirmItemPreview(ItemPreview newItem)
        Item result = undefined
        EditorLayer resultLayer = undefined

        if newItem:GetItemBlueprint() not= undefined
            IncrementNameCount(newItem:GetItemBlueprint():GetName())
        end

        if newItem is ItemPreview3D
            ItemPreview3D preview = cast(ItemPreview3D, newItem)
            Model model = preview:ConvertToModel()
            result = model

            previewTransform = preview:GetTransform()
            EditorLayer3D layer = cast(EditorLayer3D, GetSelectedLayer())
            resultLayer = layer
            layer:Add(model)
        elseif newItem is ItemPreview2D
            ItemPreview2D preview = cast(ItemPreview2D, newItem)
            Drawable drawable = preview:ConvertToDrawable()
            result = drawable

            EditorLayer2D layer = cast(EditorLayer2D, GetSelectedLayer())
            resultLayer = layer
            layer:Add(drawable)
        end

        // This Dispose call currently does nothing, but if there are any
        // resources that need to be cleaned up, it should be done here.
        //preview:Dispose()
        //Focus()

        NotifyAccessibility(newItem, "Placed " + result:GetName())
        
        SceneEditorChangeEvent event
        event:Set(me, result, undefined, resultLayer, event:ADDED)
        NotifySceneEditorChangeListeners(event)

        if newItem:GetItemBlueprint() not= undefined
            text name = newItem:GetItemBlueprint():GetName()
            newItem:SetName(name + GetNextNamePostfix(name))
            if newItem is ModelPreview
                //item3dPropertiesDialog:SetFields(newItem)
            elseif newItem is PointLightPreview
                //pointLightPropertiesDialog:SetFields(newItem)
            elseif newItem is Audio3DPreview
                //audio3DPropertiesDialog:SetFields(newItem)
            elseif newItem is ItemPreview2D
                //item2dPropertiesDialog:SetFields(newItem)
            end
        end

        SceneEditorInsertEdit edit
        edit:Create(me, resultLayer, result)
        editManager:Add(edit)
    end

    action Add(EditorLayer layer, Item item)
        if layer is EditorLayer2D and item is Item2D
            EditorLayer2D layer2D = cast(EditorLayer2D, layer)
            Item2D item2D = cast(Item2D, item)
            layer2D:Add(item2D)
        elseif layer is EditorLayer3D and item is Item3D
            EditorLayer3D layer3D = cast(EditorLayer3D, layer)
            Item3D item3D = cast(Item3D, item)
            layer3D:Add(item3D)    
        else
            alert("I couldn't add the item " + item:GetName() + " because it's incompatible with the requested layer.")
        end

        // It's not clear if we should notify accessibility here, or allow a change in selection to handle that for us.
        //NotifyAccessibility(newItem, "Placed " + result:GetName())
        
        SceneEditorChangeEvent event
        event:Set(me, item, undefined, layer, event:ADDED)
        NotifySceneEditorChangeListeners(event)

        SceneEditorInsertEdit edit
        edit:Create(me, layer, item)
        editManager:Add(edit)
    end

    action AddLayer(EditorLayer layer)
        selection:SetSelection(layer)
        layer:SetSceneEditor(me)
        layers:Add(layer)
    end

    action SetYawDirection(integer direction)
        yawDirection = direction

        if direction = 0
            NotifyAccessibility(me, "Yaw " + math:Round(GetSelectedLayer():GetCameraYaw(), 1))
        end
    end

    action GetYawDirection returns integer
        return yawDirection
    end

    action SetPitchDirection(integer direction)
        pitchDirection = direction

        if direction = 0
            NotifyAccessibility(me, "Pitch " + math:Round(GetSelectedLayer():GetCameraPitch(), 1))
        end
    end

    action GetPitchDirection returns integer
        return pitchDirection
    end

    action SetRollDirection(integer direction)
        rollDirection = direction

        if direction = 0
            NotifyAccessibility(me, "Roll " + math:Round(GetSelectedLayer():GetCameraRoll(), 1))
        end
    end

    action GetRollDirection returns integer
        return rollDirection
    end

    action IsCameraRotating returns boolean
        return GetYawDirection() not= 0 or GetPitchDirection() not= 0
    end

    action GetYaw returns number
        return GetSelectedLayer():GetCameraYaw()
    end

    action GetPitch returns number
        return GetSelectedLayer():GetCameraPitch()
    end

    action GetRoll returns number
        return GetSelectedLayer():GetCameraRoll()
    end

    action SetForwardDirection(integer direction)
        forwardDirection = direction

        if IsCameraMoving() = false
            if GetSelectedLayer() is EditorLayer2D
                Vector3 temp = GetSelectedLayer():GetCamera():GetPosition()
                number x = math:Round(temp:GetX(), 1)
                number y = math:Round(temp:GetY(), 1)
                NotifyAccessibility(me, "Camera " + x + ", " + y)
            else
                Vector3 temp = GetSelectedLayer():GetCamera():GetPosition()
                number x = math:Round(temp:GetX(), 2)
                number y = math:Round(temp:GetY(), 2)
                number z = math:Round(temp:GetZ(), 2)
                NotifyAccessibility(me, "Camera " + x + ", " + y + ", " + z)
            end
        end
    end

    action GetForwardDirection returns integer
        return forwardDirection
    end
    action SetStrafeDirection(integer direction)
        strafeDirection = direction

        if IsCameraMoving() = false
            if GetSelectedLayer() is EditorLayer2D
                Vector3 temp = GetSelectedLayer():GetCamera():GetPosition()
                number x = math:Round(temp:GetX(), 1)
                number y = math:Round(temp:GetY(), 1)
                NotifyAccessibility(me, "Camera " + x + ", " + y)
            else
                Vector3 temp = GetSelectedLayer():GetCamera():GetPosition()
                number x = math:Round(temp:GetX(), 2)
                number y = math:Round(temp:GetY(), 2)
                number z = math:Round(temp:GetZ(), 2)
                NotifyAccessibility(me, "Camera " + x + ", " + y + ", " + z)
            end
        end
    end

    action GetStrafeDirection returns integer
        return strafeDirection
    end

    action SetVerticalDirection(integer direction)
        verticalDirection = direction

        if IsCameraMoving() = false
            if GetSelectedLayer() is EditorLayer2D
                Vector3 temp = GetSelectedLayer():GetCamera():GetPosition()
                number x = math:Round(temp:GetX(), 1)
                number y = math:Round(temp:GetY(), 1)
                NotifyAccessibility(me, "Camera " + x + ", " + y)
            else
                Vector3 temp = GetSelectedLayer():GetCamera():GetPosition()
                number x = math:Round(temp:GetX(), 2)
                number y = math:Round(temp:GetY(), 2)
                number z = math:Round(temp:GetZ(), 2)
                NotifyAccessibility(me, "Camera " + x + ", " + y + ", " + z)
            end
        end
    end

    action GetVerticalDirection returns integer
        return verticalDirection
    end

    action IsCameraMoving returns boolean
        return GetForwardDirection() not= 0 or GetStrafeDirection() not= 0 or GetVerticalDirection() not= 0
    end

    action SetCursorToItem(EditorItem item)
        // We don't want the cursor to jump to the camera item, so abort now.
        if item is CameraItem
            return now
        end

        if item is EditorItem2D
            EditorCursor2D cursor = cast(EditorCursor2D, GetCursor())
            number x = item:GetGlobalX()
            number y = item:GetGlobalY()
            if not IsGridCoordinate(x)
                x = GetSelectedLayer():GetPreviousGridCoordinate(x)
            end
            if not IsGridCoordinate(y)
                y = GetSelectedLayer():GetPreviousGridCoordinate(y)
            end
            cursor:SetPosition(x, y)
        elseif item is EditorItem3D
            EditorCursor3D cursor = cast(EditorCursor3D, GetCursor())
            number x = item:GetGlobalX()
            number y = item:GetGlobalY()
            number z = item:GetGlobalZ()
            cursor:SetPosition(x, y, z)
        end
    end

    // Used when moving an InteractableItem into a grid space to give information about what's under the item.
    // Doesn't include the item itself in the description.
    private action GetDescriptionAtItemPosition(EditorItem item) returns text
        SetCursorToItem(item)

        Item ignoredItem = undefined

        if item is SelectionHighlight
            SelectionHighlight highlight = cast(SelectionHighlight, item)
            ignoredItem = highlight:GetItem()
        end

        EditorCursor cursor = GetCursor()
        if cursor is EditorCursor2D
            EditorCursor2D cursor2D = cast(EditorCursor2D, cursor)
            text position = cast(integer, item:GetGlobalX()) + " " + cast(integer, item:GetGlobalY())
            Array<Item> items = cursor2D:GetItemsAtCursor()
            if items:GetSize() = 0
                return position
            elseif items:GetSize() <= 3
                integer counter = items:GetSize()
                text names = ""
                repeat while counter > 0
                    counter = counter - 1
                    if ignoredItem = undefined or items:Get(counter):Equals(ignoredItem) = false
                        names = names + items:Get(counter):GetName() + ", "
                    end
                end
                return names + position
            else
                integer counter = items:GetSize()
                integer used = 0
                text names = ""
                repeat while used < 3
                    counter = counter - 1
                    if ignoredItem = undefined or items:Get(counter):Equals(ignoredItem) = false
                        names = names + items:Get(counter):GetName() + ", "
                        used = used + 1
                    end
                end
                return names + (items:GetSize() - 1) + " items, " + position
            end
        else
            EditorCursor3D cursor3D = cast(EditorCursor3D, cursor)
            text position = ""
            if cursor:GetGlobalX() = cast(integer, cursor:GetGlobalX())
                position = position + cast(integer, cursor:GetGlobalX())
            else
                position = position + cursor:GetGlobalX()
            end

            position = position + " "

            if cursor:GetGlobalY() = cast(integer, cursor:GetGlobalY())
                position = position + cast(integer, cursor:GetGlobalY())
            else
                position = position + cursor:GetGlobalY()
            end

            position = position + " "

            if cursor:GetGlobalZ() = cast(integer, cursor:GetGlobalZ())
                position = position + cast(integer, cursor:GetGlobalZ())
            else
                position = position + cursor:GetGlobalZ()
            end

            Array<Item> items = cursor3D:GetItemsAtCursor()
            if items:GetSize() = 0
                return position
            elseif items:GetSize() <= 3
                integer counter = items:GetSize()
                text names = ""
                repeat while counter > 0
                    counter = counter - 1
                    if ignoredItem = undefined or items:Get(counter):Equals(ignoredItem) = false
                        names = names + items:Get(counter):GetName() + ", "
                    end
                end
                return names + position
            else
                integer counter = items:GetSize()
                integer used = 0
                text names = ""
                repeat while used < 3
                    counter = counter - 1
                    if ignoredItem = undefined or items:Get(counter):Equals(ignoredItem) = false
                        names = names + items:Get(counter):GetName() + ", "
                        used = used + 1
                    end
                end
                return names + (items:GetSize() - 1) + " items, " + position
            end
        end
        return item:GetGlobalX() + " " + item:GetGlobalY()
    end

    action SetSelectionXDirection(integer direction)
        selectionXDirection = direction

        if direction = 0
            if manager:GetFocus() is EditorItem
                EditorItem focus = cast(EditorItem, manager:GetFocus())
                NotifyAccessibility(focus, GetDescriptionAtItemPosition(focus))
            end
        end
    end

    action GetSelectionXDirection returns integer
        return selectionXDirection
    end

    action SetSelectionYDirection(integer direction)
        selectionYDirection = direction

        if direction = 0
            if manager:GetFocus() is EditorItem
                EditorItem focus = cast(EditorItem, manager:GetFocus())
                NotifyAccessibility(focus, GetDescriptionAtItemPosition(focus))
            end
        end
    end

    action GetSelectionYDirection returns integer
        return selectionYDirection
    end

    action SetSelectionZDirection(integer direction)
        selectionZDirection = direction

        if direction = 0
            if manager:GetFocus() is EditorItem
                EditorItem focus = cast(EditorItem, manager:GetFocus())
                NotifyAccessibility(focus, GetDescriptionAtItemPosition(focus))
            end
        end
    end

    action GetSelectionZDirection returns integer
        return selectionZDirection
    end

    action IsSelectionMoving returns boolean
        return GetSelectionXDirection() not= 0 or GetSelectionYDirection() not= 0 or GetSelectionZDirection() not= 0
    end

    action SetSelectionYawDirection(integer direction)
        selectionYawDirection = direction

        if direction = 0
            if manager:GetFocus() is EditorItem3D
                EditorItem3D focus = cast(EditorItem3D, manager:GetFocus())
                number yaw = math:Round(focus:GetYaw(), 1)
                NotifyAccessibility(focus, "yaw " + yaw)
            end
        end
    end

    action GetSelectionYawDirection returns integer
        return selectionYawDirection
    end

    action SetSelectionPitchDirection(integer direction)
        selectionPitchDirection = direction

        if direction = 0
            if manager:GetFocus() is EditorItem3D
                EditorItem3D focus = cast(EditorItem3D, manager:GetFocus())
                number pitch = math:Round(focus:GetPitch(), 1)
                NotifyAccessibility(focus, "pitch " + pitch)
            end
        end
    end

    action GetSelectionPitchDirection returns integer
        return selectionPitchDirection
    end

    action SetSelectionRollDirection(integer direction)
        selectionRollDirection = direction

        if direction = 0
            if manager:GetFocus() is EditorItem3D
                EditorItem3D focus = cast(EditorItem3D, manager:GetFocus())
                number roll = math:Round(focus:GetRoll(), 1)
                NotifyAccessibility(focus, "roll " + roll)
            elseif manager:GetFocus() is EditorItem2D
                EditorItem2D focus = cast(EditorItem2D, manager:GetFocus())
                number rotation = math:Round(focus:GetRotation(), 1)
                NotifyAccessibility(focus, rotation + " degrees")
            end
        end
    end

    action GetSelectionRollDirection returns integer
        return selectionRollDirection
    end

    action IsSelectionRotating returns boolean
        return GetSelectionYawDirection() not= 0 or GetSelectionPitchDirection() not= 0 or GetSelectionRollDirection() not= 0
    end

    action NotifyAccessibility(Item item, text message)
        if accessibility not= undefined
            accessibility:Notify(item, message)
        end
    end

    action SetGridSnapping(boolean enabled)
        EditorLayer layer = GetSelectedLayer()

        if layer:IsGridSnapping() = enabled
            return now
        end

        layer:SetGridSnapping(enabled)

        if enabled
            NotifyAccessibility(me, "Grid snapping enabled")
        else
            NotifyAccessibility(me, "Grid snapping disabled")
        end
    end

    action SetGridUnitSize(number units)
        EditorLayer layer = GetSelectedLayer()
        layer:SetGridUnitSize(units)
        
        NotifyAccessibility(me, "Grid size " + units)
    end

    action GetGridUnitSize returns number
        EditorLayer layer = GetSelectedLayer()
        return layer:GetGridUnitSize()
    end

    action IsGridSnapping returns boolean
        EditorLayer layer = GetSelectedLayer()
        return layer:IsGridSnapping()
    end

    private action IsGridCoordinate(number value) returns boolean
        return GetSelectedLayer():IsGridCoordinate(value)
    end

    action SetSelectedItem(EditorItem item)
        selection:SetSelection(item)
    end

    action SetSelectedLayer(EditorLayer layer)
        if layer = selection:GetSelectedLayer()
            return now
        end

        EmptyFilteredItems(false)

        selection:SetSelection(layer, undefined)
    end

    action SetSelection(EditorLayer layer, EditorItem item)
        if layer = selection:GetSelectedLayer() and item = selection:GetSelectedItem()
            return now
        end

        EmptyFilteredItems(false)
        selection:SetSelection(layer, item)
    end

    action GetSelectedItem returns EditorItem
        return selection:GetSelectedItem()
    end

    action GetSelectedLayer returns EditorLayer
        return selection:GetSelectedLayer()
    end

    action GetCursor returns EditorCursor
        EditorLayer layer = GetSelectedLayer()
        if layer = undefined
            return undefined
        end

        return layer:GetCursor()
    end

    action GetSceneLayers returns Array<EditorLayer>
        return layers
    end

    action GainedFocus(FocusEvent event)
        SetSelectedItem(undefined)
        UpdateCursorVisibility()

        if accessibility not= undefined
            // Update the description for the controller in accessibility.
            accessibility:DescriptionChanged(me)
        end
    end

    action LostFocus(FocusEvent event)
        Item item = event:GetNewFocus()
        integer value = dummyItem:GetHashCode()
        boolean goingToDummy = false
        if item not= undefined
            integer value1 = item:GetHashCode()
            goingToDummy = (value1 = value)
        end
        EditorLayer layer = GetSelectedLayer()
        if layer not= undefined and not goingToDummy
            layer:ShowCursor(false)
        end
    end

    /*
    If the given Item has a corresponding SelectionHighlight, this action
    will return the highlight. Otherwise, it will return undefined.
    */
    action GetSelectionHighlight(Item item) returns SelectionHighlight
        integer i = 0
        repeat while i < filterHighlights:GetSize()
            SelectionHighlight highlight = filterHighlights:Get(i)
            if highlight:GetItem() = item
                return highlight
            end
            i = i + 1
        end

        return undefined
    end

    /*
    This action sets the cursor to either be visible or hidden, as is appropriate
    based on the current editor context. For example, if a layer is active and no
    items are selected, it will show the cursor, or hide it if there are already
    selected items.

    This is called automatically by the SceneEditorSelection when the selection
    changes.
    */
    action UpdateCursorVisibility
        EditorLayer layer = selection:GetSelectedLayer()
        if layer = undefined
            return now
        end

        // If an item is selected, hide the cursor. Otherwise, show it.
        layer:ShowCursor(selection:GetSelectedItem() = undefined)
    end

    action GetNameCount(text name) returns integer
        if nameCounts:HasKey(name)
            return nameCounts:GetValue(name)
        end
        return 0
    end

    action IncrementNameCount(text name)
        nameCounts:Set(name, GetNameCount(name) + 1)
    end

    action GetNextNamePostfix(text name) returns text
        integer count = GetNameCount(name)
        if count = 0
            return ""
        end

        return " " + count
    end


    action AddSceneEditorChangeListener(SceneEditorChangeListener listener)
        sceneEditorChangeListeners:Add(listener)
    end

    action RemoveSceneEditorChangeListener(SceneEditorChangeListener listener)
        sceneEditorChangeListeners:Remove(listener)
    end

    private action NotifySceneEditorChangeListeners(SceneEditorChangeEvent event)
        integer i = 0
        repeat while i < sceneEditorChangeListeners:GetSize()
            if event:GetEventType() = event:ADDED
                sceneEditorChangeListeners:Get(i):SceneAddedItem(event)
            else
                sceneEditorChangeListeners:Get(i):SceneRemovedItem(event)
            end
            i = i + 1
        end
    end

/* 
    Overrides the action in DefaultSceneManager. Used to determine which layers
    should be used to match the layers described in the Scene.

    We always make new layers which are stored as part of the VisualSceneController.
    */
    private action SelectLayer(JavaScriptObjectNotation layerJson) returns Layer

        text name = layerJson:GetValue(properties:NAME)
        text classValue = layerJson:GetValue(properties:CLASS)
        EditorLayer current = undefined

        if classValue = "Layer3D"
            EditorLayer3D layer
            current = layer
        elseif classValue = "Layer2D"
            EditorLayer2D layer
            current = layer
        end

        current:SetName(name)
        AddLayer(current)

        return current
    end

    /*
    This action can be used to override a portion of the default camera loading.
    */
    private action CustomLoadCameraProperty(Layer layer, Camera camera, text key, JavaScriptObjectNotation json) returns boolean
        if layer is EditorLayer2D
            EditorLayer2D layer2D = cast(EditorLayer2D, layer)
            if key = properties:SIZE        
                Number32BitArray size = ConvertToNumber32BitArray(json:GetObject(key))
                layer2D:SetCameraPreviewSize(size:Get(0), size:Get(1))
                return true
            elseif key = "EDITOR_" + properties:POSITION
                Number32BitArray position = ConvertToNumber32BitArray(json:GetObject(key))
                camera:SetPosition(position:Get(0), position:Get(1), camera:GetPosition():GetZ())
                return true
            elseif key = "EDITOR_" + properties:ZOOM
                camera:SetZoom(json:GetNumber(key))
                return true
            end
        end

        return false
    end

    private action CustomSaveCameraProperty(Layer layer, Camera camera, text key, JavaScriptObjectNotation json) returns boolean
        if layer is EditorLayer2D
            EditorLayer2D layer2D = cast(EditorLayer2D, layer)
            if key = properties:SIZE
                json:Add(properties:SIZE, NewJsonArray(layer2D:GetCameraPreviewWidth(), layer2D:GetCameraPreviewHeight()))
                return true
            elseif key = properties:POSITION
                CameraPreview2D preview = layer2D:GetCameraPreview()
                number x = preview:GetX() + preview:GetWidth() / 2.0
                number y = preview:GetY() + preview:GetHeight() / 2.0
                json:Add(properties:POSITION, NewJsonArray(x, y, camera:GetPosition():GetZ()))

                json:Add("EDITOR_" + properties:POSITION, NewJsonArray(camera:GetPosition():GetX(), camera:GetPosition():GetY()))

                return true
            elseif key = properties:ZOOM
                json:Add(properties:ZOOM, 1.0)

                json:Add("EDITOR_" + properties:ZOOM, camera:GetZoom())

                return true
            end
        end

        return false
    end

    action Save
        Array<EditorLayer> layers = GetSceneLayers()
        Scene scene = Save(layers)
        scene:GetData():SetPrettyPrint(true)
        file:Write(scene:GetData():ToText())
    end

    // We override the particular save item calls to ignore items with the editor tag.
    private action SaveItem3D(Item3D item) returns JavaScriptObjectNotation
        SceneConstants constants

        if item:HasProperty(constants:EDITOR_TAG)
            return undefined
        elseif item is EditorAudio3D
            JavaScriptObjectNotation json

            json:Add(properties:CLASS, "Audio3D")

            json:Add(properties:NAME, item:GetName())
            json:Add(properties:DESCRIPTION, item:GetDescription())
            json:Add(properties:POSITION, NewJsonArray(item:GetX(), item:GetY(), item:GetZ()))
            json:Add(properties:SIZE, NewJsonArray(item:GetWidth(), item:GetHeight(), item:GetDepth()))
    
            EditorAudio3D audio = cast(EditorAudio3D, item)
            json:Add(properties:FILE, audio:GetSource())
            json:Add(properties:VOLUME, audio:GetVolume())
            json:Add(properties:PITCH, audio:GetPitch())
            json:Add(properties:MAX_VOLUME_DISTANCE, audio:GetMaximumVolumeDistance())
            json:Add(properties:ROLLOFF_RATE, audio:GetRolloffRate())
            json:Add(properties:LOOPING, audio:GetLooping())
            json:Add(properties:DOPPLER_ENABLED, audio:GetDoppler())
            json:Add(properties:PLAY_ON_LOAD, audio:GetPlayOnLoad())

            return json
        else
            JavaScriptObjectNotation json = parent:DefaultSceneManager:SaveItem3D(item)
            return json
        end
    end

    private action SaveItem2D(Item2D item) returns JavaScriptObjectNotation
        SceneConstants constants

        if item:HasProperty(constants:EDITOR_TAG)
            return undefined
        end

        return parent:DefaultSceneManager:SaveItem2D(item)
    end

    private action CreateItem3D(text type) returns Item3D
        if type = "Model"
            EditorModel model
            return model
        elseif type = "PointLight"
            EditorPointLight light
            return light
        end

        return parent:DefaultSceneManager:CreateItem3D(type)
    end

    private action LoadItem3D(JavaScriptObjectNotation json) returns Item3D
        if json:GetValue(properties:CLASS) = "Audio3D"
            EditorAudio3D item
            item:LoadPlaceholderBox()

            text file = ""
            JavaScriptObjectNotation children = undefined
            number volume = 0
            number pitch = 0
            number maxDistance = 0
            number rolloffRate = 0
            boolean looping = false
            boolean doppler = true
            boolean playOnLoad = false

            Array<text> keys = json:GetKeys()

            integer counter = 0
            repeat while counter < keys:GetSize()
                text key = keys:Get(counter)
    
                if CustomLoadProperty3D(item, key, json)
                    // If we custom loaded this property, we don't do the normal processing for that key.
                elseif key = properties:NAME
                    item:SetName(json:GetValue(key))
                elseif key = properties:POSITION
                    Number32BitArray position = ConvertToNumber32BitArray(json:GetObject(key))
                    item:SetPosition(position:Get(0), position:Get(1), position:Get(2))
                elseif key = properties:FILE
                    item:SetSource(json:GetValue(key))
                elseif key = properties:DESCRIPTION
                    item:SetDescription(json:GetValue(key))
                elseif key = properties:CHILDREN
                    children = json:GetObject(key)
                elseif key = properties:VOLUME
                    item:SetVolume(json:GetNumber(key))
                elseif key = properties:PITCH
                    item:SetPitch(json:GetNumber(key))
                elseif key = properties:MAX_VOLUME_DISTANCE
                    item:SetMaximumVolumeDistance(json:GetNumber(key))
                elseif key = properties:ROLLOFF_RATE
                    item:SetRolloffRate(json:GetNumber(key))
                elseif key = properties:LOOPING
                    item:SetLooping(json:GetBoolean(key))
                elseif key = properties:DOPPLER_ENABLED
                    item:SetDoppler(json:GetBoolean(key))
                elseif key = properties:PLAY_ON_LOAD
                    item:SetPlayOnLoad(json:GetBoolean(key))
                end
    
                counter = counter + 1
            end

            return item
        else
            return parent:DefaultSceneManager:LoadItem3D(json)
        end
    end

    /*
    This action can be used to determine what working directory
    to use for file loading. This can be used to open model resources that
    exist in a different project, for example.
    */
    private action ConvertToProjectFile(text path) returns File
        File file
        file:SetWorkingDirectory(projectLocation:GetAbsolutePath())
        file:SetPath(path)
        return file
    end

    private action CustomLoadProperty3D(Item3D item, text key, JavaScriptObjectNotation json) returns boolean
        SceneConstants constants
        if key = properties:PHYSICS_ENABLED
            JavaScriptObjectNotation newJson
            boolean value = json:GetBoolean(key)
            newJson:SetBoolean(value)
            item:SetProperty(properties:PHYSICS_ENABLED, newJson)
            return true
        elseif key = properties:RESPONSIVENESS
            check
                integer value = json:GetInteger(key)
                JavaScriptObjectNotation newJson
                newJson:SetInteger(value)
                item:SetProperty(properties:RESPONSIVENESS, newJson)
                return true
            detect e is Error
                // An error occurs if there was no RESPONSIVENESS value to get. In that case we return silently.
                return false
            end
        elseif key = properties:MASS or key = properties:FRICTION or key = properties:RESTITUTION
            check
                number value = json:GetNumber(key)
                JavaScriptObjectNotation newJson
                newJson:SetNumber(value)
                item:SetProperty(key, newJson)
                return true
            detect e is Error
                // An error occurs if there was no value to get. In that case we return silently.
                return false
            end
        elseif key = constants:EULER_ANGLES
            
        end

        return false
    end

    private action CustomSaveProperty3D(Item3D item, text key, JavaScriptObjectNotation json) returns boolean
        SceneConstants constants
        if key = properties:CLASS
            if item is EditorPointLight
                json:Add(key, "PointLight")
                return true
            else
                return false
            end
        elseif key = properties:PHYSICS_ENABLED
            if item:HasProperty(key)
                boolean value = item:GetProperty(key):GetBoolean()
                json:Add(key, value)
                return true
            end
        elseif key = properties:RESPONSIVENESS
            if item:HasProperty(key)
                integer value = item:GetProperty(key):GetInteger()
                json:Add(key, value)
                return true
            end
        elseif key = properties:MASS or key = properties:FRICTION or key = properties:RESTITUTION
            if item:HasProperty(key)
                number value = item:GetProperty(key):GetNumber()
                json:Add(key, value)
                return true
            end
        elseif key = constants:EULER_ANGLES
            if not (item is EditorModel)
                return false
            end
            EditorModel model = cast(EditorModel, item)

            JavaScriptObjectNotation angles
            angles:SetArray()
            angles:Add(model:GetYaw())
            angles:Add(model:GetPitch())
            angles:Add(model:GetRoll())
    
            json:Add(key, angles)
            return true
        end
        return false
    end

    private action CustomLoadProperty2D(Item2D item, text key, JavaScriptObjectNotation json) returns boolean
        if key = properties:PHYSICS_ENABLED
            JavaScriptObjectNotation newJson
            boolean value = json:GetBoolean(key)
            newJson:SetBoolean(value)
            item:SetProperty(properties:PHYSICS_ENABLED, newJson)
            return true
        elseif key = properties:RESPONSIVENESS
            check
                integer value = json:GetInteger(key)
                JavaScriptObjectNotation newJson
                newJson:SetInteger(value)
                item:SetProperty(properties:RESPONSIVENESS, newJson)
                return true
            detect e is Error
                // An error occurs if there was no RESPONSIVENESS value to get. In that case we return silently.
                return false
            end
        elseif key = properties:MASS or key = properties:FRICTION or key = properties:RESTITUTION
            check
                number value = json:GetNumber(key)
                JavaScriptObjectNotation newJson
                newJson:SetNumber(value)
                item:SetProperty(key, newJson)
                return true
            detect e is Error
                // An error occurs if there was no value to get. In that case we return silently.
                return false
            end
        end

        return false
    end

    private action CustomSaveProperty2D(Item2D item, text key, JavaScriptObjectNotation json) returns boolean
        if key = properties:PHYSICS_ENABLED
            if item:HasProperty(key)
                boolean value = item:GetProperty(key):GetBoolean()
                json:Add(key, value)
                return true
            end
        elseif key = properties:RESPONSIVENESS
            if item:HasProperty(key)
                integer value = item:GetProperty(key):GetInteger()
                json:Add(key, value)
                return true

            // If physics is enabled but no responsiveness was selected, use the default responsiveness value (0 = UNMOVABLE).
            elseif item:HasProperty(properties:PHYSICS_ENABLED)
                json:Add(key, 0)
                return true
            end
        elseif key = properties:MASS or key = properties:FRICTION or key = properties:RESTITUTION
            if item:HasProperty(key)
                number value = item:GetProperty(key):GetNumber()
                json:Add(key, value)
                return true
            end
        end
        return false
    end

action HideLayers
        Array<EditorLayer> layers = GetSceneLayers()
        integer counter = 0
        repeat while counter < layers:GetSize()
            Layer layer = layers:Get(counter)
            Game game = manager:GetGame()
            game:RemoveLayer(layer)
            counter = counter + 1
        end

        HideDialogs()
    end

    action ShowLayers
        Array<EditorLayer> layers = GetSceneLayers()
        integer counter = 0
        repeat while counter < layers:GetSize()
            Layer layer = layers:Get(counter)
            Game game = manager:GetGame()
            game:AddLayer(layer)
            counter = counter + 1
        end

        HideDialogs()
    end

end