package Libraries.Interface.Controls.Blocks

use Libraries.Interface.Layouts.LayoutProperties
use Libraries.Containers.Array
use Libraries.Interface.Controls.Blocks.Block
use Libraries.Game.Graphics.Font
use Libraries.Containers.MultipleLineText
use Libraries.Interface.Layouts.ManualLayout
use Libraries.Interface.Events.TextChangeEvent
use Libraries.Interface.Events.TextChangeListener
use Libraries.Game.GameStateManager
use Libraries.System.File
use Libraries.Interface.Events.FocusEvent
use Libraries.Interface.Selections.CodeEditorSelection
use Libraries.Interface.Controls.Blocks.BlockItem
use Libraries.Interface.Views.ControlShaderView
use Libraries.Language.Compile.Blocks.ParserToBlockListener
use Libraries.Interface.Controls.Blocks.MultipleLineBlock
use Libraries.Interface.Controls.Blocks.MultipleLineBlockPart
use Libraries.Interface.Controls.Blocks.RootBlock
use Libraries.Interface.Controls.Blocks.FreeformBlock
use Libraries.Containers.Support.Pair
use Libraries.Language.Compile.CompilerErrorManager
use Libraries.Language.Compile.Parsing.QuorumLexer
use Libraries.Language.Compile.Parsing.QuorumParser
use Libraries.Language.Compile.Context.StartContext
use Libraries.Interface.Controls.Blocks.SingleLineBlock
use Libraries.Interface.Events.BlockChangeEvent
use Libraries.Interface.Events.BlockChangeListener
use Libraries.Interface.Undo.BlockEditManager
use Libraries.Interface.Controls.Blocks.IfBlock
use Libraries.Interface.Controls.Blocks.ActionBlock
use Libraries.Interface.Controls.Blocks.CheckBlock
use Libraries.Interface.Controls.ScrollableLineControl
use Libraries.Interface.Controls.LineNumberGutter
use Libraries.Interface.Controls.Gutter
use Libraries.Language.Support.FindReplace
use Libraries.Interface.Events.GutterListener
use Libraries.Interface.Events.GutterEvent
use Libraries.Language.Compile.Symbol.Class
use Libraries.Language.Debug.BreakpointManager
use Libraries.Interface.Behaviors.Blocks.all
use Libraries.Interface.Controls.AnnotationLineGutter
use Libraries.Containers.Iterator
use Libraries.Language.Compile.Hints.Hint
use Libraries.Language.Compile.CompilerError
use Libraries.Interface.Controls.CodeEditorLineNumberGutter
use Libraries.Interface.Accessibility

/*
    This is a class representing a code editor that contains source code and blocks. The design is 
    intended as a hybrid, showing visual annotations similar to blocks, while maintaining text-based
    representations for accessibility, version control, and other aspects of programming. This class
    contains a representation of the source code as a block, generated externally, and if
    this block is not present, the editor should default to the behavior of a normal textbox. In other words,
    if a block representation is available, it uses this, whereas if it is not, then it is just text.
*/
class CodeEditor is ScrollableLineControl, GutterListener, BlockEnvironment
    public constant text CODE_EDITOR_INPUT_GROUP = "CodeEditor"
    MultipleLineText rawCode
    CodeEditorSelection selection

    CodeEditorRenderer renderer
    ParserToBlockListener blockListener = undefined

    /*
    An array of listeners which are notified when the text in this editor changes.
    */
    Array<TextChangeListener> textChangeListeners
    Array<BlockChangeListener> blockChangeListeners

    BlockEditManager editManager

    GameStateManager manager
    Accessibility accessibility = undefined
    Item2D dummyItem = undefined


    boolean shouldCalculateWidth = true
    boolean shouldCalculateHeight = true
    boolean shouldCalculateNavigationIndices = true
    boolean shouldRegenerateBlocks = true
    boolean shouldRefreshView = false
    number totalContentWidth = -1
    number totalContentHeight = -1

    // variables for find/replace
    text findWord = ""
    FindReplace findReplace
    Array<Pair<integer>> findIndices = undefined
    integer findSelection = -1

    boolean failState = false
    File file = undefined
    Class clazz = undefined
    BreakpointManager breakpoints = undefined
    CodeEditorLineNumberGutter lineGutter
    AnnotationLineGutter annotationGutter

    /* 
    Cached, raw y-positions of lines in the text (e.g. the y-position of each line
    before applying offsets due to scrolling, or if the scroll bar as at the top)

    Calculated while calculating total content height.
    */
    Array<number> cachedLinePositions
    
    // A flag indicating that the CodeEditor is moving blocks using the keyboard (e.g. block insertion via the palette)
    boolean keyboardMovingBlocks = false

    on create
        /*
        Because the renderer is provided as the "scrollable region" for the ScrollableControl,
        we don't have to manually add it ourselves. It'll automatically be added during the
        "on create" of ScrollableControl.
        */
        renderer:SetName("Code Editor Background")
        SetName("Code Editor")

        SetInterfaceOptionsKey("CodeEditor")
        SetInputGroup(CODE_EDITOR_INPUT_GROUP)

        ManualLayout layout
        SetLayout(layout)

        SetFont(GetDefaultFont())

        accessibility = manager:GetAccessibility()

        selection:Initialize(me, "")
        editManager:SetEditor(me)
        AddTextChangeListener(editManager)
        rawCode:Initialize("")

                Item2D temp
        dummyItem = temp
        dummyItem:SetAccessibilityCode(dummyItem:parent:Item:ITEM)
        dummyItem:SetFocusable(true)
        dummyItem:SetName("Top of File")
        Add(dummyItem)

        
        lineGutter:SetPositionOnBaseLine(false)
        lineGutter:AddGutterListener(me)
        Add(cast(Gutter, lineGutter))
        Add(cast(Gutter, annotationGutter))

        CodeEditorPopupMenu popup
        popup:SetCodeEditor(me)
        SetPopupMenu(popup)
        SetAccessibilityCode(parent:Item:PANE)
        SetFocusable(true)
    end

    action NotifyAccessibility(Item item, text message)
        if accessibility not= undefined
            accessibility:Notify(item, message)
        end
    end

    action GetWhereAmI returns text
        text location = ""
        location = "Line " + selection:GetLine()
        return location
    end

    action SelectAll
        selection:Set(renderer:GetRootBlock():GetNextNavigableBlock(), 0, GetLineCount() - 1, undefined)
    end
    
    
    action GetDefaultFontName returns text
        text name = undefined
        Font font

        if font:IsFontAvailable("Courier New Bold")
            name = "Courier New Bold"
        elseif font:IsFontAvailable("courbd")
            name = "courbd"
        elseif font:IsFontAvailable("FiraCode-Retina")
            name = "FiraCode-Retina"
        elseif font:IsFontAvailable("FiraCode-Regular")
            name = "FiraCode-Regular"
        elseif font:IsFontAvailable("Lato")
            name = "Lato"
        elseif font:IsFontAvailable("Courier")
            name = "Courier"
        elseif font:IsFontAvailable("Courier New")
            name = "Courier New"
        elseif font:IsFontAvailable("cour")
            name = "cour"
        elseif font:IsFontAvailable("Roboto-Black")
            name = "Roboto-Black"
        elseif font:IsFontAvailable("Arial")
            name = "Arial"
        elseif font:IsFontAvailable("Arial Unicode")
            font:LoadFont("Arial Unicode")
            SetFont(font)
        elseif font:IsFontAvailable("Helvetica")
            font:LoadFont("Helvetica")
            SetFont(font)
        elseif font:IsFontAvailable("Georgia")
            font:LoadFont("Georgia")
            SetFont(font)
        elseif font:IsFontAvailable("Times New Roman")
            font:LoadFont("Times New Roman")
            SetFont(font)
        else
            Array<File> availableFontFiles = font:GetAvailableFonts()
            if availableFontFiles:GetSize() > 0
                File file = availableFontFiles:Get(0)
                name = file:GetPath()
            end
        end
        
        return name
    end

    action GetLineNumberGutter returns LineNumberGutter
        return lineGutter
    end

    action GetAnnotationLineGutter returns AnnotationLineGutter
        return annotationGutter
    end

    action GetClass returns Class
        return clazz
    end

    action SetClass(Class clazz)
        me:clazz = clazz
    end

    action GutterClicked(GutterEvent event)
        Gutter gutter = event:GetGutter()
        if gutter is LineNumberGutter
            Block block = GetBlockAtNavigationIndex(event:GetLine())
            integer line = block:GetStartLine()
            if line >= GetLineCount()
                return now
            end
            if clazz not= undefined and clazz:GetFile() not= undefined and breakpoints not= undefined
                File file = clazz:GetFile()
                breakpoints:ToggleBreakpoint(file, line)
            end
        end
    end

    action FindText(text find, boolean wholeWord, boolean matchCase) 
        findWord = find
        text textValue = GetText() //+ bufferSpace


        findReplace:SetText(textValue)
        findIndices = findReplace:Find(find, wholeWord, matchCase)

//            if dialogIsOpen
//                UpdateSelections()
//            end
//            SetSelection()
//        end    
    end

    /* moves the selection index to the next position and sends the 
    previousSelection index to UpdatCurrentSelection() to add the new 
    currentSelection highlight and remove the previousSelection highlight 
    from the textBox */
    action NextFindSelection()
        if findIndices not= undefined and findIndices:GetSize() not= 0
            integer previousSelection = findSelection
            findSelection = findSelection + 1
            UpdateCurrentFindSelection(previousSelection, true)
        end
    end

    /* moves the selection index to the previous position and sends the 
    previousSelection index to UpdatCurrentSelection() to add the new 
    currentSelection highlight and remove the previousSelection highlight 
    from the textBox */
    action PreviousFindSelection()
        if findIndices not= undefined and findIndices:GetSize() not= 0
            integer previousSelection = findSelection 
            findSelection = findSelection - 1
            UpdateCurrentFindSelection(previousSelection, true)
        end
    end

    
    /* called by PreviousSelection(), NextSelection(), and SetSelection() to 
    update the current selection in the array of indices. Highlights the line 
    of the current selection in light blue (currently not working as expected), 
    highlights the current selection in a darker shade of blue, */
    private action UpdateCurrentFindSelection(integer previousSelection, boolean moveCaret)
        if findSelection < 0
            findSelection = (findIndices:GetSize() - 1)
        end
        if findSelection >= findIndices:GetSize()
            findSelection = 0
        end

        integer wordStartIndex =  findIndices:Get(findSelection):GetFirstValue()
        integer wordEndIndex = findIndices:Get(findSelection):GetSecondValue() + 1 
        integer line = GetLineIndex(wordStartIndex)

        
        Block startBlock = renderer:GetNavigableBlockAtTextLine(line)
        if startBlock:GetStartIndex() <= wordStartIndex and startBlock:GetEndIndex() > wordEndIndex
            integer relativeStart = wordStartIndex - startBlock:GetStartIndex()
            integer relativeEnd = wordEndIndex - startBlock:GetStartIndex()
            FreeformBlock newFreeform = ConvertToFreeform(startBlock)
            EditBox textBox = newFreeform:GetTextBox()
            textBox:Select(relativeStart, relativeEnd)

            SelectBlockAtTextLine(line, false)
        else
            SelectBlockAtTextLine(line, false)
        end
//        ColoredHighlight highlight
//        ColoredHighlight selectionHighlight
//        highlight:SetVisibleWhileSelected(false)
//        selectionHighlight:SetVisibleWhileSelected(false)
//        TextStyle textStyle
//        TextStyle word
//
//        InterfaceOptions options = gameStateManager:GetInterfaceOptions()
//        ColorGroup color = options:GetColorProperty(optionsConstants:EDITOR_FIND_COLOR)
//        ColorGroup selectColor = options:GetColorProperty(optionsConstants:EDITOR_FIND_SELECTION_COLOR)
//        highlight:SetColor(color)
//        selectionHighlight:SetColor(selectColor)
//
//        if previousSelection >= 0 
//            integer previousStartIndex = findIndices:Get(previousSelection):GetFirstValue()
//            integer previousEndIndex = findIndices:Get(previousSelection):GetSecondValue()
//            integer previousLineStartIndex = GetLineIndexOfCharacter(previousStartIndex)
//            textStyle:SetIndex(previousStartIndex)
//            textStyle:SetSize((previousEndIndex - previousStartIndex) + 1)
//            textStyle:SetHighlight(highlight)
//
//            if dialogIsOpen
//            //resets the previous selection back to the orange highlight and removes the line highlight
//                if not HasTextStyle("highlight" + previousStartIndex)
//                    AddFindReplaceStyle("highlight" + previousStartIndex, textStyle)
//                end
//            end
//            if HasTextStyle("selectionHighlight" + previousStartIndex)
//                RemoveFindReplaceStyle("selectionHighlight" + previousStartIndex)
//            end
//        end
//
//        if dialogIsOpen
//            word:SetIndex(wordStartIndex)
//            word:SetSize((wordEndIndex - wordStartIndex)+ 1)
//            word:SetHighlight(selectionHighlight)
//
//            //sets the current selection to blue highlight
//            RemoveFindReplaceStyle("highlight" + wordStartIndex)       //remove the orange highlight
//            AddFindReplaceStyle("selectionHighlight" + wordStartIndex, word)    //add the blue highlight for current selection
//        else
//            SetCaretPosition(wordEndIndex + 1)
//            Select(wordStartIndex, wordEndIndex + 1, true)
//        end
//
//        if findDialog not= undefined
//            findDialog:UpdateMatches(findSelection, findIndices:GetSize())
//        end
    end

    action GetCurrentFindIndex returns integer
        return findSelection
    end

    action GetFindMatches returns integer
        return findIndices:GetSize()
    end

/* replaces only the current selection of find with replace, if there is no
    text in the replaceField of the dialog, then the findWOrd is replaced with a 
    blank text. */
    action Replace(text replaceWord) 
        //SetTextChangeListenerOn(false) *In the ReplaceBehavior
        if findSelection < 0
            findSelection = 0
        end
        if findIndices:GetSize() not= 0
            MultipleLineText newCode = rawCode
            integer startIndex = findIndices:Get(findSelection):GetFirstValue()
            integer endIndex = findIndices:Get(findSelection):GetSecondValue()
            newCode = newCode:Delete(startIndex, (endIndex + 1))
            newCode = newCode:Insert(startIndex, replaceWord)
            editManager:SetSpecialAction(true)
            SetCode(newCode)
            editManager:SetSpecialAction(false)
        end
        //SetTextChangeListenerOn(true) *In the ReplaceBehavior*
    end


    /* replaces all instances of the current find word with the current replace 
    word using an offset if necessary to correctly replace the findWord indices 
    throughout the textBox. If the replaceField is empty, then the findWord is
    replaced with blank text. */
    action ReplaceAll(text findWord, text replaceWord)
        if findIndices:GetSize() not= 0   
            integer replaceSize = replaceWord:GetSize()
            integer findSize = findWord:GetSize()
            integer offset = replaceSize - findSize
            integer startIndex = 0
            integer endIndex = 0

            integer i = 0
            MultipleLineText newCode = rawCode
            repeat while i < findIndices:GetSize()
                if i not= 0
                    startIndex = ((findIndices:Get(i):GetFirstValue()) + (offset * i))
                    endIndex = ((findIndices:Get(i):GetSecondValue()) + (offset * i))
                else
                    startIndex = findIndices:Get(i):GetFirstValue()
                    endIndex = findIndices:Get(i):GetSecondValue()
                end
                newCode = newCode:Delete(startIndex, (endIndex + 1))
                newCode = newCode:Insert(startIndex, replaceWord)
                i = i + 1
            end
            editManager:SetSpecialAction(true)
            SetCode(newCode)
            editManager:SetSpecialAction(false)
        end
    end

    action GetRootBlock returns RootBlock
        return renderer:GetRootBlock()
    end

    /*
    This action scrolls the scrolling area vertically to center on the start line of the Block.
    */
    action GoToBlock(Block block)
        if block not= undefined
        GoToLine(block:GetNavigationIndex())
            end
end

    /*
    This action attempts to center the scrolling area vertically on the provided navigation line index.
    Note that in most cases, but not all, this will match the line of text.
    */
    action GoToLine(integer line)
        if line < 0 or line >= rawCode:GetLineCount()
            return now
        end
        // This equation was derived by algebraicly reverse-engineering the GetLineY action for a fixed y and an unknown scroll percentage.
        number targetY = renderer:GetHeight() / 2.0
        number viewPercent = (targetY - (renderer:GetHeight() + cachedLinePositions:Get(line))) / GetTotalContentHeight()
        
        if viewPercent < 0
            viewPercent = 0
        elseif viewPercent > 1
            viewPercent = 1
        end

        if viewPercent not= GetScrollPercentageY()
            SetScrollPercentageY(viewPercent)
        end
    end

    action SetInterfaceOptionsKey(text key)
        parent:Control:SetInterfaceOptionsKey(key)
        renderer:SetInterfaceOptionsKey(key)
    end

    action SetInterfaceScale(number scale)
        if scale not= GetInterfaceScale()
shouldCalculateWidth = true
        shouldCalculateHeight = true
        end

        parent:Control:SetInterfaceScale(scale)
    end

    action SetCode(text code)
        code = SanitizeNewLines(code)
        rawCode:Initialize(code)
        failState = not GenerateStartContextFromCode(code)
        if failState
            blockListener:SetStartContext(undefined)
        end
        
        shouldCalculateWidth = true
        shouldCalculateHeight = true
        shouldRegenerateBlocks = true
        shouldCalculateNavigationIndices = true
        RequestLayout()
    end

    action SetCode(MultipleLineText code)
        MultipleLineText sanitized
        sanitized:Initialize(SanitizeNewLines(code:GetText()))
        rawCode = sanitized
        failState = not GenerateStartContextFromCode(code:GetText())
        if failState
            blockListener:SetStartContext(undefined)
        end
        
        shouldCalculateWidth = true
        shouldCalculateHeight = true
        shouldRegenerateBlocks = true
        shouldCalculateNavigationIndices = true
        RequestLayout()
    end


    private action GenerateStartContextFromCode(text code) returns boolean
        CompilerErrorManager manager
        QuorumLexer lexer
        lexer:SetCompilerErrorManager(manager)
        lexer:Read(code)
        
        if not manager:IsCompilationErrorFree()
            return false
        end
        QuorumParser parser
        parser:SetCompilerErrorManager(manager)
        parser:SetLexer(lexer)
        StartContext start = parser:Start()
        if not manager:IsCompilationErrorFree()
            return false
        end
        blockListener:SetQuorumLexer(lexer)
        blockListener:SetStartContext(start)
        return true
    end

    action HasValidParse returns boolean
        CompilerErrorManager manager
        QuorumLexer lexer
        lexer:SetCompilerErrorManager(manager)
        lexer:Read(GetText())
        if not manager:IsCompilationErrorFree()
            return false
        end
        QuorumParser parser
        parser:SetCompilerErrorManager(manager)
        parser:SetLexer(lexer)
        StartContext start = parser:Start()
        if not manager:IsCompilationErrorFree()
            return false
        end
        return true
    end

    action GetCaretPosition returns integer
        CodeEditorSelection blockSelection = GetSelection()
        if selection = undefined
            return -1
        end

        Block block = blockSelection:GetBlock()
        if block = undefined
            return -1
        end
        integer index = block:GetStartIndex()

        //Now get the block item and cast it
        BlockItem item = blockSelection:GetBlockItem()
        if item is EditBox
            EditBox edit = cast(EditBox, item)
            index = index + edit:GetStartIndex() + edit:GetCaretPosition()
        elseif item is EditField
            EditField edit = cast(EditField, item)
            index = index + edit:GetStartIndex() +edit:GetCaretPosition()
        end
        return index
    end

    action GetCaretGlobalX returns number
        CodeEditorSelection blockSelection = GetSelection()
        if selection = undefined
            return -1
        end

        Block block = blockSelection:GetBlock()
        if block = undefined
            return -1
        end
        integer index = block:GetStartIndex()

        //Now get the block item and cast it
        BlockItem item = blockSelection:GetBlockItem()
        if item = undefined and block:IsFastEditable()
            item = block:GetStartingEditRegion()
        end
        if item is EditBox
            EditBox edit = cast(EditBox, item)
            return edit:GetCaretGlobalX()
        elseif item is EditField
            EditField edit = cast(EditField, item)
            return edit:GetCaretGlobalX()
        end
        return -1
    end

    action GetCaretGlobalY returns number
        CodeEditorSelection blockSelection = GetSelection()
        if selection = undefined
            return -1
        end

        Block block = blockSelection:GetBlock()
        if block = undefined
            return -1
        end
        integer index = block:GetStartIndex()

        //Now get the block item and cast it
        BlockItem item = blockSelection:GetBlockItem()
        if item = undefined and block:IsFastEditable()
            item = block:GetStartingEditRegion()
        end
        if item is EditBox
            EditBox edit = cast(EditBox, item)
            return edit:GetCaretGlobalY()
        elseif item is EditField
            EditField edit = cast(EditField, item)
            return edit:GetCaretGlobalY()
        end
        return -1
    end

    action GetCode returns MultipleLineText
        return rawCode
    end

    action GetText returns text
        return rawCode:GetText()
    end

    action GetCodeBetween(integer startIndex, integer endIndex) returns text
        return rawCode:GetText(startIndex, endIndex)
    end

    action GetDefaultLineHeight returns number
        return GetFont():GetLineHeight() * (1 + GetPercentageLineHeightPadding())
    end

    action GetLineHeight(integer line) returns number
        Block block = renderer:GetBlockAtLine(line)
        if block is SingleLineBlock
            SingleLineBlock singleBlock = cast(SingleLineBlock, block)
            number detailsHeight = singleBlock:GetVisibleDetailLabelsHeight()
            
            integer startLine = block:GetNavigationIndex()
            integer endLine = block:GetNavigationEndIndex()
            if startLine not= endLine
                if line = startLine or line = endLine
                    return GetDefaultUnpaddedLineHeight() + GetLineHeightPadding(line) / 2.0 + detailsHeight
                else
                    return GetDefaultUnpaddedLineHeight() + detailsHeight
                end
            end
            
            return GetDefaultLineHeight() + detailsHeight
        end
        
        return GetDefaultLineHeight()
    end
    
action GetStaticLineHeight(integer line) returns number
        Block block = renderer:GetBlockAtLine(line)
        if block is SingleLineBlock
            SingleLineBlock singleBlock = cast(SingleLineBlock, block)
            number detailsHeight = 0
            if singleBlock:AlwaysShowDetailLabels()
detailsHeight = singleBlock:GetVisibleDetailLabelsHeight()
            end
            
            integer startLine = block:GetNavigationIndex()
            integer endLine = block:GetNavigationEndIndex()
            if startLine not= endLine
                if line = startLine or line = endLine
                    return GetDefaultUnpaddedLineHeight() + GetLineHeightPadding(line) / 2.0 + detailsHeight
                else
                    return GetDefaultUnpaddedLineHeight() + detailsHeight
                end
            end
            
            return GetDefaultLineHeight() + detailsHeight
        end
        
        return GetDefaultLineHeight()
    end

    action GetLineWidth(integer lineIndex) returns number
        if rawCode = undefined
            return 0
        end

        // TO-DO: Determine this from the node(s) located on this actual line.
        // Using the raw text is quick and dirty, but not guaranteed to match up with more complex blocks.
        // The constant "5" is added to provide extra space for enclosing structures, but is inflexible.
        // A better implementation here depends on a better data structure for the blocks/nodes.
        MultipleLineText line = rawCode:GetLine(lineIndex)
        return GetDefaultGlyphWidth() * (line:GetSize() + 5)
    end

    action GetTotalContentHeight returns number
        if shouldCalculateHeight
            shouldCalculateHeight = false
            
            // Recalculate cached y positions.
            cachedLinePositions:Empty()
            number currentY = 0

            integer counter = 0
            integer lines = GetLineCount()
            number total = 0
            repeat while counter < lines
                number currentHeight = GetStaticLineHeight(counter)
                currentY = currentY - currentHeight
                
                cachedLinePositions:Add(currentY)
                total = total + currentHeight
                counter = counter + 1
            end

            totalContentHeight = total
        end

        return totalContentHeight
    end

    action GetTotalContentWidth returns number
        if shouldCalculateWidth
            shouldCalculateWidth = false

            integer counter = 0
            integer lines = GetLineCount()
            number max = 0
            repeat while counter < lines
                number value = GetLineWidth(counter)
                if value > max
                    max = value
                end
                counter = counter + 1
            end

            totalContentWidth = max
        end

        return totalContentWidth
    end

    action NeedsNavigationIndicesUpdate returns boolean
        return shouldCalculateNavigationIndices
    end

    action RequestNavigationIndicesUpdate
        // If navigation indices are out of date, the cached line Y values are as well. We need to recalculate height in that case.
        shouldCalculateHeight = true

        shouldCalculateNavigationIndices = true
        RequestViewRefresh()
    end

    action RefreshNavigationIndices
        // If navigation indices are out of date, the cached line Y values are as well. We need to recalculate height in that case.
        shouldCalculateHeight = true

        renderer:RefreshNavigationIndices()
        shouldCalculateNavigationIndices = false
    end

    action GetScrollableRegion returns Control
        return renderer
    end

    /*
    This action returns how far the scrollable region should scroll vertically for
    a single "tick" of mouse scrolling on the y-axis. This value is returned as a
    percentage of the total content height (represented between 0 and 1).
    */
    action GetScrollIncrement returns number
        return GetDefaultLineHeight() / GetTotalContentHeight()
    end

    /*
    Returns the number of lines used for the blocks in the CodeEditor. This also corresponds to the total navigation indices of the blocks in the code.
    Note that this is different from GetRawTextLineCount, which returns how many lines are in the
    the raw text that represent the blocks under the hood. These two values can be different if the
    raw text splits up a single block's code on to multiple lines, e.g. if 
    a long if statement has its contents split onto multiple lines of text, but still only takes 1 block to represent.

    Attribute: Returns the number of lines used for blocks in the CodeEditor.
    */
    action GetLineCount returns integer
        if shouldCalculateNavigationIndices
            RefreshNavigationIndices()
        end

        if renderer:GetRootBlock() not= undefined
            return renderer:GetRootBlock():GetTotalNavigationSize()
        else
            return 0
        end
    end

    /*
    Returns the number of lines in the raw text that the blocks represent.
    Note that this is different from GetLineCount, which returns how many lines it takes to represent the blocks.
    These two values can be different if the raw text splits up a single block's code on to multiple lines, e.g. if 
    a long if statement has its contents split onto multiple lines of text, but still only takes 1 block to represent.

    Attribute: Returns the number of lines in the raw text of the code.
    */
    action GetRawTextLineCount returns integer
        return rawCode:GetLineCount()
    end

    /*
    Returns the pixel y-coordinate of the given line.
    */
    action GetLineY(integer line) returns number
        // If navigation indices are out of date, we need to update them, because we rely on them for correct line values.
        if shouldCalculateNavigationIndices
            RefreshNavigationIndices()
        end

        // If we don't have cached y-position values ready, go fetch them via calculating the height.
        if shouldCalculateHeight
            GetTotalContentHeight()
        end

        if line >= cachedLinePositions:GetSize()
            return 0
        end
        
        // Determine if any selected blocks before this line's index are showing dynamic labels, increasing their height and thus pushing this line down
        number dynamicHeightOffset = 0
        Array<Block> selectedBlocks = GetSelectedBlocks()
        if selectedBlocks not= undefined
integer i = 0
        repeat while i < selectedBlocks:GetSize()
            Block block = selectedBlocks:Get(i)
                if block not= undefined and block:GetStartLine() > line
                    // Exit early if a block is beyond the line we're interested in.
                    i = selectedBlocks:GetSize()
                elseif block is SingleLineBlock
                    SingleLineBlock singleBlock = cast(SingleLineBlock, block)
                    if singleBlock:AlwaysShowDetailLabels() = false
                        dynamicHeightOffset = dynamicHeightOffset + singleBlock:GetVisibleDetailLabelsHeight()
                    end
                end
                i = i + 1
        end
        end
        
        return (renderer:GetHeight() + cachedLinePositions:Get(line) - dynamicHeightOffset) + (GetScrollPercentageY() * GetTotalContentHeight())
    end
    
    /*This action returns the navigation index of a line located at the given pixel y-coordinate.
The y-coordinate should be relative to the position of the CodeEditor.*/
    action GetNavigationIndexAtY(number pixelY) returns integer
integer i = 0
        integer size = GetLineCount()
        number threshold = pixelY
        repeat while i < size
            number y = GetLineY(i)
            if y < threshold
                return i
            end

            i = i + 1
        end

        return i
    end

    action GetFirstVisibleLine returns integer
        integer i = 0
        integer size = GetLineCount()
        number threshold = renderer:GetHeight()
        repeat while i < size
            number y = GetLineY(i)
            if y < threshold
                return i
            end

            i = i + 1
        end

        return i
    end

    action GetLastVisibleLine returns integer
        integer i = 0
        integer size = GetLineCount()
        number threshold = 0
        repeat while i < size
            number y = GetLineY(i)
            if y < threshold
                return i
            end

            i = i + 1
        end

        return i
    end

    action GetFont returns Font
        Font font = parent:Control:GetFont()
        integer size = cast(integer, GetFontSize() * GetInterfaceScale())
        if font:GetSize() not= size
            font:SetSize(size)
        end
        return font
    end

    action GetLineIndex(integer characterIndex) returns integer
        return rawCode:LineIndexFromCharacterIndex(characterIndex)
    end

    /*
    This action instructs the CodeEditor to refresh its view.
    Typically it'll do this during the next frame of animation.
    */
    action RequestViewRefresh
        shouldRefreshView = true
    end
    
    /*
This action indicates that the editor should recalculate the height
and positioning of the lines. This is called automatically by the system
and usually shouldn't be called directly by users.
*/
    action RequestHeightRefresh
        shouldCalculateHeight = true
    end

    action Update(number seconds)
        if shouldRefreshView
            RefreshScrollableRegion()
        end
    end

    // Called automatically during a Resize via the ScrollableControl interface.
    private action RefreshScrollableRegion
        if shouldCalculateNavigationIndices
            RefreshNavigationIndices()
        end

        shouldRefreshView = false
        if shouldRegenerateBlocks
            RegenerateBlocks()
        else
            renderer:RefreshBlockView(GetFirstVisibleLine(), GetLastVisibleLine())
        end
    end

    action RegenerateBlocks
        // Attempt to generate a new start context from the code.
        failState = not GenerateStartContextFromCode(GetText())
        if failState
            blockListener:SetStartContext(undefined)
        end
        // When regenerating the blocks, we must assume that the sizing information we held previously might become invalid.
        shouldCalculateWidth = true
        shouldCalculateHeight = true
        shouldCalculateNavigationIndices = true

        shouldRegenerateBlocks = false

        RootBlock root = blockListener:Update(0, rawCode:GetSize())
        renderer:RegenerateBlocks(root)

        // If there was an old selection, it will be wrong now. Attempt to select in the same position as before.
        integer selectionLine = selection:GetLine()
        if selectionLine >= 0
            integer count = GetLineCount()
            if selectionLine >= count
                selectionLine = count - 1
            end

            SelectBlockAtLine(selectionLine)
            UpdateSelectionCursor()
        end
    end

    action AddTextChangeListener(TextChangeListener listener)
        textChangeListeners:Add(listener)
    end

    action RemoveTextChangeListener(TextChangeListener listener)
        textChangeListeners:Remove(listener)
    end

    action GetTextChangeListeners returns Array<TextChangeListener>
        return textChangeListeners
    end

action OnTextChange(TextChangeEvent event, integer indexOffset)
        text deleted = event:GetDeletedText()
        text added = event:GetAddedText()
        integer index = event:GetIndex() + indexOffset

        integer previousLineCount = rawCode:GetLineCount()

        if deleted:IsEmpty() = false
            rawCode = rawCode:Delete(index, index + deleted:GetSize())
        end
        if added:IsEmpty() = false
            SanitizeNewLines(added)
            rawCode = rawCode:Insert(index, added)
        end

        // If the number of lines has changed, we'll need to recalculate the height and y-positions of lines.
        if previousLineCount not= rawCode:GetLineCount()
            shouldCalculateHeight = true
            shouldCalculateNavigationIndices = true
        end

        if indexOffset = 0
            NotifyTextChangeListeners(event)
        else
            TextChangeEvent adjustedEvent
            adjustedEvent:Initialize(event:GetControl(), SanitizeNewLines(event:GetAddedText()), event:GetDeletedText(), index)
            NotifyTextChangeListeners(adjustedEvent)
        end
        
        if renderer:IsCursorActive()
            renderer:ShowCursor()
        end
    end

    action NotifyTextChangeListeners(TextChangeEvent event)
        integer counter = 0
        repeat while counter < textChangeListeners:GetSize()
            textChangeListeners:Get(counter):TextChanged(event)
            counter = counter + 1
        end

        manager:GetInput():NotifyTextChangeListeners(event)
    end

    action AddBlockChangeListener(BlockChangeListener listener)
        blockChangeListeners:Add(listener)
    end

    action RemoveBlockChangeListener(BlockChangeListener listener)
        blockChangeListeners:Remove(listener)
    end

    action GetBlockChangeListeners returns Array<BlockChangeListener>
        return blockChangeListeners
    end

    action NotifyBlockChangeListeners(BlockChangeEvent event)
        integer counter = 0
        repeat while counter < blockChangeListeners:GetSize()
            blockChangeListeners:Get(counter):BlockChanged(event)
            counter = counter + 1
        end
    end

    action GainedFocus(FocusEvent event)
        OnFocusChange(event)
    end
    
    action LostFocus(FocusEvent event)
        OnFocusLoss(event)
    end

    action OnFocusLoss(FocusEvent event)
        if ContainsFocus() = false
            renderer:HideCursor()
        end
    end
    
    /*
    This action is called when a Block or BlockItem in the editor receives focus, or if the Editor is focused directly.
    This is primarily responsible for updating the selection to match the focused element.
    */
    action OnFocusChange(FocusEvent event)
        Item newFocus = event:GetNewFocus()
        
        if shouldCalculateNavigationIndices
            RefreshNavigationIndices()
        end
        
        if newFocus is BlockItem
            BlockItem item = cast(BlockItem, newFocus)
            if selection:GetBlockItem() not= item
                selection:Set(item:GetBlock(), item:GetBlock():GetNavigationIndex() + (item:GetLineCount() - 1), item)
            end
        elseif newFocus is Block
            Block block = cast(Block, newFocus)
            // Don't adjust selection if the Block was already selected. Done to avoid problems with multiple selection.
            if block = selection:GetBlock() and selection:GetBlockItem() = undefined
                return now
            end
            
            if block is SingleLineBlock
                // In case this is a single line wrapped around multiple, aim to select its last line, so the selection line is rendered at the bottom
                selection:Set(block, block:GetNavigationEndIndex(), undefined)
            else
                selection:Set(block, block:GetNavigationIndex(), undefined)
            end
        elseif newFocus:Equals(me)
            // If there's no selection, default to selecting the first block visible on the screen.
            if selection:IsEmpty()
                Block block = renderer:GetRootBlock()
                if block not= undefined and block:GetNextNavigableBlock() not= undefined
                    SelectBlockAtLine(GetFirstVisibleLine())
                end
            elseif selection:GetBlockItem() not= undefined
                SelectBlockOrItem(selection:GetBlockItem())
            elseif selection:GetBlock() not= undefined
                SelectBlockOrItem(selection:GetBlockItem())
            elseif selection:GetLine() = -1
                if dummyItem not= undefined
                    dummyItem:Focus()
                end
            end
        end
        
        if ContainsFocus()
            UpdateSelectionCursor()
        end
    end

    /*  This action triggers automatically when the selection changes (via its SetDisplayName action, 
        done just before listeners are alerted).
    */
    action OnSelectionChange(Block lastBlock, BlockItem lastItem, integer lastLine)
        Block newBlock = selection:GetBlock()
        if newBlock not= lastBlock
            if lastBlock not= undefined
                lastBlock:LostSelection()
            end

            /*
            It's possible that a block losing the selection can result in a new selection occurring.
            This most likely occurs when a freeform block loses focus, parses, and causes the blocks to
            regenerate. If the selection has changed by this point, don't finish processing the (now
            outdated) selection.
            */ 
            if selection:GetBlock() not= newBlock
                return now
            end

            if newBlock not= undefined
                newBlock:GainedSelection()
            elseif lastBlock:IsFocused()
                //If the last block was focused and the new selection is undefined, give the Editor the focus so it still gets input from the keyboard.
                Focus()
            end
        end

        if newBlock = undefined or IsBlockFullyVisible(newBlock)
            UpdateSelectionCursor()
        else
            GoToBlock(newBlock)
        end
        
        if keyboardMovingBlocks
            // Move the placeholders to go just under the selected block, if they're not in the right spot.
            if renderer:GetPlaceholderStartIndex() not= selection:GetLine() + 1
                MovePlaceholdersToNavigationIndex(selection:GetLine() + 1)
            end
            
            Block currentSelection = selection:GetBlock()
            // It's possible that the selected block is one of the placeholders we've just moved (especially if the selection moved down into the placeholders).
            // If this happens, we need to re-sync the selected block and the selected index.
            if currentSelection not= undefined and currentSelection:IsPlaceholder() and GetBlockAtNavigationIndex(selection:GetLine()) not= currentSelection
                GetBlockAtNavigationIndex(selection:GetLine()):Focus()
            end
        end
    end

    action UpdateSelectionCursor
        renderer:UpdateSelectionCursor(selection)
    end

    /*
    This action indicates whether the Block is currently completely visible in the Editor.
    This means that if the Editor has enough content to scroll, then the Block is fully
    visible if the entire bounding rectangle of the Block is in the viewing area.
    */
    private action IsBlockFullyVisible(Block block) returns boolean
        return renderer:IsBlockFullyVisible(block)
    end

    action GetSelectedText returns text
        if selection:GetBlockItem() not= undefined
            if selection:GetBlockItem() is EditRegion
                EditRegion region = cast(EditRegion, selection:GetBlockItem())
                return region:GetSelectedText()
            end
        elseif selection:IsMultipleSelection()
        Array<Block> selectedBlocks = GetSelectedBlocks()
            integer startIndex = selectedBlocks:GetFromFront():GetStartIndex()
            integer endIndex = selectedBlocks:GetFromEnd():GetEndIndex()
            return rawCode:GetText(startIndex, endIndex)
        elseif selection:GetBlock() not= undefined
            return selection:GetBlock():GetText()
        end
        return undefined
    end
    
    action MoveSelectionDown
        if selection:GetBlock() not= undefined
            SelectBlockOrItem(selection:GetBlock():GetNextNavigableBlock())
        elseif selection:GetLine() < 0
            SelectBlockAtLine(0)
        else
            SelectBlockAtLine(selection:GetLine() + 1)
        end
    end

    action MoveMultipleSelectionDown
        if selection:GetBlock() not= undefined
            Block target = selection:GetBlock():GetNextNavigableBlock()
            if target = undefined
                return now
            end
            selection:Set(target, target:GetNavigationIndex(), selection:GetRangeEndLine(), undefined)
        end
    end
    
    action MoveSelectionUp
        if selection:GetBlock() not= undefined
            Block next = selection:GetBlock():GetPreviousNavigableBlock()
            if next not= undefined
                SelectBlockOrItem(next)
            else
                selection:SetToTopOfFile()
                if dummyItem not= undefined
                    dummyItem:Focus()
                end
            end
        elseif selection:IsEmpty()
            SelectBlockAtLine(0)
        else
            SelectBlockAtLine(selection:GetLine() - 1)
        end
    end

    action MoveMultipleSelectionUp
        if selection:GetBlock() not= undefined
            Block target = selection:GetBlock():GetPreviousNavigableBlock()
            if target = undefined
                return now
            end
            selection:Set(target, target:GetNavigationIndex(), selection:GetRangeEndLine(), undefined)
        end
    end
    
    action SelectNext
        BlockItem item = selection:GetBlockItem()
        Block block = selection:GetBlock()

        Item next = undefined
        if item not= undefined
            next = item:GetNextFocus()
        elseif block not= undefined
            next = block:GetNextFocus()
        end

        SelectBlockOrItem(next)
    end

    action SelectPrevious
        BlockItem item = selection:GetBlockItem()
        Block block = selection:GetBlock()

        Item next = undefined
        if item not= undefined
            next = item:GetPreviousFocus()
        elseif block not= undefined
            next = block:GetPreviousFocus()
        end

        SelectBlockOrItem(next)
    end

    action EscapeSelection
        BlockItem item = selection:GetBlockItem()
        Block block = selection:GetBlock()

        Item next = undefined
        if item not= undefined
            next = item:GetBlock()
        elseif block not= undefined
            next = block:GetEnclosingBlock()
        end

        SelectBlockOrItem(next)
    end

    action SelectBlockOrItem(Item target)
        if target not= undefined
            target:Focus()
        end
    end
    
    action SelectBlockRange(Block firstBlock, Block secondBlock, boolean selectionAtEnd)
        if firstBlock:GetNavigationIndex() < secondBlock:GetNavigationIndex()
        end
            Block temp = firstBlock
            firstBlock = secondBlock
            secondBlock = temp
        
        if selectionAtEnd
            selection:Set(firstBlock, firstBlock:GetNavigationIndex(), secondBlock:GetNavigationIndex(), undefined)
        else
            selection:Set(secondBlock, secondBlock:GetNavigationIndex(), firstBlock:GetNavigationIndex(), undefined)
        end
    end

    /*
        This action selects the line and informs
        the system that the debugger is stopped at this particular
        block.
    */
    action SelectDebuggerLine(integer line)
        Block block = SelectBlockAtTextLine(line)
        if block not= undefined
            lineGutter:SetDebuggerLine(block:GetNavigationIndex())
        end
    end

    action ClearDebuggerLine
        lineGutter:SetDebuggerLine(-1)
    end
    
    /*This action returns the active line in the debugger, or -1 if the debugger is
not currently active in the file.*/
    action GetDebuggerLine returns integer
        return lineGutter:GetDebuggerLine()
    end

    action SelectBlockAtTextLine(integer line) returns Block
        Block block = renderer:GetNavigableBlockAtTextLine(line)

        SelectBlockOrItem(block)
        return block
    end

    action SelectBlockAtTextLine(integer line, boolean focus) returns Block
        if focus
            return SelectBlockAtTextLine(line)
        end
        if line >= GetLineCount() or line < 0
            return undefined
        end

        Block candidate = renderer:GetNavigableBlockAtTextLine(line)

        // Selecting the block without selecting an item will cause it to be focused.
        selection:Set(candidate, line, undefined)
        return candidate
    end

    action SelectBlockAtLine(integer line)
        // If the blocks need to be regenerated or if the indices need to be updated, do that first.
        if shouldRegenerateBlocks
            RegenerateBlocks()
        end
        if shouldCalculateNavigationIndices
            RefreshNavigationIndices()
        end

        if line >= GetLineCount() or line < 0
            return now
        end

        Block candidate = renderer:GetNavigableBlockAtLine(line)

        // Selecting the block without selecting an item will cause it to be focused.
        SelectBlockOrItem(candidate)
    end

    action SelectBlockAtLine(integer line, boolean focus)
        if focus
            SelectBlockAtLine(line)
            return now
        end
        if line >= GetLineCount() or line < 0
            return now
        end

        Block candidate = renderer:GetNavigableBlockAtLine(line)

        // Selecting the block without selecting an item will cause it to be focused.
        selection:Set(candidate, line, undefined)
        //SelectBlockOrItem(candidate)
    end

    action GetSelection returns CodeEditorSelection
        return selection
    end
    
    action CreateNewLineBlock
        
        // If the selected block is a FreeformBlock, try to parse it before making a new one.
        if selection:GetBlock() is FreeformBlock
            // Note that if the selected block is replaced, the new one will be selected before we continue.
            FreeformBlock freeform = cast(FreeformBlock, selection:GetBlock())
            freeform:ParseToBlock()
        end

        integer currentLine = selection:GetLine()
        integer targetIndex = -1
        if selection:GetBlock() not= undefined
            currentLine = selection:GetBlock():GetEndLine()
        end

        if currentLine >= rawCode:GetLineCount() - 1
            targetIndex = rawCode:GetSize()
        elseif currentLine >= 0
            // Get the start of the next line, then go back one to reach the end of the current line.
            targetIndex = rawCode:CharacterIndexFromLineIndex(currentLine + 1) - rawCode:GetLineSeparator():GetSize()
        end
        boolean sharesLine = false
        if selection:GetBlock() not= undefined and targetIndex > 0
            
            text postText = rawCode:GetText(selection:GetBlock():GetEndIndex(), targetIndex)
            if postText:Trim() not= ""
                sharesLine = true
                targetIndex = selection:GetBlock():GetEndIndex()
            end
        end
        
        // Get the parent that the new block will be attached to.
        Block parentBlock = undefined
        integer scopeDepth = 0
        integer insertIndex = 0

        if currentLine < 0
            // If we're inserting at the top, we must add to the root block.
            parentBlock = renderer:GetRootBlock()
        else
            parentBlock = selection:GetBlock()

            scopeDepth = parentBlock:GetScopeDepth()
            insertIndex = parentBlock:GetParentIndex() + 1
    
            // If the selected block is the beginning of a scope, we can add straight to it.
            // Otherwise, we need to grab the parent of the selected block.
            if parentBlock:IsEnteringScope() = false
                parentBlock = parentBlock:GetParentBlock()
    
                if parentBlock is MultipleLineBlock
                    // Adjust the insert index to place this just after the MultipleLineBlock, instead of getting the parent index of the part.
                    insertIndex = parentBlock:GetParentIndex() + 1
    
                    // If the parent block is a MultipleLineBlock, go up one extra step to find the actual scoping block we want to attach to.
                    parentBlock = parentBlock:GetParentBlock()
                end
            else
                // If we're adding straight to a scoping block, it'll be the first block in the scope.
                insertIndex = 0
                scopeDepth = scopeDepth + 1
            end
        end

        text newLine = "
" + GetIndentationText(scopeDepth)
        if sharesLine
            newLine = "
"+ GetIndentationText(scopeDepth)+"
"
        end

        /*
        Call OffsetIndices on the parent. This will update the necessary indices in the hierarchy so their
        text and line indices are correct.
        */
        newLine = SanitizeNewLines(newLine)
        if not sharesLine
            parentBlock:OffsetIndices(targetIndex, newLine:GetSize(), 1)
        else
            parentBlock:OffsetIndices(targetIndex, newLine:GetSize(), 2)
        end
        if targetIndex < 0
            targetIndex = 0
        end

        // Process a text change event. This will automatically update the MultipleLineText.
        TextChangeEvent event
        event:Initialize(me, newLine, "", targetIndex)
        OnTextChange(event, 0)

        FreeformBlock newBlock

        if currentLine >= 0
            targetIndex = targetIndex + newLine:GetSize()
            if sharesLine
                targetIndex = targetIndex - rawCode:GetLineSeparator():GetSize()
            end

            newBlock:SetLocalStartLine(currentLine + 1 - parentBlock:GetStartLine())
            newBlock:SetLocalStartIndex(targetIndex - parentBlock:GetStartIndex())
            newBlock:SetLocalEndIndex(targetIndex - parentBlock:GetStartIndex())
        else
            newBlock:SetLocalStartLine(0)
            newBlock:SetLocalStartIndex(0)
            newBlock:SetLocalEndIndex(0)
        end

        newBlock:SetLocalEndIndex(newBlock:GetLocalStartIndex())
        newBlock:SetScopeDepth(scopeDepth)

        parentBlock:Add(insertIndex, cast(Block, newBlock))
        newBlock:Setup()

        renderer:RefreshBlockView(GetFirstVisibleLine(), GetLastVisibleLine())

        newBlock:Resize()
        MoveSelectionDown()
        BlockChangeEvent blockEvent

        integer eventIndex = targetIndex
        if targetIndex not= 0
            eventIndex = eventIndex - newLine:GetSize()
        end

        blockEvent:Set(me, eventIndex, insertIndex, newBlock, parentBlock, newLine, "", blockEvent:ADDED)
        NotifyBlockChangeListeners(blockEvent)
    end

    action ConvertToFreeform(Block block) returns FreeformBlock
        FreeformBlock result = undefined
        if block is MultipleLineBlockPart
            FreeformBlockPart newBlock
            result = newBlock
        else
            FreeformBlock newBlock
            result = newBlock
        end

        result:SetLocalStartLine(block:GetLocalStartLine())
        result:SetLocalEndLine(block:GetLocalEndLine())
        result:SetLocalStartIndex(block:GetLocalStartIndex())
        result:SetLocalEndIndex(block:GetLocalEndIndex())
        result:SetScopeDepth(block:GetScopeDepth())

        if block:IsEnteringScope()
            if block:IsExitingScope()
                result:UseEnterAndExitScopeStyling()
            else
                result:UseEnterScopeStyling()
            end
        elseif block:IsExitingScope()
            result:UseExitScopeStyling()
        end

        Replace(block, result)

        return result
    end

    /*
    This action replaces one block in the editor with another one.

    This does NOT set the local indices or lines of the new block! Make sure
    to set these values before using Replace!
    */
    action Replace(Block oldBlock, Block newBlock)
        Replace(oldBlock, newBlock, true)
    end

    /*
    This action replaces one block in the editor with another one.

    This does NOT set the local indices or lines of the new block! Make sure
    to set these values before using Replace!
    */
    action Replace(Block oldBlock, Block newBlock, boolean transferChildren)
        boolean wasSelected = (oldBlock = selection:GetBlock())

        // If the new block has a parent (e.g. a dummy root for constructing multiple line blocks) detach it before doing the swap.
        if newBlock:GetParentBlock() not= undefined
            newBlock:GetParentBlock():Remove(newBlock)
        end

        integer parentIndex = oldBlock:GetParentIndex()
        Block parentBlock = oldBlock:GetParentBlock()

        parentBlock:RemoveAt(parentIndex)
        parentBlock:Add(parentIndex, newBlock)

        if transferChildren
            // If the old block has children, move them to the new block.
            repeat until oldBlock:GetChildCount() = 0
                Block child = oldBlock:RemoveAt(0)
                newBlock:Add(child)
            end
        end

        newBlock:Setup()

        //if the told block had a hint condition, copy it over
        Iterator<Hint> hinterator = oldBlock:GetHintIterator()
        repeat while hinterator not= undefined and hinterator:HasNext()
            Hint hint = hinterator:Next()
            newBlock:Add(hint)
        end

        Iterator<CompilerError> errorator = oldBlock:GetErrorIterator()
        repeat while errorator not= undefined and errorator:HasNext()
            CompilerError error = errorator:Next()
            newBlock:Add(error)
        end

        if wasSelected
            if newBlock is MultipleLineBlock
                // If the new block is a multi-line block, get the first block part and select that.
                SelectBlockOrItem(newBlock:GetChild(0))
            else
                SelectBlockOrItem(newBlock)
            end
        end

        renderer:RefreshBlockView()
    end


    action InsertTextAfterLine(text value)
        integer line = selection:GetLine()
        
if selection:GetBlock() not= undefined
            line = selection:GetBlock():GetEndLine()
        end
        
        InsertTextAfterLine(line, value)
    end
    
    action InsertTextAfterLine(integer line, text value)
        integer currentLine = line
        integer targetIndex = 0
        value = SanitizeNewLines(value)

        if currentLine >= rawCode:GetLineCount() - 1
            targetIndex = rawCode:GetSize()
        elseif currentLine >= 0
            // Get the start of the next line, then go back one to reach the end of the current line.
            targetIndex = rawCode:CharacterIndexFromLineIndex(currentLine + 1)
        end

        text newLine = value + value:GetLineFeed()

        MultipleLineText oldCode = rawCode
        // Process a text change event. This will automatically update the MultipleLineText.
        TextChangeEvent event
        event:Initialize(me, newLine, "", targetIndex)
        OnTextChange(event, 0)

        BlockChangeEvent blockEvent
        blockEvent:Set(me, oldCode, rawCode)

        NotifyBlockChangeListeners(blockEvent)

        shouldCalculateWidth = true
        shouldCalculateHeight = true
        shouldRegenerateBlocks = true
        shouldCalculateNavigationIndices = true
        RequestLayout()
    end
    
    action InsertText(integer index, text value)
        
integer targetIndex = index
        value = SanitizeNewLines(value)
        editManager:SetSpecialAction(true)

        if targetIndex >= rawCode:GetSize()
            targetIndex = rawCode:GetSize() - 1
        end


        MultipleLineText oldCode = GetCode()
        // Process a text change event. This will automatically update the MultipleLineText.
        TextChangeEvent event
        event:Initialize(me, value, "", targetIndex)
        OnTextChange(event, 0)

        BlockChangeEvent blockEvent
        blockEvent:Set(me, oldCode, GetCode())

        NotifyBlockChangeListeners(blockEvent)
editManager:SetSpecialAction(false)
        shouldCalculateWidth = true
        shouldCalculateHeight = true
        shouldRegenerateBlocks = true
        shouldCalculateNavigationIndices = true
        RequestLayout()
    end

    /*
    This action deletes the currently selected block. If the passed boolean is true, all blocks
    nested inside the block will be deleted as well. If the boolean is false, they'll instead be
    preserved and reattached into the tree to the parent of the deleted block.
    */
    action DeleteSelectedBlock(boolean deleteContents)
        if selection:GetSelectedBlocks():GetSize() = 1
            Block block = selection:GetBlock()
            if block not= undefined
                Delete(block, deleteContents)
            end
        elseif selection:GetSelectedBlocks():GetSize() > 1
            integer startIndex = selection:GetSelectedBlocks():Get(0):GetStartIndex()
            Delete(startIndex, GetSelectedText():GetSize())
        end
    end

    /*
    This action deletes the given block. If the passed boolean is true, all blocks
    nested inside the block will be deleted as well. If the boolean is false, they'll instead be
    preserved and reattached into the tree to the parent of the deleted block.
    */
    action Delete(Block block, boolean deleteContents)
        Delete(block, deleteContents, true)
    end


    action Delete(integer index, integer size)
        MultipleLineText oldText = GetCode()
        text deletedText = rawCode:GetText(index, index+size)

        TextChangeEvent event
        event:Initialize(me, "", deletedText, index)
        OnTextChange(event, 0)

        BlockChangeEvent blockEvent
        blockEvent:Set(me,oldText, GetCode())
        NotifyBlockChangeListeners(blockEvent)

        shouldCalculateWidth = true
        shouldCalculateHeight = true
        shouldRegenerateBlocks = true
        shouldCalculateNavigationIndices = true
        RequestLayout()
    end

    /*
    This action deletes the given block. If the passed boolean is true, all blocks
    nested inside the block will be deleted as well. If the boolean is false, they'll instead be
    preserved and reattached into the tree to the parent of the deleted block.
    */
    action Delete(Block block, boolean deleteContents, boolean triggerEvent)
        shouldCalculateNavigationIndices = true
        editManager:SetSpecialAction(true)
        // After deleting the block, we'll jump to the target selection.
        Block targetSelection = undefined
        Block parentBlock = block:GetParentBlock()
        text deletedText = ""
        integer index = -1
        integer blockIndex = 0
        boolean isBlockPart = false
        Array<Block> children = undefined

        // find the index the block was attached to it's parent for undo purposes
        if parentBlock:IsEnteringScope() = false
            Block parentCheck = parentBlock:GetParentBlock()
            if parentCheck is MultipleLineBlock
                blockIndex = parentCheck:GetParentIndex() + 1
            end
        else
            blockIndex = 0
        end
        // find the next target to focus on
        targetSelection = block:GetNextNavigableBlock()
        if targetSelection = undefined
            targetSelection = block:GetPreviousNavigableBlock()
        end

        // grab the text that's being deleted

        // shift the indices if there is code on the start and end not contained in the block
        integer startIndex = block:GetStartIndex()
        integer targetIndex = rawCode:CharacterIndexFromLineIndex(rawCode:LineIndexFromCharacterIndex(startIndex))
        if targetIndex < 0
            targetIndex = 0
        end
        boolean sharesLine = false
        text pretext = ""
        if startIndex not= targetIndex
            pretext = rawCode:GetText(targetIndex, startIndex)
            if pretext:Trim() not= ""
                sharesLine = true
                targetIndex = startIndex
            end
        end
        integer endIndex = block:GetEndIndex()
        integer lines = block:GetEndLine() - block:GetStartLine() + 1
        // Make sure we grab the new line separator
        if not( sharesLine and lines = 1)
            integer nextLineIndex = rawCode:CharacterIndexFromLineIndex(block:GetEndLine() + 1)
            if nextLineIndex < endIndex
                nextLineIndex = rawCode:GetSize()
            end
            text postText = rawCode:GetText(endIndex, nextLineIndex)
            if postText:Trim() = ""
                endIndex = nextLineIndex
            else
                if sharesLine = false
                    targetIndex = startIndex
                end
            end
    
            if endIndex > rawCode:GetSize()
                endIndex = rawCode:GetSize()
            end
        end


        integer textSize = endIndex - targetIndex
        deletedText = rawCode:GetText(targetIndex, endIndex)
        index = targetIndex

        if block is MultipleLineBlockPart
            isBlockPart = true
            MultipleLineBlockPart multiBlock = cast(MultipleLineBlockPart, block)
            // If we're deleting the first or last part of a multi-line block, then we're deleting the whole thing.

                if parentBlock is IfBlock
                    MultipleLineText originalText = rawCode
                    MultipleLineText newText 
                    IfBlock ifParent = cast(IfBlock, parentBlock)
                    
                    targetSelection = block:GetNextNavigableBlock()

                    ifParent:RemoveChildBlock(block)
                    RequestViewRefresh()
                    newText = rawCode
                    if triggerEvent
                        BlockChangeEvent event
                        event:Set(me, originalText , newText)
                        
                        NotifyBlockChangeListeners(event)
                    end
                    
                    editManager:SetSpecialAction(false)
                    return now
                end

                if parentBlock is ActionBlock
                    ActionBlock actionParent = cast(ActionBlock, parentBlock)
                    if actionParent:IsSystemAction() or actionParent:IsBlueprintAction()
                        targetSelection = block:GetPreviousNavigableBlock()
                        if targetSelection = undefined
                            targetSelection = parentBlock:GetChild(parentBlock:GetChildCount() - 1):GetNextNavigableBlock()
                        end
                        DeleteBlockAndChildren(actionParent)
                        RequestViewRefresh()
                        if triggerEvent
                            BlockChangeEvent event
                            event:Set(me,index, blockIndex, block, parentBlock, "", deletedText, event:DELETED)
                            NotifyBlockChangeListeners(event)
                        end
                        editManager:SetSpecialAction(false)
                        SelectBlockOrItem(targetSelection)
                        return now
                    else
                        targetSelection = block:GetPreviousNavigableBlock()
                        if targetSelection = undefined
                            targetSelection = parentBlock:GetChild(parentBlock:GetChildCount() - 1):GetNextNavigableBlock()
                        end
                        DeleteBlockAndChildren(actionParent)
                        RequestViewRefresh()
                        if triggerEvent
                            BlockChangeEvent event
                            event:Set(me,index, blockIndex, block, parentBlock, "", deletedText, event:DELETED)
                            NotifyBlockChangeListeners(event)
                        end
                        editManager:SetSpecialAction(false)
                        SelectBlockOrItem(targetSelection)
                        return now
                    end
                    
                end

                if parentBlock is CheckBlock
                    CheckBlock checkParent = cast(CheckBlock, parentBlock)
                    MultipleLineText originalText = rawCode
                    MultipleLineText newText 
                    targetSelection = block:GetNextNavigableBlock()
                    checkParent:RemoveChildBlock(block)
                    RequestViewRefresh()
                    newText = rawCode
                    if triggerEvent
                        BlockChangeEvent event
                        event:Set(me, originalText , newText)
                        
                        NotifyBlockChangeListeners(event)
                    end
                    editManager:SetSpecialAction(false)
                    return now
                end

                if deleteContents
                    targetSelection = parentBlock:GetChild(parentBlock:GetChildCount() - 1):GetNextNavigableBlock()
                    if targetSelection = undefined
                        targetSelection = parentBlock:GetPreviousNavigableBlock()
                    end

                    // Delete the entire multi-line block in this case.
                    DeleteBlockAndChildren(parentBlock)
                else
                    targetSelection = block:GetNextNavigableBlock()
                    if targetSelection = undefined
                        targetSelection = block:GetPreviousNavigableBlock()
                    end
                    
                    DeleteBlockPreservingGrandchildren(block:GetParentBlock(), block:GetParentBlock():GetParentBlock())

                    if targetSelection not= undefined
                        SelectBlockOrItem(targetSelection)
                    end
                    
                    // Return early so we don't refresh the block view -- it'll be regenerated on the next frame due to the delete call happening
                    editManager:SetSpecialAction(false)
                    return now
                end


        else
            
            targetSelection = block:GetPreviousNavigableBlock()
            DeleteBlockAndChildren(block)
        end

        if triggerEvent
            BlockChangeEvent event
            event:Set(me,index, blockIndex, block, parentBlock, "", deletedText, event:DELETED)
            
            NotifyBlockChangeListeners(event)
        end

        editManager:SetSpecialAction(false)

        if targetSelection not= undefined
            SelectBlockOrItem(targetSelection)
        else
            selection:SetToTopOfFile()
            dummyItem:Focus()
        end

        if parentBlock is RootBlock and parentBlock:GetChildCount() = 0
            RegenerateBlocks()
            SelectBlockAtLine(0)
        else
            parentBlock:Resize()
            RequestViewRefresh()
        end

    end

    action DeleteBlockAndChildren(Block block)
        shouldCalculateNavigationIndices = true

        integer startIndex = block:GetStartIndex()
    
        // Make sure we delete the whole line by grabbing any indentation whitespace
        integer targetIndex = rawCode:CharacterIndexFromLineIndex(rawCode:LineIndexFromCharacterIndex(startIndex))
        if targetIndex < 0
            targetIndex = 0
        end

        boolean sharesLine = false
        text pretext = ""
        if startIndex not= targetIndex
            pretext = rawCode:GetText(targetIndex, startIndex)
            if pretext:Trim() not= ""
                sharesLine = true
                targetIndex = startIndex
            end
        end

        integer endIndex = block:GetEndIndex()
        integer lines = block:GetEndLine() - block:GetStartLine() + 1
        if block:GetChildCount() > 0
            Block lastBlock = block:GetChild(block:GetChildCount() - 1)
            endIndex = lastBlock:GetEndIndex()
            lines = lastBlock:GetEndLine() - block:GetStartLine() + 1
        end

        // Make sure we grab the new line separator
        if not( sharesLine and lines = 1)
            integer nextLineIndex = rawCode:CharacterIndexFromLineIndex(block:GetEndLine() + 1)
            if nextLineIndex < endIndex
                nextLineIndex = rawCode:GetSize()
            end
            text postText = rawCode:GetText(endIndex, nextLineIndex)
            if postText:Trim() = ""
                endIndex = nextLineIndex
            else
                if sharesLine = false
                    sharesLine = true
                    targetIndex = startIndex
                end
            end
    
            if endIndex > rawCode:GetSize()
                endIndex = rawCode:GetSize()
            end
        end

        integer textSize = endIndex - targetIndex
        text deletedText = rawCode:GetText(targetIndex, endIndex)

        Block parentBlock = block:GetParentBlock()
        parentBlock:Remove(block)

        /*
        Call OffsetIndices on the parent. By passing false for the final parameter,
        existing blocks shouldn't try to incorporate index changes that fall exactly
        on their start/end boundaries.
        */
        if lines = 1 and sharesLine
            lines = 0
        end
        parentBlock:OffsetIndices(targetIndex, -textSize, -lines)

        // Process a text change event. This will automatically update the MultipleLineText.
        TextChangeEvent event
        event:Initialize(me, "", deletedText, targetIndex)
        OnTextChange(event, 0)
    end

    action DeleteBlockPreservingChildren(Block block, Block newParent)
        shouldCalculateNavigationIndices = true

        Array<Block> preservedChildren
        integer i = 0
        repeat while i < block:GetChildCount()
            preservedChildren:Add(block:GetChild(i))
            i = i + 1
        end

        // We'll have to correct the local indices and line numbers to match up with the new parent
        integer offset = block:GetStartIndex() - newParent:GetStartIndex()
        integer lineOffset = block:GetStartLine() - newParent:GetStartLine()
        integer startIndex = block:GetStartIndex()
    
        // Make sure we delete the whole line by grabbing any indentation whitespace
        integer targetIndex = rawCode:CharacterIndexFromLineIndex(rawCode:LineIndexFromCharacterIndex(startIndex))
        if targetIndex < 0
            targetIndex = 0
        end
        boolean sharesLine = false
        text pretext = ""
        if startIndex not= targetIndex
            pretext = rawCode:GetText(targetIndex, startIndex)
            if pretext:Trim() not= ""
                sharesLine = true
                targetIndex = startIndex
            end
        end

        // Make sure we grab the new line separator
        integer endIndex = block:GetEndIndex()
        integer lines = block:GetEndLine() - block:GetStartLine() + 1

        if not( sharesLine and lines = 1)
            integer nextLineIndex = rawCode:CharacterIndexFromLineIndex(block:GetEndLine() + 1)
            if nextLineIndex < endIndex
                nextLineIndex = rawCode:GetSize()
            end
            text postText = rawCode:GetText(endIndex, nextLineIndex)
            if postText:Trim() = ""
                endIndex = nextLineIndex
            else
                if sharesLine = false
                    sharesLine = true
                    targetIndex = startIndex
                end
            end
    
            if endIndex > rawCode:GetSize()
                endIndex = rawCode:GetSize()
            end
        end

        integer textSize = endIndex - targetIndex
        text deletedText = rawCode:GetText(targetIndex, endIndex)

        Block parentBlock = block:GetParentBlock()
        parentBlock:Remove(block)

        /*
        Call OffsetIndices on the parent. By passing false for the final parameter,
        existing blocks shouldn't try to incorporate index changes that fall exactly
        on their start/end boundaries.
        */
        if lines = 1 and sharesLine
            lines = 0
        end
        parentBlock:OffsetIndices(targetIndex, -textSize, -lines)

        // Process a text change event. This will automatically update the MultipleLineText.
        TextChangeEvent event
        event:Initialize(me, "", deletedText, targetIndex)
        OnTextChange(event, 0)

        // We need to correct the offsets based on the size of the deleted text
        offset = offset - textSize
        lineOffset = lineOffset - lines

        // Now correct indices using our previously calculated offsets, and add them to the new parent
        i = 0    
        repeat while i < preservedChildren:GetSize()
            Block kid = preservedChildren:Get(i)
            integer startLine = kid:GetLocalStartLine()
            integer endLine = kid:GetLocalEndLine()
            kid:SetLocalStartIndex(kid:GetLocalStartIndex() + offset)
            kid:SetLocalEndIndex(kid:GetLocalEndIndex() + offset)
            kid:SetLocalStartLine(startLine + lineOffset)
            kid:SetLocalEndLine(endLine + lineOffset)
            newParent:Add(kid)
            
            i = i + 1
        end
    end

    action DeleteBlockPreservingGrandchildren(Block block, Block newParent)
        shouldCalculateNavigationIndices = true

        // Just modify the text directly and refresh the blocks.
        MultipleLineText updatedText = rawCode

        integer startLine = block:GetStartLine()

        // The end line is where the new end of the updated text will be, once we've deleted the text of the direct children
        integer endLine = block:GetEndLine() - block:GetChildCount()

        integer i = block:GetChildCount()
        repeat while i > 0
            i = i - 1
            Block current = block:GetChild(i)
            
            integer startIndex = current:GetStartIndex()
    
            // Make sure we delete the whole line by grabbing any indentation whitespace
            integer targetIndex = updatedText:CharacterIndexFromLineIndex(updatedText:LineIndexFromCharacterIndex(startIndex))
            if targetIndex < 0
                targetIndex = 0
            end
    
            integer endIndex = current:GetEndIndex()
    
            // Make sure we grab the new line separator
            endIndex = endIndex + updatedText:GetLineSeparator():GetSize()
    
            if endIndex > updatedText:GetSize()
                endIndex = updatedText:GetSize()
            end

            updatedText = updatedText:Delete(targetIndex, endIndex)
        end

        // Reduce the indentation for the remaining lines.
        i = startLine
        repeat while i <= endLine
            integer startIndex = updatedText:CharacterIndexFromLineIndex(i)
            if startIndex + 4 < updatedText:GetSize() 
                text whitespaceCheck = updatedText:GetText(startIndex, startIndex + 4)
                if whitespaceCheck:Trim() = ""
                                updatedText = updatedText:Delete(startIndex, startIndex + 4)
                end
            end
            i = i + 1
        end

        SetCode(updatedText)
        TextChangeEvent event
        event:Initialize(me, "", "", 0)
        OnTextChange(event, 0)
    end

    /*
    This action returns the character index at the start of the given line.
    */
    action GetIndexOfLineStart(integer lineIndex) returns integer
        return rawCode:CharacterIndexFromLineIndex(lineIndex)
    end

    /*
    This action returns the character index at the end of the given line.
    */
    action GetIndexOfLineEnd(integer lineIndex) returns integer
        if lineIndex < rawCode:GetLineCount() - 1
            return rawCode:CharacterIndexFromLineIndex(lineIndex + 1) - rawCode:GetLineSeparator():GetSize()
        else
            return rawCode:GetSize()
        end
    end

    /*
    This action returns the default indentation text at the beginning of a line,
    depending on the scope depth.
    */
    action GetIndentationText(integer scopeDepth) returns text
        text tab = "    "
        text result = ""
        repeat scopeDepth times        
            result = result + tab
        end
        return result
    end

    /*
        This on its own will only affect the raw code underneath but this is usually done with other operations 
        such as taking a freeform block and converting it into a MultipleLineBlockPart
    */
    action SetIndentation(Block block, integer scopeDepth)
        startIndex = block:GetStartIndex()
        lineStartIndex = rawCode:CharacterIndexFromLineIndex(rawCode:LineIndexFromCharacterIndex(startIndex))

        text oldIndentText = rawCode:GetText(lineStartIndex, startIndex)
        integer oldIndentSize = startIndex - lineStartIndex

        text newIndentText = GetIndentationText(scopeDepth)
        integer newIndentSize = newIndentText:GetSize()

        integer offset = newIndentSize - oldIndentSize
        Block parentBlock = block:GetParentBlock()
        parentBlock:OffsetIndices(lineStartIndex, offset, 0)

        TextChangeEvent event
        event:Initialize(me, newIndentText, oldIndentText, lineStartIndex)
        OnTextChange(event, 0)
        
    end

    /*
    This action returns true if the CodeEditor is focused, or if any of the Blocks
    or BlockItems inside of this editor are focused. Otherwise, it returns false.
    */
    action ContainsFocus returns boolean
        if IsFocused()
            return true
        end

        Item focus = manager:GetFocus()
        if focus is Block
            Block block = cast(Block, focus)
            BlockEnvironment envir = block:GetBlockEnvironment()
            if envir not= undefined
                return envir:Equals(me)
            end
        elseif focus is BlockItem
            BlockItem item = cast(BlockItem, focus)
            BlockEnvironment envir = item:GetBlockEnvironment()
            if envir not= undefined
                return envir:Equals(me)
            end
        end

        return false
    end

    action GetBlockEditManager returns BlockEditManager
        return editManager
    end

    action GetBlockListener returns ParserToBlockListener
        return blockListener
    end

    action SetBlockListener(ParserToBlockListener blockListener)
        me:blockListener = blockListener
        me:blockListener:SetBlockEnvironment(me)
    end

    action GetFailState returns boolean
        return failState
    end

    action SetFailState(boolean failState)
        me:failState = failState
    end

    action GetFile returns File
        return file
    end

    action SetFile(File file)
        me:file = file
        lineGutter:SetFile(file)
    end

    action GetBreakpointManager returns BreakpointManager
        return breakpoints
    end

    action SetBreakpointManager(BreakpointManager breakpoints)
        me:breakpoints = breakpoints
        lineGutter:SetBreakpointManager(breakpoints)
    end

    /* 
    This action checks if the given text is using either Windows or UNIX style
    new line separators, and if it's using a different new line style than the
    current OS's style, swaps the new lines to the system's style.
    */
    private action SanitizeNewLines(text inputText) returns text
        if inputText:IsEmpty()
            return inputText
        end

        text separator = rawCode:GetLineSeparator()
        text outputText = inputText

        text carriageReturn = separator:GetCarriageReturn()
        text lineFeed = separator:GetLineFeed()

        // If we're using Windows style separators.
        if separator = (carriageReturn + lineFeed)
            //QS now uses only linefeeds so this wont be needed
            //This also doesn't check for the only carriage return case
            integer readIndex = 0
            integer index = outputText:IndexOf(lineFeed, readIndex)
            repeat while index >= 0
                if index > 0 and outputText:GetCharacter(index - 1) = carriageReturn
                    readIndex = index + 1
                else
                    if index = 0
                        outputText = carriageReturn + outputText
                    else
                        text preText = outputText:GetSubtext(0, index) + carriageReturn
                        text postText = outputText:GetSubtext(index)
                        outputText = preText + postText
                    end

                    readIndex = index + 2
                end

                if readIndex >= outputText:GetSize()
                    index = -1
                else
                    index = outputText:IndexOf(lineFeed, readIndex)
                end
            end

        // If we're using Unix style separators.
        elseif separator = lineFeed
            outputText = outputText:Replace(carriageReturn + lineFeed, lineFeed)
            outputText = outputText:Replace(carriageReturn, lineFeed)
        end

        return outputText
    end

    private action GetEnclosingActionBlock returns Block
        if selection = undefined or selection:GetBlock() = undefined
            return undefined
        end

        Block actionBlock = undefined
        Block block = selection:GetBlock()
        if block not= undefined and IsActionOrConstructor(block)
            return block
        else 
            Block possibleAction = block:GetParentBlock()
            repeat while possibleAction not= undefined
                if IsActionOrConstructor(possibleAction)
                    actionBlock = possibleAction
                    possibleAction = undefined
                else
                    possibleAction = possibleAction:GetParentBlock()
                end
            end
        end

        return actionBlock
    end

    private action GetEnclosingClass returns ClassBlock
        RootBlock root = GetRootBlock()
        if root = undefined
            return undefined
        end
        i = 0
        repeat while i < root:GetChildCount()
            Block child = root:GetChild(i)
            if child is ClassBlock
                ClassBlock classBlock = cast(ClassBlock, child)
                return classBlock
            end
            i = i + 1
        end
        return undefined
    end

    private action IsActionOrConstructor(Block block) returns boolean
        if block is ActionBlock or block is ConstructorBlock
            return true
        else
            return false
        end
    end

    action SmartNavigateUp
        if selection = undefined or selection:GetBlock() = undefined
            return now
        end

        Block block = selection:GetBlock()

        //first get a class and action. Neither might exist in an implicit class
        //but if both are null, smart navigation does not do anything, so just return
        ClassBlock theClass = GetEnclosingClass()
        Block theAction = GetEnclosingActionBlock()
        //first check if it's a block not enclosed, so just get the first action
        if theClass = undefined and theAction = undefined
            return now
        elseif theClass not= undefined and theAction = undefined
            Block firstChild = theClass:GetChild(0)
            if firstChild = undefined
                return now
            end

            //get the last action and move on.
            i = firstChild:GetChildCount() - 1
            repeat while i >= 0
                Block child = firstChild:GetChild(i)
                if child not= undefined and IsActionOrConstructor(child)
                    NavigateToBlock(child)
                    return now
                end
                i = i - 1
            end
        elseif theClass not= undefined and theAction not= undefined
            //find the action before this one, or the last one
            //this is a class block and all the children are stored in the first child
            Block firstChild = theClass:GetChild(0)
            if firstChild = undefined
                return now
            end

            Block candidateAction = undefined
            //first find the action
            integer index = 0
            //first find the block
            i = 0
            repeat while i < firstChild:GetChildCount()
                Block child = firstChild:GetChild(i)
                if child:GetHashCode() = theAction:GetHashCode()
                    index = i
                    i = firstChild:GetChildCount()
                elseif child:GetHashCode() not= theAction:GetHashCode() and IsActionOrConstructor(child)
                    candidateAction = child
                end
                i = i + 1
            end


            if candidateAction not= undefined
                NavigateToBlock(candidateAction)
                return now
            end

            //loop back around up to the index, because we didn't check there.
            i = firstChild:GetChildCount() - 1
            repeat while i > index
                Block child = firstChild:GetChild(i)
                if IsActionOrConstructor(child)
                    NavigateToBlock(child)
                    return now
                end //this is the one
                i = i - 1
            end

            //nothing was found, so just do the action block
            NavigateToBlock(theAction)
        end
    end

    private action NavigateToBlock(Block block)
Block toNavigate = block
        if not toNavigate:IsNavigable()
            toNavigate = toNavigate:GetNextNavigableBlock()
        end
        if toNavigate = undefined
            return now
        end
        SelectBlockRange(toNavigate, toNavigate, true)
        GoToBlock(toNavigate)
        toNavigate:Focus()
    end
    

    action SmartNavigateDown
        if selection = undefined or selection:GetBlock() = undefined
            return now
        end

        Block block = selection:GetBlock()

        //first get a class and action. Neither might exist in an implicit class
        //but if both are null, smart navigation does not do anything, so just return
        ClassBlock theClass = GetEnclosingClass()
        Block theAction = GetEnclosingActionBlock()
        //first check if it's a block not enclosed, so just get the first action
        if theClass = undefined and theAction = undefined
            return now
        elseif theClass not= undefined and theAction = undefined
            Block firstChild = theClass:GetChild(0)
            if firstChild = undefined
                return now
            end

            //get the first action and move on.
            i = 0
            repeat while i < firstChild:GetChildCount()
                Block child = firstChild:GetChild(i)
                if child not= undefined and IsActionOrConstructor(child)
                    NavigateToBlock(child)
                    return now
                end
                i = i + 1
            end
        elseif theClass not= undefined and theAction not= undefined
            //find the action after this one
            //this is a class block and all the children are stored in the first child
            Block firstChild = theClass:GetChild(0)
            if firstChild = undefined
                return now
            end

            //the candidate action here would be the first 
            //one round the horn, so only do this once for down
            Block candidateAction = undefined
            //first find the action
            integer index = 0
            //first find the block
            i = 0
            repeat while i < firstChild:GetChildCount()
                Block child = firstChild:GetChild(i)
                if child:GetHashCode() = theAction:GetHashCode()
                    index = i
                    i = firstChild:GetChildCount()
                elseif child:GetHashCode() not= theAction:GetHashCode() 
                    and IsActionOrConstructor(child)
                    and candidateAction = undefined //only the first round the horn

                    candidateAction = child
                end
                i = i + 1
            end



            //loop back around up to the index, because we didn't check there.
            i = index + 1
            repeat while i < firstChild:GetChildCount()
                Block child = firstChild:GetChild(i)
                if IsActionOrConstructor(child)
                    NavigateToBlock(child)
                    return now
                end //this is the one
                i = i + 1
            end

            //if we didn't find one previously, choose the first round the horn
            if candidateAction not= undefined
                NavigateToBlock(candidateAction)
                return now
            end

            //nothing was found, so just do the action block
            NavigateToBlock(theAction)
        end
    end

    action IsControlStructureBlock(Block block) returns boolean
        if  block is RepeatBlock or
            block is CheckBlock or
            block is ActionBlock or
            block is ConstructorBlock or
            block is ClassBlock or
            block is IfBlock
            return true
        else
            return false
        end
    end

    action TraverseBackward(Block block) returns Block
        Block candidate = block:GetPreviousNavigableBlock()
        repeat until candidate = undefined
            if candidate is MultipleLineBlockPart
                return candidate
            end
            candidate = candidate:GetPreviousNavigableBlock()
        end
        return candidate
    end

    action TraverseForward(Block block) returns Block
        Block candidate = block:GetNextNavigableBlock()
        repeat until candidate = undefined
            if candidate is MultipleLineBlockPart
                return candidate
            end
            candidate = candidate:GetNextNavigableBlock()
        end
        return candidate
    end

    action SmartNavigateLeft
        if selection = undefined or selection:GetBlock() = undefined
            return now
        end

        Block block = selection:GetBlock()
        Block found = TraverseBackward(block)
        if found not= undefined
            NavigateToBlock(found)
            return now
        end
    end

    action SmartNavigateRight
        if selection = undefined or selection:GetBlock() = undefined
            return now
        end

        Block block = selection:GetBlock()
        Block found = TraverseForward(block)
        if found not= undefined
            NavigateToBlock(found)
            return now
        end
    end

    action GetNavigableBlocksInIndexRange(integer rangeStart, integer rangeEnd) returns Array<Block>
        Array<Block> result

        Block root = renderer:GetRootBlock()
        if root not= undefined
            GetBlocksInNavigationIndexRange(result, root, rangeStart, rangeEnd)
        end

        return result
    end

    private action GetBlocksInNavigationIndexRange(Array<Block> array, Block block, integer rangeStart, integer rangeEnd)
        if rangeStart > rangeEnd
            integer temp = rangeStart
            rangeStart = rangeEnd
            rangeEnd = temp
        end
        
        integer i = block:GetChildCount()
        // If we find a block with a navigation index less than our start, it might have eligible children,
        // But any elements attached to earlier tree nodes must have a lower index, so we don't have to look at those.
        boolean lastSubTree = false
        repeat while i > 0
        i = i - 1
            Block current = block:GetChild(i)
            integer currentIndex = current:GetNavigationIndex()
            integer currentEndIndex = current:GetNavigationEndIndex()
            if currentIndex > rangeEnd
                // Do nothing. This subtree can't have any elements in the range we need.
            elseif currentEndIndex < rangeStart
                if lastSubTree 
                    i = 0
                else
                    lastSubTree = true
                    GetBlocksInNavigationIndexRange(array, current, rangeStart, rangeEnd)
                end
            else
                GetBlocksInNavigationIndexRange(array, current, rangeStart, rangeEnd)
            end
        end

        if block:IsNavigable() and (block:GetNavigationIndex() <= rangeEnd and block:GetNavigationEndIndex() >= rangeStart)
            array:AddToFront(block)
        end
    end
    
    action GetSelectedBlocks returns Array<Block>
        if selection:IsMultipleSelection()
            return GetNavigableBlocksInIndexRange(selection:GetLine(), selection:GetRangeEndLine())
        end
        if selection:IsEmpty()
            return undefined
        end
        Array<Block> value
        value:Add(selection:GetBlock())
        return value
    end
    
    action GetBlockAtNavigationIndex(integer index) returns Block
        return renderer:GetBlockAtLine(index)
    end
    
    action GetEditRegionAtTextIndex(integer index) returns EditRegion
        integer line = GetLineIndex(index)
        Block block = renderer:GetNavigableBlockAtTextLine(line)
        if block = undefined
            return undefined
        end
        Array<Item2D> children = block:GetChildren()
        integer i = 0
        repeat while i < children:GetSize()
            Item2D item = children:Get(i)
            if item is EditRegion
                EditRegion region = cast(EditRegion, item)
                if index >= block:GetStartIndex() + region:GetStartIndex() and index <= block:GetStartIndex() + region:GetEndIndex()
                    return region
                end
            end
            i = i + 1
        end
        return undefined
    end
    
    action SelectBlockRange(Block block, integer endIndex)
        if endIndex < 0
            endIndex = 0
        end
        
        selection:Set(block, block:GetNavigationIndex(), endIndex, undefined)
    end
    
    action SelectFirstBlock
Block firstBlock = renderer:GetRootBlock():GetNextNavigableBlock()
        if firstBlock not= undefined
            SelectBlockOrItem(firstBlock)
        end
    end
    
    action SelectLastBlock
        Block lastBlock = GetLastBlock()
        if lastBlock not= undefined
            SelectBlockOrItem(lastBlock)
        end
    end
    
    action SelectRangeToFirstBlock
        Block firstBlock = renderer:GetRootBlock():GetNextNavigableBlock()
        if firstBlock not= undefined
            SelectBlockRange(firstBlock, selection:GetRangeEndLine())
        end
    end
    
    action SelectRangeToLastBlock
Block lastBlock = GetLastBlock()
        if lastBlock not= undefined
            SelectBlockRange(lastBlock, selection:GetRangeEndLine())
        end
    end
    
    private action GetLastBlock returns Block
    Block current = renderer:GetRootBlock()
        repeat until current:GetChildCount() = 0
            current = current:GetChild(current:GetChildCount() - 1)
        end
        
        return current
    end
    
    action IsAccessibleParent returns boolean
        return true
    end
    
    action InsertPlaceholdersAtNavigationIndex(integer index, Array<Block> placeholders)
        editManager:SetSpecialAction(true)
        renderer:InsertPlaceholdersAtNavigationIndex(index, placeholders)
        editManager:SetSpecialAction(false)
    end
    
    action MovePlaceholdersToNavigationIndex(integer index)
        renderer:MovePlaceholdersToNavigationIndex(index)
    end
    
    action HasPlaceholders returns boolean
        return renderer:HasPlaceholders()
    end
    
    action ConvertPlaceholdersToBlocks(text toInsert)
        renderer:ConvertPlaceholdersToBlocks(toInsert)
        // If the editor has been manually instructed to convert placeholders to blocks,
        // there's no longer anything to move with the keyboard, if we were doing so.
        keyboardMovingBlocks = false
    end
    
    action RemovePlaceholders
        renderer:RemovePlaceholders()
    end
    
    action SetMovingBlocks(Array<Block> blocks)
        renderer:SetMovingBlocks(blocks)
    end

    action CanAcceptPlaceholdersAtNavigationIndex(integer navigationIndex) returns boolean
        return renderer:CanAcceptPlaceholdersAtNavigationIndex(navigationIndex)
    end
    
    /*This action inserts the array of given blocks as placeholders at the given navigation index.
The user can then move the blocks up or down within the editor before confirming or cancelling
the placement.*/
    action KeyboardInsertBlocksAtIndex(integer navigationIndex, Array<Block> newBlocks)
        if IsKeyboardMovingBlocks()
            CancelKeyboardMovingBlocks()
        end
        keyboardMovingBlocks = true
            InsertPlaceholdersAtNavigationIndex(navigationIndex, newBlocks)
        if selection:GetBlock() not= undefined
            selection:GetBlock():Focus()
        else
            Focus()
        end
    end
    
    /*This action indicates whether the editor is currently moving blocks using the keyboard.
This includes when placing blocks via keyboard commands from a block palette.*/
    action IsKeyboardMovingBlocks returns boolean
        return keyboardMovingBlocks
    end
    
    /*This action confirms the placement of blocks being moved with the keyboard. The editor
will convert the placeholders to "real" blocks and exit the keyboard moving mode.*/
    action ConfirmKeyboardMovingBlocks
        renderer:ConvertPlaceholdersToBlocks()
        keyboardMovingBlocks = false
    end
    
    /*This action cancels the placement of blocks being moved with the keyboard. The editor
will remove the placeholders and revert the blocks to their prior state before exiting
keyboard moving mode.*/
    action CancelKeyboardMovingBlocks
        RemovePlaceholders()
        keyboardMovingBlocks = false
    end
    
    /*This action will return the navigation index that most closely matches with the given
line number in the raw text. */
    action GetNavigationIndexFromLine(integer line) returns integer
        if GetLineCount() <= 0
            return -1
        end
        
        if line < 0
            line = 0
        end
        if line >= GetLineCount()
            line = GetLineCount() - 1
        end
        
        // Once we start searching, we'll need to either to iterate forward or backwards through the blocks to find the correct line. 
        // Assume at first we need to iterate forward, but we'll check if this makes sense before using it.
        boolean moveForward = true
        
        // Start by trying to grab the block where (navigationIndex = lineNumber). Most of the time, these two will be the same.
        Block block = GetBlockAtNavigationIndex(line)
        if block not= undefined and line < block:GetStartLine()
            moveForward = false
        end
        
        // Return the block's index if it contains the line. Otherwise, check the next/previous block.
        // This is technically O(n), but in practice, the navigation index and line numbers will rarely diverge very far.
        repeat until block = undefined
            if block:GetStartLine() >= line and block:GetEndLine() <= line
                return block:GetNavigationIndex()
            end
            if moveForward
                block = block:GetNextNavigableBlock()
            else
                block = block:GetPreviousNavigableBlock()
            end
        end
        
        return -1
    end
    
/*This action will return the text line number that most closely matches with the given
navigation index. */
    action GetLineFromNavigationIndex(integer index) returns integer
if GetLineCount() <= 0
            return -1
        end
        
        if index < 0
            index = 0
        end
        if index >= GetLineCount()
            index = GetLineCount() - 1
        end
        
        Block block = GetBlockAtNavigationIndex(index)
        if block not= undefined
            return block:GetStartLine()
        end
        
        return -1
    end
end
