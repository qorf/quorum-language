package Libraries.Interface.Controls.Blocks

use Libraries.Interface.Controls.Blocks.EditField
use Libraries.Interface.Controls.Blocks.BlockLabel
use Libraries.Interface.Options.BlockOptionConstants
use Libraries.Interface.Controls.Layouts.ScopeBlockLayout
use Libraries.Language.Compile.Context.all
use Libraries.Language.Compile.Location
use Libraries.Interface.Controls.Layouts.MultipleLineBlockLayout
use Libraries.Containers.Array
use Libraries.Language.Compile.Parsing.Token
use Libraries.Interface.Events.TextChangeEvent
use Libraries.Containers.MultipleLineText

class IfBlock is MultipleLineBlock
    BlockLabel ifLabel = undefined
    EditField expressionField = undefined
    BlockLabel elseLabel = undefined

    Array<BlockLabel> elseifLabels
    Array<EditField> elseifExpressionFields

    MultipleLineBlockPart ifPart = undefined
    Array<MultipleLineBlockPart> elseifParts
    MultipleLineBlockPart elsePart = undefined
    MultipleLineBlockPart endPart = undefined

    IfContext ifContext
    boolean removingBlock = false

    on create
        BlockOptionConstants constants
        SetInterfaceOptionsKey(constants:IF_KEY)

        MultipleLineBlockLayout layout
        SetLayout(layout)

        SetName("If Block")
    end

    action SetupElements
        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()
        SetLeftPadding(spacing * 0.5)
        SetRightPadding(spacing * 0.5)
    end

    action AddStartLine returns MultipleLineBlockPart
        MultipleLineBlockPart part
        part:UseEnterScopeStyling()
        Add(part)

        // The start line is always the beginning of the multi-block, so it always starts at local index 0.
        part:SetLocalStartIndex(0)

        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()

        BlockLabel ifLabel
        me:ifLabel = ifLabel
        ifLabel:SetFont(GetEditor():GetFont())
        ifLabel:SetFontSize(GetEditor():GetFontSize())
        ifLabel:SetText("if")
        ifLabel:SetRightPadding(spacing)
        part:Add(ifLabel)

        EditField expressionField
        me:expressionField = expressionField
        part:Add(expressionField)

        Location expressionLoc = ifContext:ifExpression:GetLocation()
        expressionField:Setup("Expression", expressionLoc:GetIndex() - GetStartIndex(), expressionLoc:GetIndexEnd() + 1 - GetStartIndex())

        part:SetLocalEndIndex(expressionField:GetEndIndex())

        ifPart = part
        return part
    end

    action AddElseifLine(integer elseifIndex) returns MultipleLineBlockPart
        ParseContext elseifExpression = ifContext:elseIfExpressions:Get(elseifIndex)
        Token elseifToken = ifContext:elseIfTokens:Get(elseifIndex)

        MultipleLineBlockPart part
        part:UseEnterAndExitScopeStyling()
        Add(part)

        part:SetLocalStartIndex(elseifToken:startIndex - GetStartIndex())

        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()

        BlockLabel elseifLabel
        me:elseifLabels:Add(elseifLabel)
        elseifLabel:SetFont(GetEditor():GetFont())
        elseifLabel:SetFontSize(GetEditor():GetFontSize())
        elseifLabel:SetText("elseif")
        elseifLabel:SetRightPadding(spacing)
        part:Add(elseifLabel)

        EditField expressionField
        me:elseifExpressionFields:Add(expressionField)
        part:Add(expressionField)

        Location expressionLoc = elseifExpression:GetLocation()
        part:SetLocalStartLine(expressionLoc:GetLineNumber() - GetStartLine() - 1)
        expressionField:Setup("Expression", expressionLoc:GetIndex() - (GetStartIndex() + part:GetLocalStartIndex()), expressionLoc:GetIndexEnd() + 1 - (GetStartIndex() + part:GetLocalStartIndex()))

        part:SetLocalEndIndex(part:GetLocalStartIndex() + expressionField:GetEndIndex())

        elseifParts:Add(part)
        return part
    end

    action AddElseifLineFromFreeform(FreeformBlock block, text expression) returns MultipleLineBlockPart
        if elsePart not= undefined and elsePart:GetStartLine() < block:GetStartLine()
            return undefined
        end
        MultipleLineBlockPart part
        part:UseEnterAndExitScopeStyling()
        integer insertIndex = 0
        if elseifParts:GetSize() > 0
            MultipleLineBlockPart elseifPart = elseifParts:Get(0)
            repeat while insertIndex < elseifParts:GetSize() and elseifPart:GetStartLine() < block:GetStartLine()
                elseifPart = elseifParts:Get(insertIndex)
                i = insertIndex + 1
            end
        end

        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()

        editor:SetIndentation(block, GetScopeDepth())

        // grab the next siblings of the freeform to add them to the part later
        Array<Block> newChildren
        Block sibling = block:GetNextSibling()
        repeat while sibling not= undefined
            newChildren:Add(sibling)
            sibling = sibling:GetNextSibling()
        end

        Add(insertIndex+1, cast(Block,part))
        part:SetLocalStartIndex(block:GetStartIndex() - GetStartIndex())


        BlockLabel elseifLabel
        me:elseifLabels:Add(elseifLabel)
        elseifLabel:SetFont(GetEditor():GetFont())
        elseifLabel:SetFontSize(GetEditor():GetFontSize())
        elseifLabel:SetText("elseif")
        elseifLabel:SetRightPadding(spacing)
        part:Add(elseifLabel)

        EditField expressionField
        me:elseifExpressionFields:Add(expressionField)
        part:Add(expressionField)

        part:SetLocalStartLine(block:GetStartLine() - GetStartLine())
        expressionField:Setup("Expression", 7, 7 + expression:GetSize())

        part:SetLocalEndIndex(part:GetLocalStartIndex() + 7 + expressionField:GetText():GetSize())

        // with the indicies correct add the new children
        if newChildren:GetSize() > 0
            integer i = 0
            repeat while i < newChildren:GetSize()
                Block newChild = newChildren:Get(i)
                integer childStart = newChild:GetStartIndex()
                integer childEnd = newChild:GetEndIndex()
                integer childStartLine = newChild:GetStartLine()
                integer childEndLine = newChild:GetEndLine()
                Block oldParent = newChild:GetParentBlock()
                if oldParent not= undefined
                    oldParent:Remove(newChild)
                end
                part:Add(newChild)
                newChild:SetLocalStartIndex(childStart - part:GetStartIndex())
                newChild:SetLocalEndIndex(childEnd - part:GetStartIndex())
                newChild:SetLocalStartLine(childStartLine - part:GetStartLine())
                newChild:SetLocalEndLine(childEndLine - part:GetStartLine())
                i = i + 1
            end
        end
        elseifParts:Add(insertIndex, part)
        Block parentBlock = block:GetParentBlock()
        parentBlock:Remove(cast(Block, block))
        // the selection is set based on navigation indices so they must be set before selecting
        editor:RefreshNavigationIndices()
        // if the freeform block was selected select this block part instead
        if cast(Block,block) = editor:GetSelection():GetBlock()
            editor:SelectBlockOrItem(part)
        end
        editor:RequestNavigationIndicesUpdate()
        return part
    end

    action AddElseLine returns MultipleLineBlockPart
        MultipleLineBlockPart part
        part:UseEnterAndExitScopeStyling()
        Add(part)

        part:SetLocalStartLine(ifContext:elseLocation:GetLineNumber() - GetStartLine() - 1)

        part:SetLocalStartIndex(ifContext:elseLocation:GetIndex() - GetStartIndex())

        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()

        BlockLabel elseLabel
        me:elseLabel = elseLabel
        elseLabel:SetFont(GetEditor():GetFont())
        elseLabel:SetFontSize(GetEditor():GetFontSize())
        elseLabel:SetText("else")
        part:Add(elseLabel)

        part:SetLocalEndIndex(part:GetLocalStartIndex() + elseLabel:GetText():GetSize())

        elsePart = part
        return part
    end

    action AddElseLineFromFreeform(FreeformBlock block) returns MultipleLineBlockPart
        if elsePart not= undefined
            return undefined
        end
        MultipleLineBlockPart part
        part:UseEnterAndExitScopeStyling()
        integer i = 0
        repeat while i < elseifParts:GetSize()
            MultipleLineBlockPart elseifPart = elseifParts:Get(i)
            // if the block is before an elseif this is an error
            if elseifPart:GetStartLine() > block:GetStartLine()
                return undefined
            end
            i = i + 1
        end

        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()

        editor:SetIndentation(block, GetScopeDepth())
        // grab the next siblings of the freeform to add them to the part later
        Array<Block> newChildren
        Block sibling = block:GetNextSibling()
        repeat while sibling not= undefined
            newChildren:Add(sibling)
            sibling = sibling:GetNextSibling()
        end

        Add(GetChildCount() - 1, cast(Block,part))
        part:SetLocalStartIndex(block:GetStartIndex() - GetStartIndex())

        BlockLabel elseLabel
        me:elseLabel = elseLabel
        elseLabel:SetFont(GetEditor():GetFont())
        elseLabel:SetFontSize(GetEditor():GetFontSize())
        elseLabel:SetText("else")
        elseLabel:SetRightPadding(spacing)
        part:Add(elseLabel)

        part:SetLocalStartLine(block:GetStartLine() - GetStartLine())
        part:SetLocalEndIndex(part:GetLocalStartIndex() + elseLabel:GetText():GetSize())

        // with the indicies correct add the new children
        if newChildren:GetSize() > 0
            i = 0
            repeat while i < newChildren:GetSize()
                Block newChild = newChildren:Get(i)
                integer childStart = newChild:GetStartIndex()
                integer childEnd = newChild:GetEndIndex()
                integer childStartLine = newChild:GetStartLine()
                integer childEndLine = newChild:GetEndLine()
                Block oldParent = newChild:GetParentBlock()
                if oldParent not= undefined
                    oldParent:Remove(newChild)
                end
                part:Add(newChild)
                newChild:SetLocalStartIndex(childStart - part:GetStartIndex())
                newChild:SetLocalEndIndex(childEnd - part:GetStartIndex())
                newChild:SetLocalStartLine(childStartLine - part:GetStartLine())
                newChild:SetLocalEndLine(childEndLine - part:GetStartLine())
                i = i + 1
            end
        end

        elsePart = part
        Block parentBlock = block:GetParentBlock()
        parentBlock:Remove(cast(Block, block))
        // the selection is set based on navigation indices so they must be set before selecting
        editor:RefreshNavigationIndices()
        if cast(Block,block) = editor:GetSelection():GetBlock()
            editor:SelectBlockOrItem(part)
        end

        editor:RequestNavigationIndicesUpdate()
        return part
    end

    action AddEndLine returns MultipleLineBlockPart
        endPart = parent:MultipleLineBlock:AddEndLine()
        return endPart
    end

    action UpdateName(integer selectedLine)
//        if selectedLine = endLabel:GetRelativeLineIndex()
//            SetName("end")
//        else
//            //SetName("class " + nameField:GetText())
//        end
    end

    action RemoveChildBlock(Block block) returns boolean
        if block is MultipleLineBlockPart
            MultipleLineBlockPart blockPart = cast(MultipleLineBlockPart, block)
            if blockPart = ifPart
                RemoveIfPart(blockPart)
            elseif elseifParts:Has(blockPart)
                RemoveElseifPart(blockPart)
            elseif blockPart = elsePart
                RemoveElsePart(blockPart)
            elseif blockPart = endPart
                RemoveEndPart(blockPart)
            end
            MultipleLineBlockPart part = cast(MultipleLineBlockPart, block)
            GetBlockParts():Remove(part)
            part:SetParentBlock(undefined)

            repeat until GetBlockConnectors():GetSize() <= GetBlockParts():GetSize() - 1
                GetBlockConnectors():RemoveFromEnd()
            end
        end

        return parent:Control:Remove(block)
    end



    private action RemoveIfPart(Block block)
        // Just modify the text directly and refresh the blocks.
        MultipleLineText updatedText = GetEditor():GetCode()
        integer startLine = block:GetStartLine()

        // The end line is where the new end of the updated text will be, once we've deleted the text of the direct children
        integer endLine = block:GetEndLine() - block:GetChildCount()

        integer i = 0
        boolean modifyElseif = false
        boolean modifyElse = false
        integer linesToChange = 1
        text newExpression = ""
        if not elseifParts:IsEmpty()
            linesToChange = 2
            modifyElseif = true
        elseif elseifParts:IsEmpty() and elsePart not= undefined
            linesToChange = 2
            oldExpression = expressionField:GetText()
            newExpression = "not (" + oldExpression + ") "
            modifyElse = true
        elseif elseifParts:IsEmpty() and elsePart = undefined
            linesToChange = GetChildCount()
        end
        i = linesToChange
        repeat while i > 0
            i = i - 1
            Block current = GetChild(i)
            
            integer startIndex = current:GetStartIndex()

            if i = linesToChange - 1 and (modifyElse or modifyElseif)
                // delete the else in the elseif
                if modifyElseif
                    updatedText = updatedText:Delete(startIndex, startIndex + 4)
                elseif modifyElse
                    updatedText = updatedText:Delete(startIndex, startIndex + 4)
                    updatedText = updatedText:Insert(startIndex, "if " + newExpression)
                end
            else
                // Make sure we delete the whole line by grabbing any indentation whitespace
                integer targetIndex = updatedText:CharacterIndexFromLineIndex(updatedText:LineIndexFromCharacterIndex(startIndex))
                if targetIndex < 0
                    targetIndex = 0
                end
        
                integer endIndex = current:GetEndIndex()
        
                // Make sure we grab the new line separator
                endIndex = endIndex + updatedText:GetLineSeparator():GetSize()
        
                if endIndex > updatedText:GetSize()
                    endIndex = updatedText:GetSize()
                end
                updatedText = updatedText:Delete(targetIndex, endIndex)
            end
        end
        // Reduce the indentation for the remaining lines.
        i = startLine
        repeat while i <= endLine
            integer startIndex = updatedText:CharacterIndexFromLineIndex(i)
            updatedText = updatedText:Delete(startIndex, startIndex + 4)
            i = i + 1
        end

        GetEditor():SetCode(updatedText)
        TextChangeEvent event
        event:Initialize(me, "", "", 0)
        GetEditor():OnTextChange(event, 0)

    end

    private action RemoveElseifPart(Block block)
        RemoveMiddleBlockPart(block, block:GetPreviousSibling())
        MultipleLineBlockPart elseifPart = cast(MultipleLineBlockPart, block)
        elseifParts:Remove(elseifPart)
    end

    private action RemoveElsePart(Block block)
        RemoveMiddleBlockPart(block, block:GetPreviousSibling())
        elsePart = undefined
        elseLabel = undefined
    end

    private action RemoveMiddleBlockPart(Block block, Block newParent)
        MultipleLineText rawCode = GetEditor():GetCode()
        Array<Block> preservedChildren
        integer i = 0
        repeat while i < block:GetChildCount()
            preservedChildren:Add(block:GetChild(i))
            i = i + 1
        end
        Block nextBlock = block:GetNextNavigableBlock()
        Block previousBlock = block:GetPreviousNavigableBlock()
        // We'll have to correct the local indices and line numbers to match up with the new parent
        integer offset = block:GetStartIndex() - newParent:GetStartIndex()
        integer lineOffset = block:GetStartLine() - newParent:GetStartLine()
        integer startIndex = block:GetStartIndex()
    
        // Make sure we delete the whole line by grabbing any indentation whitespace
        integer targetIndex = rawCode:CharacterIndexFromLineIndex(rawCode:LineIndexFromCharacterIndex(startIndex))
        if targetIndex < 0
            targetIndex = 0
        end

        // Make sure we grab the new line separator
        integer endIndex = block:GetEndIndex() + rawCode:GetLineSeparator():GetSize()
        integer lines = block:GetEndLine() - block:GetStartLine() + 1

        if endIndex > rawCode:GetSize()
            endIndex = rawCode:GetSize()
        end

        integer textSize = endIndex - targetIndex
        text deletedText = rawCode:GetText(targetIndex, endIndex)

        integer index = block:GetParentIndex()

        i = GetChildCount() - 1
        repeat while i > index
            Block child = GetChild(i)
            child:SetParentIndex(i - 1)
            i = i - 1
        end

        block:SetParentIndex(-1)
        block:SetParentBlock(undefined)
        block:SetEditor(undefined)

        MultipleLineBlockPart part = cast(MultipleLineBlockPart, block)
        GetBlockParts():Remove(part)
        part:SetParentBlock(undefined)

        /*
        Call OffsetIndices on the parent. By passing false for the final parameter,
        existing blocks shouldn't try to incorporate index changes that fall exactly
        on their start/end boundaries.
        */
        OffsetIndices(targetIndex, -textSize, -lines, undefined)

        // Process a text change event. This will automatically update the MultipleLineText.
        TextChangeEvent event
        event:Initialize(me, "", deletedText, targetIndex)
        GetEditor():OnTextChange(event, 0)

        // We need to correct the offsets based on the size of the deleted text
        offset = offset - textSize
        lineOffset = lineOffset - lines

        // Now correct indices using our previously calculated offsets, and add them to the new parent
        i = 0    
        repeat while i < preservedChildren:GetSize()
            Block kid = preservedChildren:Get(i)
            integer startLine = kid:GetLocalStartLine()
            integer endLine = kid:GetLocalEndLine()
            kid:SetLocalStartIndex(kid:GetLocalStartIndex() + offset)
            kid:SetLocalEndIndex(kid:GetLocalEndIndex() + offset)
            kid:SetLocalStartLine(startLine + lineOffset)
            kid:SetLocalEndLine(endLine + lineOffset)
            newParent:Add(kid)
            
            i = i + 1
        end
        GetEditor():RefreshNavigationIndices()
        if cast(Block, block) = GetEditor():GetSelection():GetBlock()
            if nextBlock not= undefined
                GetEditor():SelectBlockOrItem(nextBlock)
            else
                GetEditor():SelectBlockOrItem(previousBlock)
            end
        end
        GetEditor():RequestNavigationIndicesUpdate()
    end

    private action RemoveEndPart(Block block)
        // if no else or elseif parts delete whole if preserving children
        if elsePart = undefined and elseifParts:IsEmpty()
            GetEditor():DeleteBlockPreservingGrandchildren(me, GetParentBlock())
            return now
        end

        // Just modify the text directly and refresh the blocks.
        MultipleLineText rawCode = GetEditor():GetCode()
        
        integer startLine = block:GetStartLine()

        // The end line is where the new end of the updated text will be, once we've deleted the text of the direct children
        integer endLine = block:GetEndLine() - block:GetChildCount()

        integer i = 0
        boolean modifyElseif = false
        boolean modifyElse = false
        integer linesToChange = 1
        text newExpression = ""
        if elsePart not= undefined
            modifyElse = true
        elseif not elseifParts:IsEmpty()
            modifyElseif = true
        end
        i = GetChildCount()
        // grab the end line
        integer startIndex = block:GetStartIndex()
        integer targetIndex = rawCode:CharacterIndexFromLineIndex(rawCode:LineIndexFromCharacterIndex(startIndex))
        if targetIndex < 0
            targetIndex = 0
        end

        integer endIndex = block:GetEndIndex()
        integer lines = block:GetEndLine() - block:GetStartLine() + 1
        // Make sure we grab the new line separator
        endIndex = endIndex + rawCode:GetLineSeparator():GetSize()

        if endIndex > rawCode:GetSize()
            endIndex = rawCode:GetSize()
        end

        integer textSize = endIndex - targetIndex
        text endText = rawCode:GetText(targetIndex, endIndex)
        rawCode = rawCode:Delete(targetIndex, endIndex)

        Block lastChain = undefined
        if modifyElse
            lastChain = elsePart
        else
            lastChain = elseifParts:GetFromEnd()
        end

        startIndex = lastChain:GetStartIndex()
        targetIndex = rawCode:CharacterIndexFromLineIndex(rawCode:LineIndexFromCharacterIndex(startIndex))
        if targetIndex < 0
            targetIndex = 0
        end

        endIndex = lastChain:GetEndIndex()
        lines = lastChain:GetEndLine() - lastChain:GetStartLine() + 1
        // Make sure we grab the new line separator
        endIndex = endIndex + rawCode:GetLineSeparator():GetSize()

        if endIndex > rawCode:GetSize()
            endIndex = rawCode:GetSize()
        end

        textSize = endIndex - targetIndex
        rawCode = rawCode:Delete(targetIndex, endIndex)
        rawCode = rawCode:Insert(targetIndex, endText)

        // Reduce the indentation for the remaining lines.
        i = startLine

//        repeat while i <= endLine
//            startIndex = updatedText:CharacterIndexFromLineIndex(i)
//            updatedText = updatedText:Delete(startIndex, startIndex + 4)
//            i = i + 1
//        end
//
        GetEditor():SetCode(rawCode)
        TextChangeEvent event
        event:Initialize(me, "", "", 0)
        GetEditor():OnTextChange(event, 0)
    end

    action GetIfContext returns IfContext
        return ifContext
    end

    action SetContext(IfContext ifContext)
        me:ifContext = ifContext
        SetContext(cast(ParseContext, ifContext))
    end

end