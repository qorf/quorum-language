package Libraries.Interface.Controls.Blocks

use Libraries.Interface.Controls.Control
use Libraries.Interface.Layouts.LayoutProperties
use Libraries.Interface.Views.ControlShaderView
use Libraries.Containers.Array
use Libraries.Interface.Controls.Blocks.EditRegion
use Libraries.Interface.Views.SingleLineBlockView
use Libraries.Interface.Views.BlockErrorShaderView
use Libraries.Interface.Controls.Blocks.BlockItem
use Libraries.Interface.Selections.CodeEditorSelection
use Libraries.Language.Compile.Context.ParseContext
use Libraries.Interface.Events.FocusEvent
use Libraries.Language.Compile.Hints.Hint
use Libraries.Language.Compile.CompilerError
use Libraries.Containers.Iterator
use Libraries.Containers.List
use Libraries.Game.GameStateManager
use Libraries.Interface.Accessibility
use Libraries.Game.Graphics.Painter2D
use Libraries.Game.Graphics.ColorNamer
use Libraries.Game.Graphics.ColorGroup
use Libraries.Game.Graphics.Color
use Libraries.Interface.Controls.Blocks.Palette.BlockPaletteItem
use Libraries.Game.Graphics.Font
use Libraries.Game.Graphics.Label

class Block is Control
    integer scopeDepth = 0
    //CodeEditor editor = undefined
    BlockEnvironment environment = undefined
    ParseContext context = undefined

    /*
    These values store the LOCAL character and line indices represented by this Block.
    These values are relative to the parent Block these are attached to.
    This allows us to specifically target index changes to relevant portions of the tree.
    */
    integer startIndex = -1
    integer endIndex = -1
    integer startLine = -1
    integer endLine = -1

    // An index used to navigate and render the blocks in a linear fashion.
    integer navigationIndex = -1

    /*
    Blocks store their relatives, making them elements in a linked list style structure.
    Relative blocks can be undefined if there's no code to correspond to a block (e.g.
    there's no "nextBlock" at the end of the file) OR if there is viable code, but the
    block isn't visible (e.g. there's no "nextBlock" if this block is the last block
    that's visible in the CodeEditor window).

    These are set when blocks are generated (e.g. CodeEditorRenderer's "RegenerateBlocks" action)
    */
    Block nextBlock = undefined
    Block previousBlock = undefined
    Block enclosingBlock = undefined

    // This block's parent in the Block tree structure.
    Block parentBlock = undefined

    // This block's index within the parent's node hierarchy.
    integer parentIndex = -1

    /*
    Multipliers on the notch positions, used to offset the notches.
    This is used in case of increasing/decreasing scope. In practice,
    these values should basically always be either 1 or 2.
    */
    number topNotchPositionFactor = 1
    number bottomNotchPositionFactor = 1
    List<Hint> hints
    List<CompilerError> errors

    // Used to identify when the rendering needs to be refreshed due to Hints changing.
    boolean renderingImportantHints = false
    
    /* 
Used to indicate if this is a placeholder. Placeholders don't represent "real" text in the code,
but instead are used to indicate "potential" code, e.g. where blocks that are being dragged might
be dropped. Placeholder blocks have special rules around their text values and how they're rendered.
*/
    boolean isPlaceholder = false
    // If this is a placeholder, it doesn't represent text in the real code, so it needs to store it separately here.
    text placeholderText = ""
    // This represents the controls used for a placeholder. Undefined by default.
    Array<Item2D> placeholderControls = undefined
    
    // Indicates that this Block is currently being moved with the mouse or keyboard.
    boolean isMoving = false
    

    on create
        SetName("Block")

        SetFocusable(true)
        SetAccessibilityCode(parent:Item:ITEM)
        SetAccessibilityRoleDescription("Block")
    end

    action GetBlockName returns text
        return ""
    end
    
    action GetBlockDescription returns text
        return ""
    end
    
    private action UpdateHintsAndErrorsVisuals
        boolean changed = false

        if errors:IsEmpty() = false
            if GetView2D() is BlockErrorShaderView = false
                BlockErrorShaderView view
                view:Initialize()
                SetView2D(view)

                changed = true
            end
        else
            if GetView2D() is SingleLineBlockView = false
                SingleLineBlockView view
                view:Initialize()
                SetView2D(view)

                changed = true
            end
        end

        boolean hasImportantHints = HasImportantHints()
        if renderingImportantHints not= hasImportantHints
            // The shader mapping will handle the actual change in this case, but it's important we tell the mapping to update the vertices.
            renderingImportantHints = hasImportantHints
            changed = true
        end
        
        if changed
            RequestVerticesUpdate()
        end
    end

    action HasImportantHints returns boolean
        return hints:IsEmpty() = false
    end

    action Add(Hint hint)
        hints:Add(hint)
        UpdateHintsAndErrorsVisuals()
    end

    action GetFirstHint returns Hint
        return hints:Get(0)
    end

    action GetHint(integer index) returns Hint
        return hints:Get(index)
    end

    action IsHintsEmpty returns boolean
        return hints:IsEmpty()
    end

    action GetHintsSize returns integer
        return hints:GetSize()
    end

    action Remove(Hint hint) returns boolean
        boolean value = hints:Remove(hint)
        UpdateHintsAndErrorsVisuals()
        return value
    end

    action GetHintIterator returns Iterator<Hint>
        return hints:GetIterator()
    end

    action EmptyHints
        hints:Empty()
        UpdateHintsAndErrorsVisuals()
    end

    action Add(CompilerError error)
        errors:Add(error)
        UpdateHintsAndErrorsVisuals()
    end

    action GetFirstError returns CompilerError
        return errors:Get(0)
    end

    action GetError(integer index) returns CompilerError
        return errors:Get(index)
    end

    action IsErrorsEmpty returns boolean
        return errors:IsEmpty()
    end

    action GetErrorsSize returns integer
        return errors:GetSize()
    end

    action Remove(CompilerError error) returns boolean
        boolean value = errors:Remove(error)
        UpdateHintsAndErrorsVisuals()
        return value
    end

    action GetErrorIterator returns Iterator<CompilerError>
        return errors:GetIterator()
    end

    action EmptyErrors
        errors:Empty()
        UpdateHintsAndErrorsVisuals()
    end

    /*
    Nests a block into this block. This is illegal for single line blocks. For multi-line blocks,
    only multi-line block parts can be added. Multi-line block parts can accept either single or
    multi-line blocks (as contents of a scope).
    */
    action Add(Block block)
        block:SetParentIndex(GetChildCount())
        block:SetParentBlock(me)
        block:SetBlockEnvironment(GetBlockEnvironment())
//        block:SetEditor(GetEditor())

        AddChildBlock(block)
    end

    /*
    Nests a block into this block. This is illegal for single line blocks. For multi-line blocks,
    only multi-line block parts can be added. Multi-line block parts can accept either single or
    multi-line blocks (as contents of a scope).
    */
    action Add(integer index, Block block)
        block:SetParentIndex(index)
        block:SetParentBlock(me)

        block:SetBlockEnvironment(GetBlockEnvironment())
//        block:SetEditor(GetEditor())

        integer i = index
        repeat while i < GetChildCount()
            Block child = GetChild(i)
            i = i + 1
            child:SetParentIndex(i)
        end

        AddChildBlock(index, block)
    end

    /*
    Removes a nested block from this block.
    */
    action Remove(Block block) returns boolean
        boolean result = RemoveChildBlock(block)

        if result = true
            integer index = block:GetParentIndex()

            integer i = GetChildCount() - 1
            repeat while i >= index
                Block child = GetChild(i)
                child:SetParentIndex(i)
                i = i - 1
            end

            block:SetParentIndex(-1)
            block:SetParentBlock(undefined)
            block:SetBlockEnvironment(undefined)
        end

        return result
    end

    /*
    Removes a nested block from this block at the given index.
    */
    action RemoveAt(integer index) returns Block
        Block result = RemoveChildBlock(index)

        if result not= undefined
            result:SetParentIndex(-1)
            result:SetParentBlock(undefined)
//            result:SetEditor(undefined)
            result:SetBlockEnvironment(undefined)
    
            integer i = GetChildCount() - 1
            repeat while i >= index
                Block child = GetChild(i)
                child:SetParentIndex(i)
                i = i - 1
            end
        end

        return result
    end

    /*
    Inserts this block as a child at the given relative line index. This follows the same
    rules as Adding blocks otherwise.
    */
    action InsertAtLine(Block block, integer line)
        // Find the first block that will come after this one once it's inserted
        // We start from the end because we expect new lines are more commonly added to the end of scopes, rather than the beginning
        integer i = GetChildCount()
        repeat until i <= 0
            Block child = GetChild(i - 1)
            if child:GetStartLine() < line
                Add(i, block)
                return now
            end

            i = i - 1
        end

        // If we got here, then we checked every block, and they all go after the candidate.
        Add(0, block)
    end

    private blueprint action AddChildBlock(Block block)

    private blueprint action AddChildBlock(integer index, Block block)

    private blueprint action RemoveChildBlock(Block block) returns boolean

    private blueprint action RemoveChildBlock(integer index) returns Block

    blueprint action EmptyChildBlocks

    blueprint action GetChildCount returns integer

    blueprint action GetChild(integer index) returns Block

    /*
    This action gets the starting character index of this block,
    relative to its parent block (if it has one).
    */
    action GetLocalStartIndex returns integer
        return startIndex
    end

    /*
    This action gets the ending character index of this block,
    relative to its parent block (if it has one).
    */
    action GetLocalEndIndex returns integer
        return endIndex
    end

    /*
    This action sets the starting character index of this block,
    relative to its parent block (if it has one).
    */
    action SetLocalStartIndex(integer index)
        startIndex = index
    end

    /*
    This action sets the ending character index of this block,
    relative to its parent block (if it has one).
    */
    action SetLocalEndIndex(integer index)
        endIndex = index
    end

    /*
    This action returns the starting character index of this block.
    This is the "overall" index, e.g. the position in the overall
    text regardless of parent or children blocks.
    */
    action GetStartIndex returns integer
        if parentBlock not= undefined
            return parentBlock:GetStartIndex() + GetLocalStartIndex()
        else
            return GetLocalStartIndex()
        end
    end

    /*
    This action returns the ending character index of this block.
    This is the "overall" index, e.g. the position in the overall
    text regardless of parent or children blocks.
    */
    action GetEndIndex returns integer
        if parentBlock not= undefined
            return parentBlock:GetStartIndex() + GetLocalEndIndex()
        else
            return GetLocalEndIndex()
        end
    end

    /*
    This action gets the starting line index of this block,
    relative to its parent block (if it has one).
    */
    action GetLocalStartLine returns integer
        return startLine
    end

    /*
    This action gets the ending line index of this block,
    relative to its parent block (if it has one).
    */
    action GetLocalEndLine returns integer
        return endLine
    end

    /*
    This action sets the starting line index of this block,
    relative to its parent block (if it has one).
    */
    action SetLocalStartLine(integer index)
        startLine = index

        // Ensure the end line doesn't precede the start line.
        if startLine > endLine
            SetLocalEndLine(startLine)
        end
    end

    /*
    This action sets the ending line index of this block,
    relative to its parent block (if it has one).
    */
    action SetLocalEndLine(integer index)
        endLine = index
    end

    /*
    This action returns the starting line index of this block.
    This is the "overall" index, e.g. the position in the overall
    text regardless of parent or children blocks.
    */
    action GetStartLine returns integer
        if parentBlock not= undefined
            return parentBlock:GetStartLine() + GetLocalStartLine()
        else
            return GetLocalStartLine()
        end
    end

    /*
    This action returns the ending line index of this block.
    This is the "overall" index, e.g. the position in the overall
    text regardless of parent or children blocks.
    */
    action GetEndLine returns integer
        if parentBlock not= undefined
            return parentBlock:GetStartLine() + GetLocalEndLine()
        else
            return GetLocalEndLine()
        end
    end

    action SetNavigationIndex(integer navigationIndex)
        me:navigationIndex = navigationIndex
    end

    /*
    This action returns the Block's overall index within the navigation tree structure.
    This is calculated using the navigation indices of the parents and/or previous siblings.
    */
    action GetNavigationIndex returns integer
        CodeEditor editor = GetEditor()
        if editor not= undefined and (navigationIndex < 0 or editor:NeedsNavigationIndicesUpdate())
            editor:RefreshNavigationIndices()
        end

        return navigationIndex
    end

    /*
    This action returns the last line that the Block renders on in the navigation tree structure.
    */
    action GetNavigationEndIndex returns integer
        integer index = GetNavigationIndex()
        integer size = GetNavigationSize()

        // Don't offset by a size of 1 or less, because in that case the start and end are the same.
        if size > 1
            return index + size - 1
        end

        return index
    end

    /*
    This action returns how much space is taken up in the navigation structure by
    this block and its children hierarchy. Any block that can be navigated to has a
    size of at least 1, but blocks that can't be navigated to can be size 0.
    */
    action GetNavigationSize returns integer
        if IsNavigable() = false
            return 0
        else
            // Navigable blocks across multiple lines take multiple spots in the navigation hierarchy, as you can navigate across the lines.
            return GetLocalEndLine() - GetLocalStartLine() + 1
        end
    end

    /*
    This action returns how much space is taken up in the navigation structure by
    this block and its children hierarchy. Any block that can be navigated to has a
    size of at least 1, but blocks that can't be navigated to can be size 0.
    */
    action GetTotalNavigationSize returns integer
        // Traverse all the way down the right side of the tree to the last element, then return its index + 1.
        Block current = me
        repeat while current:GetChildCount() > 0
            current = current:GetChild(current:GetChildCount() - 1)
        end

        // If there were no children to traverse, just return our own size.
        if current = me
            return GetNavigationSize()
        end

        // We can determine the size by subtracting our index from the index of the last child, plus the child's size (to account for extra space it takes)
        return (current:GetNavigationIndex() - GetNavigationIndex()) + current:GetNavigationSize()
    end

    /*
    This action offsets all of the text and line indices of this Block and the Blocks
    that are attached to it. If the change index is located after a Block's indices,
    they won't be modified.
    */
    action OffsetIndices(integer changeIndex, integer textChanged, integer linesChanged)
        OffsetIndices(changeIndex, textChanged, linesChanged, undefined)
    end

    /*
    This action offsets all of the text and line indices of this Block and the Blocks
    that are attached to it. If the change index is located after a Block's indices,
    they won't be modified.

    The Block value represents the block that created the event that is causing the offset. This is used in certain cases such as when the offset comes
    from an EditRegion within a block. The reason this is used is because endpoints need to be handled differently depending on if it should affect a block
    or not. If a change comes from an EditRegion outside of a block then it should always process endpoints but a block can't alter it's own start index 
    through an EditRegion.
    */
    action OffsetIndices(integer changeIndex, integer textChanged, integer linesChanged, Block block)
        Block current = me
        boolean atStartOfFile = false
        if changeIndex < 0
            atStartOfFile = true
            changeIndex = 0
        end
        repeat until current = undefined
            integer counter = 0
            repeat while counter < current:GetChildCount()
                Block child = current:GetChild(counter)
                integer startIndex = child:GetStartIndex()
                integer endIndex = child:GetEndIndex()

                boolean atStartOfBlock = (IsOffendingBlock(child, block) and changeIndex = startIndex)
                boolean atEndOfBlock = (IsOffendingBlock(child, block) and changeIndex = endIndex)

                // if the change is before the end of the block something has to change
                if changeIndex < endIndex 
                    // if the change is inside the block offset relative
                    if changeIndex > startIndex or atStartOfBlock
                        child:OffsetRelativeIndices(changeIndex - startIndex, textChanged)
                    else
                        // if the change is before the start only the local start moves
                        child:SetLocalStartIndex(child:GetLocalStartIndex() + textChanged)
                    end
                    child:SetLocalEndIndex(child:GetLocalEndIndex() + textChanged)
                elseif atEndOfBlock
                    child:OffsetRelativeIndices(changeIndex - startIndex, textChanged)
                    child:SetLocalEndIndex(child:GetLocalEndIndex() + textChanged)
                elseif changeIndex = startIndex and changeIndex = 0 and atStartOfFile
                    // special case where the change is at the beginning (new line from top)
                    // other cases you assume the change is after the block if the indicies conflict
                    child:SetLocalStartIndex(child:GetLocalStartIndex() + textChanged)
                    child:SetLocalEndIndex(child:GetLocalEndIndex() + textChanged)
                end

                // Only process line indices if the number of lines changed.
                // Also, don't do it if there's no offending block and our start/end indices are identical.
                // This resolves an edge case when adding a new line to the end of an empty freeform block.
                if linesChanged not= 0 and not (IsOffendingBlock(child, block) = false and (changeIndex = endIndex) and not atStartOfFile)
                    integer startLine = child:GetLocalStartLine()
                    integer endLine = child:GetLocalEndLine()

                    if changeIndex < endIndex or atEndOfBlock
                        child:SetLocalEndLine(endLine + linesChanged)
                    end
                    if changeIndex <= startIndex
                        if atStartOfBlock
                            // don't modify the start line in this case
                        else
                            child:SetLocalStartLine(startLine + linesChanged)
                        end
                    end

                end

                counter = counter + 1
            end

            Block parentBlock = current:GetParentBlock()
            if parentBlock = undefined
                /*
                The last block is the root, and it must be handled specially.
                Since it doesn't have a parent, if we exit from the loop normally,
                it'll never be affected. We just need to offset the end by the changed amount
                (as the root block always starts at 0 and encompasses the whole text).
                */
                current:SetLocalEndIndex(current:GetLocalEndIndex() + textChanged)
                current:SetLocalEndLine(current:GetLocalEndLine() + linesChanged)
            end

            current = parentBlock
        end
    end


    /* 
        Used by OffsetIndices to check if a block is the block causing the change. This result is used to process endpoints correctly.
        If a block is the same block as the offender it returns true but it also returns true if the offending block is a block part
        of the given block.
    */
    private action IsOffendingBlock(Block block, Block offender) returns boolean
        if offender = undefined
            return false
        elseif block = offender
            return true
        elseif offender is MultipleLineBlockPart and block = offender:GetParentBlock()
            return true
        end
        return false
    end

    /*
    Used to adjust relative indices within the Block, most commonly for EditRegions.
    By default this iterates over the block's children and adjusts the found EditRegions,
    but this can be overridden for custom adjustment of element vertices if needed.
    */
    private action OffsetRelativeIndices(integer index, integer amount)
        Array<Item2D> children = GetChildren()
        integer counter = 0
        repeat while counter < children:GetSize()
            Item2D child = children:Get(counter)
            if child is EditRegion
                EditRegion region = cast(EditRegion, child)

                integer startIndex = region:GetStartIndex()
                if index < startIndex
                    region:SetStartIndex(startIndex + amount)
                end

                integer endIndex = region:GetEndIndex()
                if index <= endIndex
                    region:SetEndIndex(endIndex + amount)
                end
            end
            counter = counter + 1
        end
    end

    action GetScopeDepth returns integer
        return scopeDepth
    end

    action SetScopeDepth(integer depth)
        me:scopeDepth = depth
    end

    action GetTopNotchPosition returns number
        BlockEnvironment environment = GetBlockEnvironment()
        if environment = undefined
            return 0
        end

        return environment:GetScopeIndentationWidth() * topNotchPositionFactor
    end

    action GetBottomNotchPosition returns number
        BlockEnvironment environment = GetBlockEnvironment()
        if environment = undefined
            return 0
        end

        return environment:GetScopeIndentationWidth() * bottomNotchPositionFactor
    end

    action UseEnterScopeStyling
        topNotchPositionFactor = 1
        bottomNotchPositionFactor = 2
        SetBottomLeftPixelRounding(0)
    end

    action UseExitScopeStyling
        topNotchPositionFactor = 2
        bottomNotchPositionFactor = 1
        SetTopLeftPixelRounding(0)
    end

    action UseEnterAndExitScopeStyling
        topNotchPositionFactor = 2
        bottomNotchPositionFactor = 2
        SetTopLeftPixelRounding(0)
        SetBottomLeftPixelRounding(0)
    end

    action UseNeutralScopeStyling
        topNotchPositionFactor = 1
        bottomNotchPositionFactor = 1
    end

    action IsEnteringScope returns boolean
        return bottomNotchPositionFactor > 1
    end

    action IsExitingScope returns boolean
        return topNotchPositionFactor > 1
    end

    action GetEditor returns CodeEditor
        if environment is CodeEditor
            return cast(CodeEditor, environment)
        end

        return undefined
    end
    
    action GetBlockEnvironment returns BlockEnvironment
        return environment
    end
    
    action SetBlockEnvironment(BlockEnvironment environment)
        me:environment = environment
    end

    action GetColorName returns text
        text colorName = ""
        ColorNamer namer
        Color color = cast(Color, GetBackgroundColor())
        colorName = namer:GetName(color:GetRed(), color:GetGreen(), color:GetBlue())
        return colorName
    end

    action Setup
        if IsPlaceholder()
            SetupPlaceholderElements(placeholderText)
        else
        SetupElements()
        SetDefaultTabOrder()

        // Set the default name to reflect the first line of the block.
        UpdateName(0)
        end
        
    end

    private blueprint action SetupElements
    
    private action SetupPlaceholderElements(text code)
        
        BlockEnvironment editor = GetBlockEnvironment()
        if editor is BlockPaletteItem
            BlockPaletteItem item = cast(BlockPaletteItem, editor)
            if item:GetEditor() not= undefined
editor = item:GetEditor()
            end
        end
        
        if editor = undefined
            return now
        end
        
        number spacing = editor:GetDefaultGlyphWidth()
        SetLeftPadding(spacing * 0.5)
        SetRightPadding(spacing * 0.5)
        
        if placeholderControls not= undefined
            integer i = 0
            repeat while i < placeholderControls:GetSize()
                Item2D child = placeholderControls:Get(i)
                if child is EditRegion
                    EditRegion region = cast(EditRegion, child)
                    region:SetFont(editor:GetFont())
                    region:SetFontSize(editor:GetFontSize())
                    Add(region)
                    
                    region:SetupAsPlaceholder(region:GetName(), region:GetText())
                elseif child is BlockLabel
                    BlockLabel label = cast(BlockLabel, child)
                    label:SetFont(GetLabelFont())
                    label:SetFontSize(editor:GetFontSize())
                    Add(label)
                elseif child is Label
                    Add(child)
                end
                i = i + 1
            end
        else
            BlockLabel label
            label:SetFont(editor:GetFont())
            label:SetFontSize(editor:GetFontSize())
            label:SetText(code)
            Add(label)
        end
    end

    blueprint action UpdateName(integer selectedLine)

    action GetNextBlock returns Block
        if GetChildCount() > 0
            return GetChild(0)
        end

        Block currentParent = me
        repeat until currentParent = undefined
            Block candidate = currentParent:GetNextSibling()
            if candidate not= undefined
                return candidate
            end

            currentParent = currentParent:GetParentBlock()
        end

        return undefined
    end

    action GetPreviousBlock returns Block
        Block sibling = GetPreviousSibling()
        if sibling not= undefined
            repeat while sibling:GetChildCount() > 0
                sibling = sibling:GetChild(sibling:GetChildCount()-1)
            end
            return sibling
        end

        return parentBlock
    end

    action GetNextRenderableBlock returns Block
        Block block = GetNextBlock()
        if block not= undefined and block:IsDirectlyRenderable() = false
            return block:GetNextRenderableBlock()
        else
            return block
        end
    end

    action GetNextNavigableBlock returns Block
        Block block = GetNextBlock()
        if block not= undefined and block:IsNavigable() = false
            return block:GetNextNavigableBlock()
        else
            return block
        end
    end

    action GetPreviousRenderableBlock returns Block
        Block block = GetPreviousBlock()
        if block not= undefined and block:IsDirectlyRenderable() = false
            return block:GetPreviousRenderableBlock()
        else
            return block
        end
    end

    action GetPreviousNavigableBlock returns Block
        Block block = GetPreviousBlock()
        if block not= undefined and block:IsNavigable() = false
            return block:GetPreviousNavigableBlock()
        else
            return block
        end
    end

    action GetNextSibling returns Block
        if parentBlock = undefined or parentBlock:GetChildCount() <= (parentIndex + 1)
            return undefined
        end

        return parentBlock:GetChild(parentIndex + 1)
    end

    action GetPreviousSibling returns Block
        if parentBlock = undefined or parentIndex <= 0
            return undefined
        end

        return parentBlock:GetChild(parentIndex - 1)
    end

    /*
    This action returns the last focusable block item in the Block.
    This is typically the last BlockItem in the tab order as well.
    */
    action GetLastBlockItem returns BlockItem
        // When the next block is set, make the last BlockItem point to it, if it doesn't already have a focus target.
        Array<Item2D> children = GetChildren()

        integer i = children:GetSize()
        repeat while i > 0
            i = i - 1
            Item2D current = children:Get(i)
            if current is BlockItem and current:IsFocusable()
                return cast(BlockItem, current)
            end
        end

        return undefined
    end

    action GetEnclosingBlock returns Block
        return enclosingBlock
    end

    action SetEnclosingBlock(Block enclosingBlock)
        me:enclosingBlock = enclosingBlock
    end

    action SetDefaultTabOrder
        Array<Item2D> children = GetChildren()

        BlockItem previous = undefined

        integer i = 0
        repeat while i < children:GetSize()
            Item2D current = children:Get(i)
            if current is BlockItem and current:IsFocusable()
                BlockItem item = cast(BlockItem, current)
                if previous not= undefined
                    previous:SetNextFocus(item)
                    item:SetPreviousFocus(previous)
                else
                    SetNextFocus(item)
                    item:SetPreviousFocus(me)
                end
                previous = item
            end

            i = i + 1
        end
    end

    action GainedSelection
        CodeEditor editor = GetEditor()
        CodeEditorSelection selection = editor:GetSelection()

        if selection:GetBlockItem() = undefined
            if editor:ContainsFocus()
                integer line = selection:GetLine() - GetStartLine()
                UpdateName(line)
                Focus()
            end
            
            if IsFastEditable()
                EditRegion region = GetStartingEditRegion()
                if region not= undefined
                    region:ShowCaret()
                end
            end
        end

        parent:Control:GainedSelection()
    end
    
    action LostSelection
        CodeEditor editor = GetEditor()
        if editor not= undefined
            CodeEditorSelection selection = editor:GetSelection()
            if selection:GetBlock() not= me and IsFastEditable()
                EditRegion region = GetStartingEditRegion()
                if region not= undefined
                    region:HideCaret()
                end
            end
        end

        parent:Control:LostSelection()
    end
    
    action GetStartingEditRegion returns EditRegion
        BlockItem firstItem = undefined
        Array<Item2D> children = GetChildren()
        integer i = 0
        repeat while firstItem = undefined and i < children:GetSize()
            Item2D item = children:Get(i)
            if item is BlockItem
                firstItem = cast(BlockItem, item)
            end
            i = i + 1
        end
        
        if firstItem is EditRegion
            EditRegion region = cast(EditRegion, firstItem)
            return region
        end
        
        return undefined
    end

    action SetContext(ParseContext context)
        me:context = context
        InitializeLocalIndices()
    end

    action GetContext returns ParseContext
        return context
    end

    action GetParentIndex returns integer
        return parentIndex
    end

    action SetParentIndex(integer parentIndex)
        me:parentIndex = parentIndex
    end

    action GetParentBlock returns Block
        return parentBlock
    end

    action SetParentBlock(Block parentBlock)
        me:parentBlock = parentBlock
//        if parentBlock not= undefined and parentBlock:GetEditor() not= editor
//            SetEditor(parentBlock:GetEditor())
//        end

        if parentBlock not= undefined and parentBlock:GetBlockEnvironment() not= GetBlockEnvironment()
            SetBlockEnvironment(parentBlock:GetBlockEnvironment())
        end

        InitializeLocalIndices()
    end

    private action InitializeLocalIndices
        // Check if we have a valid context and parent block, but the start index hasn't been set yet.
        if context not= undefined and parentBlock not= undefined and startIndex < 0
            // Set our starting local values using the context and parent.
            SetLocalStartIndex(context:GetLocation():GetIndex() - parentBlock:GetStartIndex())
            SetLocalEndIndex(context:GetLocation():GetIndexEnd() + 1 - parentBlock:GetStartIndex())
            SetLocalStartLine(context:GetLocation():GetLineNumber() - 1 - parentBlock:GetStartLine())
            SetLocalEndLine(context:GetLocation():GetLineNumberEnd() - 1 - parentBlock:GetStartLine())
        end
    end

    /*
    Returns true if this block can be navigated to, or false otherwise.
    */
    action IsNavigable returns boolean
        return true
    end

    /*
    Returns true if this block can be rendered directly, or false otherwise.
    If this is false, either the item shouldn't be rendered (RootBlock) or should
    be rendered by a parent object (MultpleLineBlockParts).
    */
    action IsDirectlyRenderable returns boolean
        return true
    end

    /*
        Special operations need to be taken for the system here
        because the description needs to be changed before getting the focus.

    */ 
    action Focus
        GameStateManager manager
        Accessibility access = manager:GetAccessibility()
        if access not= undefined
            access:NameChanged(me)
            access:DescriptionChanged(me)
        end
        //now finally set the focus
        manager:GetGame():SetFocus(me)
    end

    action GainedFocus(FocusEvent event)
        CodeEditor editor = GetEditor()
        if editor not= undefined
            editor:OnFocusChange(event)
        end
    end
    
    action LostFocus(FocusEvent event)
        CodeEditor editor = GetEditor()
        if editor not= undefined
            editor:OnFocusLoss(event)
        end
    end

    action GetText returns text
        check
            return GetBlockEnvironment():GetCodeBetween(GetStartIndex(), GetEndIndex())
        detect error
            return undefined
        end

        return undefined
    end

    /*

    */
    action GetMinimumWidth returns number
        BlockEnvironment editor = GetBlockEnvironment()
        if editor not= undefined
            number minimumWidth = GetTopNotchPosition()
            if GetBottomNotchPosition() > minimumWidth
                minimumWidth = GetBottomNotchPosition()
            end
            minimumWidth = minimumWidth + (editor:GetBlockNotchTopWidth() + GetRightPadding()) * GetInterfaceScale()
            return minimumWidth
        end

        return 0
    end

    /*
    This action determines if this Block is currently present in its CodeEditor's block hierarchy.
    If this returns false, it's most likely because it was removed or because the CodeEditor has
    regenerated its blocks.
    */
    action IsInEditorTree returns boolean
        CodeEditor editor = GetEditor()
        if editor = undefined
            return false
        end

        RootBlock root = GetRootBlock()
        if root = undefined
            return false
        end

        // Only the RootBlock can be a valid part of the tree with a negative parent index.
        if not (me is RootBlock) and GetParentIndex() < 0
            return false
        end

        return editor:GetRootBlock() = root
    end

    action GetRootBlock returns RootBlock
        Block candidate = me
        repeat until candidate is RootBlock or candidate = undefined
            candidate = candidate:GetParentBlock()
        end

        return cast(RootBlock, candidate)
    end
    
    action IsFastEditable returns boolean
        return false
    end
    
    action IsSelected returns boolean
        CodeEditor editor = GetEditor()
        if editor not= undefined
            CodeEditorSelection selection = editor:GetSelection()
            integer startIndex = selection:GetLine()
            integer endIndex = selection:GetRangeEndLine()
            if startIndex > endIndex
                integer temp = startIndex
                startIndex = endIndex
                endIndex = temp
            end
            // Only navigable blocks can be selected. Use that plus navigation indices to check for selection.
            return IsNavigable() and GetNavigationIndex() <= endIndex and GetNavigationEndIndex() >= startIndex

        end
        
        return false
    end
    
    // This action returns true if this Block is both selected and where the cursor is located.
    // This doesn't necessarily imply that there isn't a BlockItem within the block that's also selected, though.
    action IsCursorSelected returns boolean
        CodeEditor editor = GetEditor()
        if editor not= undefined
            CodeEditorSelection selection = editor:GetSelection()
            return selection:GetBlock() = me
        end
        
        return false
    end
    
action Draw(Painter2D painter)
        if not IsShowing()
            return now
        end

        if parent:Item2D:visualView not= undefined
            parent:Item2D:visualView:Draw(painter)
        end
    end
    
action DrawContents(Painter2D painter)
        if not IsShowing()
            return now
        end

        integer counter = 0
        Array<Item2D> children = GetChildren()
        repeat while counter < children:GetSize()
            children:Get(counter):Draw(painter)
            counter = counter + 1
        end
    end
    
action IsAccessibleParent returns boolean
        return true
    end
    
    // Indicates if this block is currently moving (e.g. being dragged with the mouse)
    action SetMoving(boolean moving)
        isMoving = moving
    end
    
    action IsMoving returns boolean
        return isMoving
    end
    
    // This action indicates if the given placeholder blocks can be placed under this block.
    // For example, if this is a block that's currently moving, it won't accept any placeholders.
    action CanAcceptPlaceholders returns boolean
        return isMoving = false
    end
    
    /*This action returns false if the given placeholder would be an error in the code if it is placed under this block,
or true otherwise. This doesn't indicate whether or not the placeholder is allowed to be placed there or not -- for
that information, use CanAcceptPlaceholders().*/
    action IsPlaceholderValid(Block block) returns boolean
        return true
    end
    
    action IsPlaceholder returns boolean
        return isPlaceholder
    end
    
    /*This action sets the block as a placeholder. It will visually appear as a block with a single label containing
the provided code. For more specific visuals, use SetAsPlaceholder(text, Array<Item2D>).*/
    action SetAsPlaceholder(text code)
        SetAsPlaceholder(code, undefined)
    end
    
    /*This action sets the block as a placeholder. The actual appearance will be dictated by the given controls.
    This action will make a COPY of each of the provided elements. It does not store the original elements or
    maintain a shallow copy of the given array.
    
    Because the given controls supply the visuals, the code will not be used visually, but must still correctly
    match the code the block represents, because it will be used if the placeholder is converted to a real block.*/
    action SetAsPlaceholder(text code, Array<Item2D> controls)
        isPlaceholder = true
        placeholderText = code
        
        if controls not= undefined
            BlockEnvironment editor = GetBlockEnvironment()
            number spacing = 10
            if editor not= undefined
spacing = editor:GetDefaultGlyphWidth()
            elseif GetFont() not= undefined
                // As a fallback, use the width of a character from the font. Arbitrary if the font is monospaced, which it usually is. Otherwise, "W" is usually a wide character.
                spacing = editor:GetFont():GetGlyph("W"):horizontalAdvance
            end
            SetLeftPadding(spacing * 0.5)
            SetRightPadding(spacing * 0.5)
                
            Array<Item2D> newArray
            placeholderControls = newArray
            integer i = 0
            repeat while i < controls:GetSize()
                Item2D child = controls:Get(i)
                if child is EditField
                    EditField field = cast(EditField, child)
                    EditField newField
                    newField:SetName(field:GetName())
                    newField:SetText(field:GetText())
                    newField:SetLeftPadding(field:GetLeftPadding())
                    newField:SetRightPadding(field:GetRightPadding())
                    newField:SetInputGroup("")
                    
placeholderControls:Add(newField)
                    
                    Array<Label> topLabels = field:GetTopLabels()
                    Array<Label> bottomLabels = field:GetBottomLabels()
                    if topLabels not= undefined
                        integer counter = 0
                        repeat while counter < topLabels:GetSize()
                            Label label = topLabels:Get(counter)
                            Label newLabel
                            newLabel:SetName(label:GetName())
                            newLabel:SetText(label:GetText())
                            newLabel:SetFont(label:GetFont())
                            newLabel:SetFontSize(label:GetFontSize())
                            newLabel:SetInterfaceOptionsKey(label:GetInterfaceOptionsKey())
                            newLabel:SetFontColor(label:GetFontColor())
                            newLabel:SetInterfaceScale(label:GetInterfaceScale())
newLabel:SetPositionOnBaseLine(label:IsPositioningOnBaseLine())
            newLabel:SetBottomMargin(label:GetBottomMargin())
                            if label:IsShowing() = false
                                newLabel:Hide()
                            end
                            newField:AddTopLabel(newLabel)
                            placeholderControls:Add(newLabel)
                            
                            counter = counter + 1
                        end
                    end
if bottomLabels not= undefined
                        integer counter = 0
                        repeat while counter < bottomLabels:GetSize()
                            Label label = bottomLabels:Get(counter)
                            Label newLabel
                            newLabel:SetName(label:GetName())
                            newLabel:SetText(label:GetText())
                            newLabel:SetFont(label:GetFont())
                            newLabel:SetFontSize(label:GetFontSize())
                            newLabel:SetInterfaceOptionsKey(label:GetInterfaceOptionsKey())
                            newLabel:SetFontColor(label:GetFontColor())
                            newLabel:SetInterfaceScale(label:GetInterfaceScale())
newLabel:SetPositionOnBaseLine(label:IsPositioningOnBaseLine())
            newLabel:SetTopMargin(label:GetTopMargin())
                            if label:IsShowing() = false
                                newLabel:Hide()
                            end
                            newField:AddBottomLabel(newLabel)
                            placeholderControls:Add(newLabel)
                            
                            counter = counter + 1
                        end
                    end
                elseif child is EditBox
                    EditBox box = cast(EditBox, child)
                    EditBox newBox
                    newBox:SetName(box:GetName())
                    newBox:SetText(box:GetText())
                    newBox:SetLeftPadding(box:GetLeftPadding())
                    newBox:SetRightPadding(box:GetRightPadding())
                    newBox:SetInputGroup("")
                    
placeholderControls:Add(newBox)
                    
Array<Label> topLabels = box:GetTopLabels()
                    Array<Label> bottomLabels = box:GetBottomLabels()
                    if topLabels not= undefined
                        integer counter = 0
                        repeat while counter < topLabels:GetSize()
                            Label label = topLabels:Get(counter)
                            Label newLabel
                            newLabel:SetName(label:GetName())
                            newLabel:SetText(label:GetText())
                            newLabel:SetFont(label:GetFont())
                            newLabel:SetFontSize(label:GetFontSize())
                            newLabel:SetInterfaceOptionsKey(label:GetInterfaceOptionsKey())
                            newLabel:SetFontColor(label:GetFontColor())
                            newLabel:SetInterfaceScale(label:GetInterfaceScale())
newLabel:SetPositionOnBaseLine(label:IsPositioningOnBaseLine())
            newLabel:SetBottomMargin(label:GetBottomMargin())
if label:IsShowing() = false
                                newLabel:Hide()
                            end
                            newBox:AddTopLabel(newLabel)
placeholderControls:Add(newLabel)
                            
                            counter = counter + 1
                        end
                    end
if bottomLabels not= undefined
                        integer counter = 0
                        repeat while counter < bottomLabels:GetSize()
                            Label label = bottomLabels:Get(counter)
                            Label newLabel
                            newLabel:SetName(label:GetName())
                            newLabel:SetText(label:GetText())
                            newLabel:SetFont(label:GetFont())
                            newLabel:SetFontSize(label:GetFontSize())
                            newLabel:SetInterfaceOptionsKey(label:GetInterfaceOptionsKey())
                            newLabel:SetFontColor(label:GetFontColor())
                            newLabel:SetInterfaceScale(label:GetInterfaceScale())
newLabel:SetPositionOnBaseLine(label:IsPositioningOnBaseLine())
            newLabel:SetTopMargin(label:GetTopMargin())
if label:IsShowing() = false
                                newLabel:Hide()
                            end
                            newBox:AddBottomLabel(newLabel)
placeholderControls:Add(newLabel)
                            
                            counter = counter + 1
                        end
                    end
                elseif child is BlockLabel
                    BlockLabel label = cast(BlockLabel, child)
                    BlockLabel newLabel
                    newLabel:SetText(label:GetText())
                    newLabel:SetLeftPadding(label:GetLeftPadding())
                    newLabel:SetRightPadding(label:GetRightPadding())
                        
                    placeholderControls:Add(newLabel)
                end
                
                i = i + 1
            end
        end
        
    end
    
    action GetPlaceholderText returns text
        if placeholderText = undefined
            return "Placeholder"
        end
        return placeholderText
    end
    
    // Makes a copy of this block as a placeholder. Used for operatings like dragging blocks to show previews.
    action CopyToPlaceholder returns Block
        integer i = 0
        Array<Item2D> children = GetChildren()
        
        //The actual type of block is irrelevant, as the placeholder calls will supersede anything it would do. 
        ActionCallBlock placeholder
        placeholder:SetInterfaceOptionsKey(GetInterfaceOptionsKey())
        placeholder:SetInterfaceScale(GetInterfaceScale())
        placeholder:SetBlockEnvironment(GetBlockEnvironment())
        placeholder:SetAsPlaceholder(GetText(), children)
        placeholder:SetScopeDepth(GetScopeDepth())
        
        if topNotchPositionFactor = 2
            if bottomNotchPositionFactor = 2
                placeholder:UseEnterAndExitScopeStyling()
            else
                placeholder:UseExitScopeStyling()
            end
        elseif bottomNotchPositionFactor = 2
            placeholder:UseEnterScopeStyling()
        end
        
        if me is SingleLineBlock
            SingleLineBlock singleBlock = cast(SingleLineBlock, me)
            placeholder:SetAlwaysShowDetailLabels(singleBlock:AlwaysShowDetailLabels())
        end
        
        placeholder:Setup()
        return placeholder
    end
    
    action IsRenderingSelection returns boolean
        if GetParent() is BlockPaletteItem
            if GetParent():IsFocused()
                return true
            end
        end
        
        return parent:Control:IsRenderingSelection()
    end
    
    /* This action returns the font that is used for labels on this Block.
This is usually whatever font is attached to the BlockEnvironment,
especially if it's a CodeEditor, but in some cases it might be fetched
from elsewhere. For example, BlockPaletteItems don't use their own font,
but instead use the font of the associated Editor, if there is one. */
    action GetLabelFont returns Font
        BlockEnvironment source = GetBlockEnvironment()
        if source is BlockPaletteItem
            BlockPaletteItem item = cast(BlockPaletteItem, source)
            if item:GetEditor() not= undefined
                source = item:GetEditor()
            end
        end
        
        return source:GetFont()
    end
    
end