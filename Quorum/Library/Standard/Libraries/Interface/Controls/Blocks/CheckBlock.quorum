package Libraries.Interface.Controls.Blocks

use Libraries.Interface.Controls.CodeEditor
use Libraries.Interface.Controls.Blocks.Controls.EditField
use Libraries.Interface.Controls.Blocks.Controls.BlockLabel
use Libraries.Interface.Options.BlockOptionConstants
use Libraries.Interface.Controls.Blocks.Layouts.ScopeBlockLayout
use Libraries.Language.Compile.Context.all
use Libraries.Language.Compile.Location
use Libraries.Interface.Controls.Blocks.Layouts.MultipleLineBlockLayout
use Libraries.Containers.Array
use Libraries.Interface.Events.TextChangeEvent
use Libraries.Containers.MultipleLineText

class CheckBlock is MultipleLineBlock
    BlockLabel checkLabel = undefined
    BlockLabel alwaysLabel = undefined
    BlockLabel endLabel = undefined

    Array<BlockLabel> detectLabels
    Array<EditField> detectNameFields
    Array<BlockLabel> detectIsLabels
    Array<EditField> detectExpressionFields

    MultipleLineBlockPart checkPart = undefined
    Array<MultipleLineBlockPart> detectParts
    MultipleLineBlockPart alwaysPart = undefined
    MultipleLineBlockPart endPart = undefined

    CheckContext checkContext

    on create
        BlockOptionConstants constants
        SetInterfaceOptionsKey(constants:CHECK_KEY)

        MultipleLineBlockLayout layout
        SetLayout(layout)

        SetName("Check Block")
    end

    action SetupElements
        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()
        SetLeftPadding(spacing * 0.5)
        SetRightPadding(spacing * 0.5)
    end

    action AddStartLine returns MultipleLineBlockPart
        MultipleLineBlockPart part
        Add(part)
        part:UseEnterScopeStyling()

        // The start line is always the beginning of the multi-block, so it always starts at local index 0.
        part:SetLocalStartIndex(0)

        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()

        BlockLabel checkLabel
        me:checkLabel = checkLabel
        checkLabel:SetFont(GetEditor():GetFont())
        checkLabel:SetFontSize(GetEditor():GetFontSize())
        checkLabel:SetText("check")
        part:Add(checkLabel)

        // The end index is the same as the length of the label text, since we start from 0.
        part:SetLocalEndIndex(checkLabel:GetSize())
        me:checkPart = part
        return part
    end

    action AddDetectLine(DetectStatementContext detectContext) returns MultipleLineBlockPart
        MultipleLineBlockPart part
        Add(part)
        part:UseEnterAndExitScopeStyling()

        part:SetLocalStartIndex(detectContext:GetLocation():GetIndex() - GetStartIndex())
        part:SetLocalStartLine(detectContext:GetLocation():GetLineNumber() - GetStartLine() - 1)

        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()

        BlockLabel detectLabel
        me:detectLabels:Add(detectLabel)
        detectLabel:SetFont(GetEditor():GetFont())
        detectLabel:SetFontSize(GetEditor():GetFontSize())
        detectLabel:SetText("detect")
        detectLabel:SetRightPadding(spacing)
        part:Add(detectLabel)

        
        EditField nameField
        me:detectNameFields:Add(nameField)
        part:Add(nameField)

        nameField:Setup("Name", detectContext:nameLocation:GetIndex() - (GetStartIndex() + part:GetLocalStartIndex()), detectContext:nameLocation:GetIndexEnd() + 1 - (GetStartIndex() + part:GetLocalStartIndex()))
        nameField:SetRightPadding(spacing)


        Location finalName = undefined
        if detectContext:qualifiedNameContexts not= undefined
            BlockLabel isLabel
            me:detectIsLabels:Add(isLabel)
            isLabel:SetFont(GetEditor():GetFont())
            isLabel:SetFontSize(GetEditor():GetFontSize())
            isLabel:SetText("is")
            isLabel:SetRightPadding(spacing)
            part:Add(isLabel)


            EditField expressionField
            me:detectExpressionFields:Add(expressionField)
            Array<QualifiedNameContext> nameList = detectContext:qualifiedNameContexts

            Location firstName = nameList:Get(0):GetLocation()
            Location lastName = nameList:Get(nameList:GetSize() - 1):GetLocation()
            finalName = lastName
            Location expressionLoc = detectContext:GetLocation()
            part:Add(expressionField)

            expressionField:Setup("Expression", firstName:GetIndex() - (GetStartIndex() + part:GetLocalStartIndex()), lastName:GetIndexEnd() + 1 - (GetStartIndex() + part:GetLocalStartIndex()))
        end
        
        part:SetLocalEndIndex(detectContext:GetLocation():GetIndexEnd() - GetStartIndex())
        me:detectParts:Add(part)
        return part
    end

    action AddAlwaysLine(AlwaysStatementContext context) returns MultipleLineBlockPart
        MultipleLineBlockPart part
        Add(part)
        part:UseEnterAndExitScopeStyling()
        part:SetLocalStartLine(context:GetLocation():GetLineNumber() - GetStartLine() - 1)

        part:SetLocalStartIndex(context:GetLocation():GetIndex() - GetStartIndex())

        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()

        BlockLabel alwaysLabel
        me:alwaysLabel = alwaysLabel
        alwaysLabel:SetFont(GetEditor():GetFont())
        alwaysLabel:SetFontSize(GetEditor():GetFontSize())
        alwaysLabel:SetText("always")
        part:Add(alwaysLabel)
        part:SetLocalEndIndex(part:GetLocalStartIndex() + alwaysLabel:GetSize())

        me:alwaysPart = part
        return part
    end

    action UpdateName(integer selectedLine)
//        if selectedLine = endLabel:GetRelativeLineIndex()
//            SetName("end")
//        else
//            //SetName("class " + nameField:GetText())
//        end
    end

   action RemoveChildBlock(Block block) returns boolean
        if block is MultipleLineBlockPart
            MultipleLineBlockPart blockPart = cast(MultipleLineBlockPart, block)
            if blockPart = checkPart
                RemoveCheckPart(blockPart)
            elseif detectParts:Has(blockPart)
                RemoveDetectPart(blockPart)
            elseif blockPart = alwaysPart
                RemoveAlwaysPart(blockPart)
            elseif blockPart = endPart
                RemoveEndPart(blockPart)
            end
            MultipleLineBlockPart part = cast(MultipleLineBlockPart, block)
            GetBlockParts():Remove(part)
            part:SetParentBlock(undefined)

            repeat until GetBlockConnectors():GetSize() <= GetBlockParts():GetSize() - 1
                GetBlockConnectors():RemoveFromEnd()
            end
        end

        return parent:Control:Remove(block)
    end

    action RemoveCheckPart(Block block)
        // a check detect makes no sense without a check and a detect can't be converted to a check so delete the whole thing
        GetEditor():DeleteBlockPreservingGrandchildren(me, GetParentBlock())
        output GetEditor():GetCode():GetText()
    end

    action RemoveDetectPart(Block block)
        if detectParts:GetSize() > 1
            RemoveMiddleBlockPart(block, block:GetPreviousSibling())
        else
        end
    end

    action RemoveAlwaysPart(Block block)
        RemoveMiddleBlockPart(block, block:GetPreviousSibling())
    end

    action RemoveEndPart(Block block)
        if detectParts:GetSize() = 1  and alwaysPart = undefined
            GetEditor():DeleteBlockPreservingGrandchildren(me, GetParentBlock())
            return now
        end

        // Just modify the text directly and refresh the blocks.
        MultipleLineText rawCode = GetEditor():GetCode()
        
        integer startLine = block:GetStartLine()

        // The end line is where the new end of the updated text will be, once we've deleted the text of the direct children
        integer endLine = block:GetEndLine() - block:GetChildCount()

        integer i = 0
        boolean modifyElseif = false
        boolean modifyElse = false
        integer linesToChange = 1
        text newExpression = ""
        i = GetChildCount()
        // grab the end line
        integer startIndex = block:GetStartIndex()
        integer targetIndex = rawCode:CharacterIndexFromLineIndex(rawCode:LineIndexFromCharacterIndex(startIndex))
        if targetIndex < 0
            targetIndex = 0
        end

        integer endIndex = block:GetEndIndex()
        integer lines = block:GetEndLine() - block:GetStartLine() + 1
        // Make sure we grab the new line separator
        endIndex = endIndex + rawCode:GetLineSeparator():GetSize()

        if endIndex > rawCode:GetSize()
            endIndex = rawCode:GetSize()
        end

        integer textSize = endIndex - targetIndex
        text endText = rawCode:GetText(targetIndex, endIndex)
        rawCode = rawCode:Delete(targetIndex, endIndex)

        Block lastChain = undefined
        lastChain = alwaysPart

        startIndex = lastChain:GetStartIndex()
        targetIndex = rawCode:CharacterIndexFromLineIndex(rawCode:LineIndexFromCharacterIndex(startIndex))
        if targetIndex < 0
            targetIndex = 0
        end

        endIndex = lastChain:GetEndIndex()
        lines = lastChain:GetEndLine() - lastChain:GetStartLine() + 1
        // Make sure we grab the new line separator
        endIndex = endIndex + rawCode:GetLineSeparator():GetSize()

        if endIndex > rawCode:GetSize()
            endIndex = rawCode:GetSize()
        end

        textSize = endIndex - targetIndex
        rawCode = rawCode:Delete(targetIndex, endIndex)
        rawCode = rawCode:Insert(targetIndex, endText)

        // Reduce the indentation for the remaining lines.
        i = startLine

//        repeat while i <= endLine
//            startIndex = updatedText:CharacterIndexFromLineIndex(i)
//            updatedText = updatedText:Delete(startIndex, startIndex + 4)
//            i = i + 1
//        end
//
        GetEditor():SetCode(rawCode)
        TextChangeEvent event
        event:Initialize(me, "", "", 0)
        GetEditor():OnTextChange(event, 0)
    end

private action RemoveMiddleBlockPart(Block block, Block newParent)
        MultipleLineText rawCode = GetEditor():GetCode()
        Array<Block> preservedChildren
        integer i = 0
        repeat while i < block:GetChildCount()
            preservedChildren:Add(block:GetChild(i))
            i = i + 1
        end

        // We'll have to correct the local indices and line numbers to match up with the new parent
        integer offset = block:GetStartIndex() - newParent:GetStartIndex()
        integer lineOffset = block:GetStartLine() - newParent:GetStartLine()
        integer startIndex = block:GetStartIndex()
    
        // Make sure we delete the whole line by grabbing any indentation whitespace
        integer targetIndex = rawCode:CharacterIndexFromLineIndex(rawCode:LineIndexFromCharacterIndex(startIndex))
        if targetIndex < 0
            targetIndex = 0
        end

        // Make sure we grab the new line separator
        integer endIndex = block:GetEndIndex() + rawCode:GetLineSeparator():GetSize()
        integer lines = block:GetEndLine() - block:GetStartLine() + 1

        if endIndex > rawCode:GetSize()
            endIndex = rawCode:GetSize()
        end

        integer textSize = endIndex - targetIndex
        text deletedText = rawCode:GetText(targetIndex, endIndex)

        integer index = block:GetParentIndex()

        i = GetChildCount() - 1
        repeat while i >= index
            Block child = GetChild(i)
            child:SetParentIndex(i)
            i = i - 1
        end
        block:SetParentIndex(-1)
        block:SetParentBlock(undefined)
        block:SetEditor(undefined)

        /*
        Call OffsetIndices on the parent. By passing false for the final parameter,
        existing blocks shouldn't try to incorporate index changes that fall exactly
        on their start/end boundaries.
        */
        OffsetIndices(targetIndex, -textSize, -lines, false)

        // Process a text change event. This will automatically update the MultipleLineText.
        TextChangeEvent event
        event:Initialize(me, "", deletedText, targetIndex)
        GetEditor():OnTextChange(event, 0)

        // We need to correct the offsets based on the size of the deleted text
        offset = offset - textSize
        lineOffset = lineOffset - lines

        // Now correct indices using our previously calculated offsets, and add them to the new parent
        i = 0    
        repeat while i < preservedChildren:GetSize()
            Block kid = preservedChildren:Get(i)
            integer startLine = kid:GetLocalStartLine()
            integer endLine = kid:GetLocalEndLine()
            kid:SetLocalStartIndex(kid:GetLocalStartIndex() + offset)
            kid:SetLocalEndIndex(kid:GetLocalEndIndex() + offset)
            kid:SetLocalStartLine(startLine + lineOffset)
            kid:SetLocalEndLine(endLine + lineOffset)
            newParent:Add(kid)
            
            i = i + 1
        end
    end


    action GetCheckContext returns CheckContext
        return checkContext
    end

    action SetContext(CheckContext checkContext)
        me:checkContext = checkContext
        SetContext(cast(ParseContext, checkContext))
    end

end