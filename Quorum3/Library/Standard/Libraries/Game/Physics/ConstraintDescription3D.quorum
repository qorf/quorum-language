package Libraries.Game.Physics

use Libraries.Compute.Vector3
use Libraries.Compute.Matrix3

/*
This class stores different constraint values between two rigid bodies or even
for one body, which all depends on which action you used to initialize/change
the values stored inside this ConstraintDescription3D.
*/
class ConstraintDescription3D 
    Vector3 linearJointAxis
    Vector3 aJ
    Vector3 bJ
    Vector3 minvJt0
    Vector3 minvJt1
    number diag = 0
    
    //constraint between two different rigid bodies
    action Initialize(Matrix3 world2A, Matrix3 world2B, Vector3 relativePosition1, 
                      Vector3 relativePosition2, Vector3 jointAxis, Vector3 inertiaInverseA,
                      number massInverseA, Vector3 inertiaInverseB, number massInverseB)
        linearJointAxis:Set(jointAxis)
        
        aJ:Set(relativePosition1):CrossProduct(linearJointAxis)
        world2A:Transform(aJ)
         
        bJ:Set(linearJointAxis)
        bJ:Scale(-1)
        Vector3 temp
        temp:Set(relativePosition2):CrossProduct(bJ)
        bJ:Set(temp)
        world2B:Transform(bJ)

        minvJt0:SetX(inertiaInverseA:GetX() * aJ:GetX())
        minvJt0:SetY(inertiaInverseA:GetY() * aJ:GetY())
        minvJt0:SetZ(inertiaInverseA:GetZ() * aJ:GetZ())
        minvJt1:SetX(inertiaInverseB:GetX() * bJ:GetX())
        minvJt1:SetY(inertiaInverseB:GetY() * bJ:GetY())
        minvJt1:SetZ(inertiaInverseB:GetZ() * bJ:GetZ())
        diag = massInverseA + minvJt0:DotProduct(aJ) + massInverseB + minvJt1:DotProduct(bJ)
    end

    //angular constraint between two rigid bodies
    action Initialize(Vector3 jointAxis, Matrix3 world2A, Matrix3 world2B, Vector3 inertiaInverseA, Vector3 inertiaInverseB)
        linearJointAxis:Set(0, 0, 0)
        
        aJ:Set(jointAxis)
        world2A:Transform(aJ)

        bJ:Set(jointAxis)
        bJ:Scale(-1)
        world2B:Transform(bJ)

        minvJt0:SetX(inertiaInverseA:GetX() * aJ:GetX())
        minvJt0:SetY(inertiaInverseA:GetY() * aJ:GetY())
        minvJt0:SetZ(inertiaInverseA:GetZ() * aJ:GetZ())
        minvJt1:SetX(inertiaInverseB:GetX() * bJ:GetX())
        minvJt1:SetY(inertiaInverseB:GetY() * bJ:GetY())
        minvJt1:SetZ(inertiaInverseB:GetZ() * bJ:GetZ())
        diag = minvJt0:DotProduct(aJ) + minvJt1:DotProduct(bJ)
    end

    //angular constraint between two rigid bodies
    action Initialize(Vector3 axisInA, Vector3 axisInB, Vector3 inertiaInverseA, Vector3 inertiaInverseB)
        linearJointAxis:Set(0, 0, 0)
        aJ:Set(axisInA)

        bJ:Set(axisInB)
        bJ:Scale(-1)

        minvJt0:SetX(inertiaInverseA:GetX() * aJ:GetX())
        minvJt0:SetY(inertiaInverseA:GetY() * aJ:GetY())
        minvJt0:SetZ(inertiaInverseA:GetZ() * aJ:GetZ())
        minvJt1:SetX(inertiaInverseB:GetX() * bJ:GetX())
        minvJt1:SetY(inertiaInverseB:GetY() * bJ:GetY())
        minvJt1:SetZ(inertiaInverseB:GetZ() * bJ:GetZ())
        diag = minvJt0:DotProduct(aJ) + minvJt1:DotProduct(bJ)
    end

    //constraint on one rigid body
    action Initialize(Matrix3 world2A, Vector3 relativePosition1, Vector3 relativePosition2,
                      Vector3 jointAxis, Vector3 inertiaInverseA, number massInverseA)
        linearJointAxis:Set(jointAxis)

        aJ:Set(relativePosition1):CrossProduct(jointAxis)
        world2A:Transform(aJ)

        bJ:Set(jointAxis)
        bJ:Scale(-1)
        Vector3 temp
        temp:Set(relativePosition2):CrossProduct(bJ)
        bJ:Set(temp)
        world2A:Transform(bJ)

        minvJt0:SetX(inertiaInverseA:GetX() * aJ:GetX())
        minvJt0:SetY(inertiaInverseA:GetY() * aJ:GetY())
        minvJt0:SetZ(inertiaInverseA:GetZ() * aJ:GetZ())     
        minvJt1:Set(0, 0, 0)
        diag = massInverseA + minvJt0:DotProduct(aJ)
    end

    action GetDiagonal returns number
        return diag
    end

    //return the non diagonal entries for two constraints on the same rigid body
    action GetNonDiagonal(ConstraintDescription3D descriptionB, number massInverseA) returns number
        ConstraintDescription3D jacA = me
        number lin = massInverseA * jacA:linearJointAxis:DotProduct(descriptionB:linearJointAxis)
        number ang = jacA:minvJt0:DotProduct(descriptionB:aJ)
        return lin + ang
    end

    //2 constraints shared by two different rigid bodies (ex. 2 contact points)
    action GetNonDiagonal(ConstraintDescription3D descriptionB, number massInverseA, number massInverseB) returns number
        ConstraintDescription3D jacA = me

        Vector3 lin
        lin:SetX(jacA:linearJointAxis:GetX() * descriptionB:linearJointAxis:GetX())
        lin:SetY(jacA:linearJointAxis:GetY() * descriptionB:linearJointAxis:GetY())
        lin:SetZ(jacA:linearJointAxis:GetZ() * descriptionB:linearJointAxis:GetZ())

        Vector3 ang0
        ang0:SetX(jacA:minvJt0:GetX() * descriptionB:aJ:GetX())
        ang0:SetY(jacA:minvJt0:GetY() * descriptionB:aJ:GetY())
        ang0:SetZ(jacA:minvJt0:GetZ() * descriptionB:aJ:GetZ())

        Vector3 ang1
        ang1:SetX(jacA:minvJt1:GetX() * descriptionB:bJ:GetX())
        ang1:SetY(jacA:minvJt1:GetY() * descriptionB:bJ:GetY())
        ang1:SetZ(jacA:minvJt1:GetZ() * descriptionB:bJ:GetZ())

        Vector3 lin0
        lin0:Set(lin):Scale(massInverseA)

        Vector3 lin1
        lin1:Set(lin):Scale(massInverseB)

        Vector3 sum
        sum:Set(ang0):Add(ang1):Add(lin0):Add(lin1)

        return sum:GetX() + sum:GetY() + sum:GetZ()        
    end

    action GetRelativeVelocity(Vector3 linearVelocityA, Vector3 angularVelocityA, Vector3 linearVelocityB, Vector3 angularVelocityB) returns number
        Vector3 linrel
        linrel:Set(linearVelocityA):Subtract(linearVelocityB)

        Vector3 angvela
        angvela:SetX(angularVelocityA:GetX() * aJ:GetX())
        angvela:SetY(angularVelocityA:GetY() * aJ:GetY())
        angvela:SetZ(angularVelocityA:GetZ() * aJ:GetZ())

        Vector3 angvelb
        angvelb:SetX(angularVelocityB:GetX() * bJ:GetX())
        angvelb:SetY(angularVelocityB:GetY() * bJ:GetY())
        angvelb:SetZ(angularVelocityB:GetZ() * bJ:GetZ())

        linrel:SetX(linrel:GetX() * linearJointAxis:GetX())
        linrel:SetY(linrel:GetY() * linearJointAxis:GetY())
        linrel:SetZ(linrel:GetZ() * linearJointAxis:GetZ())

        angvela:Add(angvelb)
        angvela:Add(linrel)

        number rel_vel2 = angvela:GetX() + angvela:GetY() + angvela:GetZ()
        return rel_vel2 + 0.000000119209290
    end
end