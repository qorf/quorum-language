package Libraries.Game.Physics.Joints
use Libraries.Compute.Vector2
use Libraries.Interface.Item2D
use Libraries.Game.Collision.PhysicsPosition2D
use Libraries.Compute.Math

class DistanceJoint is Joint2D
    Vector2 localAnchorA
    Vector2 localAnchorB
    number length = 1
    number frequency = 0
    number dampingRatio = 0

    Vector2 anchorA
    Vector2 anchorB
    
    on create
        parent:Joint2D:SetType(parent:Joint2D:DISTANCEJOINT)
        localAnchorA:Set(0, 0)
        localAnchorB:Set(0, 0)
    end


    number bias = 0
    
    //Solver shared data
    number gamma = 0
    number impulse = 0
    Math math
    

    //Solver temp data
    integer indexA = 0
    integer indexB = 0
    Vector2 u
    Vector2 rA
    Vector2 rB
    Vector2 localCenterA
    Vector2 localCenterB
    number inverseMassA = 0
    number inverseMassB = 0
    number inverseInertiaA = 0
    number inverseInertiaB = 0
    number mass = 0

    /* 
        This action initializes the items, local anchors, and the length based on the passed
        items, and the world anchor points.

        parameters:
        * first body
        * second body
        * world anchor on first body
        * world anchor on second body
    */
    action Initialize(Item2D itemA, Item2D itemB, Vector2 anchorA, Vector2 anchorB) 
        parent:Joint2D:itemA = itemA
        parent:Joint2D:itemB = itemB
        me:anchorA:Set(anchorA)
        me:anchorB:Set(anchorB)
        localAnchorA:Set(parent:Joint2D:itemA:GetLocalPoint(anchorA))
        localAnchorB:Set(parent:Joint2D:itemB:GetLocalPoint(anchorB))
        Vector2 distance
        distance:Set(anchorB):Subtract(anchorA)
        length = distance:Length()       
    end

    //double check the box2D manual for information on how this could be problematic
    action SetDistance(number distance)
        length = distance
    end

    action GetDistance() returns number
        return length
    end

    action SetFrequency(number hz)
        frequency = hz
    end

    action GetFrequency() returns number
        return frequency
    end

    action SetLength(number passedLength)
        length = passedLength
    end

    action GetLength() returns number
        return length
    end

    action SetDampingRatio(number ratio)
        dampingRatio = ratio
    end

    action GetDampingRatio() returns number
        return dampingRatio
    end

    action GetAnchorA()returns Vector2
        return parent:Joint2D:itemA:GetWorldPoint(localAnchorA)
    end

    action SetAnchorA(Vector2 anchor)
        localAnchorA:Set(parent:Joint2D:itemA:GetLocalPoint(anchor))
        anchorA:Set(anchor)
        Vector2 distance
        distance:Set(anchorB):Subtract(anchorA)
        length = distance:Length()  
    end

    action GetAnchorB() returns Vector2
        return parent:Joint2D:itemB:GetWorldPoint(localAnchorB)
    end

    action SetAnchorB(Vector2 anchor)
        localAnchorB:Set(parent:Joint2D:itemB:GetLocalPoint(anchor))
        anchorB:Set(anchor)
        Vector2 distance
        distance:Set(anchorB):Subtract(anchorA)
        length = distance:Length()  
    end

    action GetLocalAnchorA returns Vector2
        return localAnchorA
    end

    action GetLocalAnchorB returns Vector2
        return localAnchorB
    end
    
    action GetReactionForce(number inverseTimeStep) returns Vector2
        Vector2 reactionForce
        reactionForce:SetX(impulse * u:GetX() * inverseTimeStep)
        reactionForce:SetY(impulse * u:GetY() * inverseTimeStep)
        return reactionForce
    end

    action GetReactionTorque(number inverseTimeStep) returns number
        return 0
    end

    action InitializeVelocityConstraints (JointSolverData data)
        indexA = parent:Joint2D:itemA:GetCollisionGroupIndex()
        indexB = parent:Joint2D:itemB:GetCollisionGroupIndex()
        localCenterA:Set(parent:Joint2D:itemA:GetSweep():GetLocalCenter())
        localCenterB:Set(parent:Joint2D:itemB:GetSweep():GetLocalCenter())
        inverseMassA = parent:Joint2D:itemA:GetInverseMass()
        inverseMassB = parent:Joint2D:itemB:GetInverseMass()
        inverseInertiaA = parent:Joint2D:itemA:GetInverseInertia()
        inverseInertiaB = parent:Joint2D:itemB:GetInverseInertia()
        
        Vector2 positionA = data:GetPositions():Get(indexA)
        number angleA = data:GetAngles():Get(indexA)
        Vector2 linearVelocityA = data:GetLinearVelocities():Get(indexA)
        number angularVelocityA = data:GetAngularVelocities():Get(indexA)

        Vector2 positionB = data:GetPositions():Get(indexB)
        number angleB = data:GetAngles():Get(indexB)
        Vector2 linearVelocityB = data:GetLinearVelocities():Get(indexB)
        number angularVelocityB = data:GetAngularVelocities():Get(indexB)

        number sineA = math:Sine(angleA)
        number cosineA = math:Cosine(angleA)
        number sineB = math:Sine(angleB)
        number cosineB = math:Cosine(angleB)

        u:Set(localAnchorA):Subtract(localCenterA)
        rA:SetX(cosineA * u:GetX() - sineA * u:GetY())
        rA:SetY(sineA * u:GetX() + cosineA * u:GetY())

        u:Set(localAnchorB):Subtract(localCenterB)
        rB:SetX(cosineB * u:GetX() - sineB * u:GetY())
        rB:SetY(sineB * u:GetX() + cosineB * u:GetY())

        u:Set(positionB):Add(rB):Subtract(positionA):Subtract(rA)
        
        //handle singularities
        number localLength = u:Length()
        if (localLength > 0.005)
            u:SetX(u:GetX() * (1.0 / localLength))
            u:SetY(u:GetY() * (1.0 / localLength))
        else
            u:SetZero()
        end

        number crossAu = rA:CrossProduct(u)
        number crossBu = rB:CrossProduct(u)
        number inverseMass = inverseMassA + inverseInertiaA * crossAu * crossAu + inverseMassB + inverseInertiaB * crossBu * crossBu

        // Compute the effective mass matrix.
        if inverseMass not= 0
            mass = 1 / inverseMass
        else
            mass = 0
        end

        if frequency > 0
            number lengthDiff = localLength - length
            
            //frequency
            number omega = 2.0 * math:pi * frequency

            number dampingCoefficient = 2.0 * mass * dampingRatio * omega
            
            number springStiffness = mass * omega * omega
            
            //magic formulas
            number h = data:GetTimeStep():GetTimeStep()
            gamma = h * (dampingCoefficient + h * springStiffness)
            if gamma not= 0
                gamma = 1 / gamma
            else 
                gamma = 0
            end
            bias = lengthDiff * h * springStiffness * gamma
            
            inverseMass = inverseMass + gamma
            if inverseMass not= 0
                mass = 1 / inverseMass
            else
                mass = 0
            end
            
        else
            gamma = 0
            bias = 0
        end

        if data:GetTimeStep():IsWarmStarting()
            impulse = impulse * data:GetTimeStep():GetTimeStepRatio()
            Vector2 p 
            p:Set(u):Scale(impulse)
            
            linearVelocityA:SetX(linearVelocityA:GetX() - (inverseMassA * p:GetX()))
            linearVelocityA:SetY(linearVelocityA:GetY() - (inverseMassA * p:GetY()))
            angularVelocityA = angularVelocityA - (inverseInertiaA * rA:CrossProduct(p))

            linearVelocityB:SetX(linearVelocityB:GetX() + (inverseMassB * p:GetX()))
            linearVelocityB:SetY(linearVelocityB:GetY() + (inverseMassB * p:GetY()))
            angularVelocityB = angularVelocityB + (inverseInertiaB * rB:CrossProduct(p))

        else
            impulse = 0            
        end

        data:SetAngularVelocity(angularVelocityA, indexA)
        data:SetAngularVelocity(angularVelocityB, indexB)
    end

    action SolveVelocityConstraints(JointSolverData data)
        Vector2 linearVelocityA = data:GetLinearVelocities():Get(indexA)
        number angularVelocityA = data:GetAngularVelocities():Get(indexA)
        Vector2 linearVelocityB = data:GetLinearVelocities():Get(indexB)
        number angularVelocityB = data:GetAngularVelocities():Get(indexB)

        Vector2 vpA 
        Vector2 vpB
        
        //cdot = dot (u, v + cross(w, r))
        vpA:SetX(-angularVelocityA * rA:GetY())
        vpA:SetY(angularVelocityA * rA:GetX())
        vpA:Add(linearVelocityA)
        
        vpB:SetX(-angularVelocityB * rB:GetY())
        vpB:SetY(angularVelocityB * rB:GetX())
        vpB:Add(linearVelocityB)

        number cDot = u:DotProduct(vpB:Subtract(vpA))
        
        number localImpulse = -mass * (cDot + bias + gamma * impulse)
        impulse = impulse + localImpulse

        number px = localImpulse * u:GetX()
        number py = localImpulse * u:GetY()

        linearVelocityA:SetX(linearVelocityA:GetX() - (inverseMassA * px))
        linearVelocityA:SetY(linearVelocityA:GetY() - (inverseMassA * py))
        angularVelocityA = angularVelocityA - (inverseInertiaA * (rA:GetX() * py - rA:GetY() * px))

        linearVelocityB:SetX(linearVelocityB:GetX() + (inverseMassB * px))
        linearVelocityB:SetY(linearVelocityB:GetY() + (inverseMassB * py))
        angularVelocityB = angularVelocityB + (inverseInertiaB * (rB:GetX() * py - rB:GetY() * px))
 
        data:SetAngularVelocity(angularVelocityA, indexA)
        data:SetAngularVelocity(angularVelocityB, indexB)   
    end

    action SolvePositionConstraints(JointSolverData data) returns boolean
        if frequency > 0
            return true
        end

        Vector2 rALocal
        Vector2 rBLocal
        Vector2 uLocal
        
        Vector2 positionA = data:GetPositions():Get(indexA)
        number angleA = data:GetAngles():Get(indexA)
        Vector2 positionB = data:GetPositions():Get(indexB)
        number angleB = data:GetAngles():Get(indexB)

        number sineA = math:Sine(angleA)
        number cosineA = math:Cosine(angleA)
        number sineB = math:Sine(angleB)
        number cosineB = math:Cosine(angleB)

        uLocal:Set(localAnchorA):Subtract(localCenterA)
        rALocal:SetX(cosineA * uLocal:GetX() - sineA * uLocal:GetY())
        rALocal:SetY(sineA * uLocal:GetX() + cosineA * uLocal:GetY())

        uLocal:Set(localAnchorB):Subtract(localCenterB)
        rBLocal:SetX(cosineB * uLocal:GetX() - sineB * uLocal:GetY())
        rBLocal:SetY(sineB * uLocal:GetX() + cosineB * uLocal:GetY())

        uLocal:Set(positionB):Add(rBLocal):Subtract(positionA):Subtract(rALocal)
        
        number lengthLocal = uLocal:Length()
        uLocal:Normalize()
        
        number c = lengthLocal - length
        if c < -0.2 
            c = -0.2
        end
        if c > 0.2
            c = 0.2
        end
        
        number impulseLocal = -mass * c
        number px = impulseLocal * uLocal:GetX()
        number py = impulseLocal * uLocal:GetY()
        
        positionA:SetX(positionA:GetX() - (inverseMassA * px))
        positionA:SetY(positionA:GetY() - (inverseMassA * py))
        angleA = angleA - (inverseInertiaA * (rALocal:GetX() * py - rALocal:GetY() * px))

        positionB:SetX(positionB:GetX() + (inverseMassB * px))
        positionB:SetY(positionB:GetY() + (inverseMassB * py))
        angleB = angleB + (inverseInertiaB * (rBLocal:GetX() * py - rBLocal:GetY() * px))

        data:SetAngle(angleA, indexA)
        data:SetAngle(angleB, indexB)
        
        return math:AbsoluteValue(c) < 0.005           
    end
end
