package Libraries.Game.Physics.Joints

use Libraries.Game.Physics.CollisionSolverInformation3D
use Libraries.Game.Physics.all
use Libraries.Interface.Item3D
use Libraries.Containers.Array
use Libraries.Compute.Math  
use Libraries.Compute.Vector3  
use Libraries.Compute.Matrix3
use Libraries.Game.Physics.Joints.RotationalLimitMotor3D
use Libraries.Game.Physics.Joints.TranslationalLimitMotor3D   
use Libraries.Game.Physics.ConstraintDescription3D
use Libraries.Game.Collision.PhysicsPosition3D
use Libraries.Compute.Quaternion


//allows the body to rotate around one axis and translate along this axis
//may not be possible because shapes are not hollow
class SliderJoint3D is Joint3D
    public constant number SLIDER_CONSTRAINT_DEF_SOFTNESS    = 1.0
    public constant number SLIDER_CONSTRAINT_DEF_DAMPING     = 1.0
    public constant number SLIDER_CONSTRAINT_DEF_RESTITUTION = 0.7

    Math math


    PhysicsPosition3D frameInA
    PhysicsPosition3D frameInB
    // use frameA fo define limits, if true
    boolean useLinearReferenceFrameA = false
    // linear limits
    number lowerLinLimit = 0
    number upperLinLimit = 0
    // angular limits
    number lowerAngLimit = 0
    number upperAngLimit = 0
    // softness, restitution and damping for different cases
    // DirLin - moving inside linear limits
    // LimLin - hitting linear limit
    // DirAng - moving inside angular limits
    // LimAng - hitting angular limit
    // OrthoLin, OrthoAng - against constraint axis
    number softnessDirLin = 0
    number restitutionDirLin = 0
    number dampingDirLin = 0
    number softnessDirAng = 0
    number restitutionDirAng = 0
    number dampingDirAng = 0
    number softnessLimLin = 0
    number restitutionLimLin = 0
    number dampingLimLin = 0
    number softnessLimAng = 0
    number restitutionLimAng = 0
    number dampingLimAng = 0
    number softnessOrthoLin = 0
    number restitutionOrthoLin = 0
    number dampingOrthoLin = 0
    number softnessOrthoAng = 0
    number restitutionOrthoAng = 0
    number dampingOrthoAng = 0

    // for interlal use
    boolean solveLinLim = false
    boolean solveAngLim = false


    number timeStep = 0
    PhysicsPosition3D calculatedTransformA 
    PhysicsPosition3D calculatedTransformB 

    Vector3 sliderAxis  
    Vector3 realPivotAInW  
    Vector3 realPivotBInW  
    Vector3 projPivotInW  
    Vector3 delta  
    Vector3 depth  
    Vector3 relPosA  
    Vector3 relPosB  

    number linPos = 0

    number angDepth = 0  
    number kAngle = 0  

    boolean poweredLinMotor = false 
    number targetLinMotorVelocity = 0 
    number maxLinMotorForce = 0  
    number accumulatedLinMotorImpulse = 0  

    boolean poweredAngMotor = false  
    number targetAngMotorVelocity = 0  
    number maxAngMotorForce = 0  
    number accumulatedAngMotorImpulse = 0  




    ConstraintDescription3D jacLin0
    ConstraintDescription3D jacLin1
    ConstraintDescription3D jacLin2
    number jacLinDiagABInv0 = 0
    number jacLinDiagABInv1 = 0
    number jacLinDiagABInv2 = 0

    ConstraintDescription3D jacAng0
    ConstraintDescription3D jacAng1
    ConstraintDescription3D jacAng2



    action Initialize(Item3D itemA, Item3D itemB, PhysicsPosition3D positionA, PhysicsPosition3D positionB, boolean useLinearReferenceFrameA)
        parent:Joint3D:SetType(parent:Joint3D:Slider)
        parent:Joint3D:SetItemA(itemA)
        parent:Joint3D:SetItemB(itemB)

        frameInA:Set(positionA)
        frameInB:Set(positionB)
        me:useLinearReferenceFrameA = useLinearReferenceFrameA


        lowerLinLimit = 1  
        upperLinLimit = -1  
        lowerAngLimit = 0  
        upperAngLimit = 0  
        softnessDirLin = SLIDER_CONSTRAINT_DEF_SOFTNESS  
        restitutionDirLin = SLIDER_CONSTRAINT_DEF_RESTITUTION  
        dampingDirLin = 0  
        softnessDirAng = SLIDER_CONSTRAINT_DEF_SOFTNESS  
        restitutionDirAng = SLIDER_CONSTRAINT_DEF_RESTITUTION  
        dampingDirAng = 0  
        softnessOrthoLin = SLIDER_CONSTRAINT_DEF_SOFTNESS  
        restitutionOrthoLin = SLIDER_CONSTRAINT_DEF_RESTITUTION  
        dampingOrthoLin = SLIDER_CONSTRAINT_DEF_DAMPING  
        softnessOrthoAng = SLIDER_CONSTRAINT_DEF_SOFTNESS  
        restitutionOrthoAng = SLIDER_CONSTRAINT_DEF_RESTITUTION  
        dampingOrthoAng = SLIDER_CONSTRAINT_DEF_DAMPING  
        softnessLimLin = SLIDER_CONSTRAINT_DEF_SOFTNESS  
        restitutionLimLin = SLIDER_CONSTRAINT_DEF_RESTITUTION  
        dampingLimLin = SLIDER_CONSTRAINT_DEF_DAMPING  
        softnessLimAng = SLIDER_CONSTRAINT_DEF_SOFTNESS  
        restitutionLimAng = SLIDER_CONSTRAINT_DEF_RESTITUTION  
        dampingLimAng = SLIDER_CONSTRAINT_DEF_DAMPING  

        poweredLinMotor = false  
        targetLinMotorVelocity = 0  
        maxLinMotorForce = 0  
        accumulatedLinMotorImpulse = 0  

        poweredAngMotor = false  
        targetAngMotorVelocity = 0  
        maxAngMotorForce = 0  
        accumulatedAngMotorImpulse = 0  
        
    end



    action BuildJacobian
        if (useLinearReferenceFrameA)
            BuildJacobian(parent:Joint3D:itemA, parent:Joint3D:itemB, frameInA, frameInB)
        else
            BuildJacobian(parent:Joint3D:itemB, parent:Joint3D:itemA, frameInB, frameInA)
        end
        //output "jacobian built"
    end


    action SolveJoint(number timeStep) 
            me:timeStep = timeStep
            if (useLinearReferenceFrameA)
                    SolveJoint(parent:Joint3D:itemA, parent:Joint3D:itemB)
            else 
                    SolveJoint(parent:Joint3D:itemB, parent:Joint3D:itemA)
            end
    end




    private action SolveJoint(Item3D itemA, Item3D itemB)

		Vector3 tmp

		// linear
		Vector3 velA
                velA:Set(itemA:GetLinearVelocityAtLocalPoint(relPosA))

		Vector3 velB
                velB:Set(itemB:GetLinearVelocityAtLocalPoint(relPosB))

		Vector3 vel
		vel:Set(velA)
                vel:Subtract(velB) 

		Vector3 impulse_vector 
                
                integer i = 0

                repeat 3 times
                    Vector3 normal
                    number depthNum = 0
                    number jacLinDiagABInvTemp = 0

                    if (i = 0)
                        normal:Set(jacLin0:GetLinearJointAxis())
                        //normal:Output()   //debugging
                        depthNum = depth:GetX()  // calculate positional error
                        jacLinDiagABInvTemp = jacLinDiagABInv0
                    elseif (i = 1)
                        normal:Set(jacLin1:GetLinearJointAxis())
                        //normal:Output()   //debugging
                        depthNum = depth:GetY()
                        jacLinDiagABInvTemp = jacLinDiagABInv1
                    elseif (i = 2)
                        normal:Set(jacLin2:GetLinearJointAxis())
                        //normal:Output()   //debugging
                        depthNum = depth:GetZ()
                        jacLinDiagABInvTemp = jacLinDiagABInv2
                    else
                        output "error"
                    end



                    number rel_vel = normal:DotProduct(vel)

			// get parameters
			number softness = 0 
                        number restitution = 0
                        number damping = 0
                        if (i not= 0)
                            softness = softnessOrthoLin
                            restitution = restitutionOrthoLin
                            damping = dampingOrthoLin
                        else
                            if (solveLinLim)
                                softness = softnessLimLin
                                restitution = restitutionLimLin
                                damping = dampingLimLin
                            else 
                                softness = softnessDirLin
                                restitution = restitutionDirLin
                                damping = dampingDirLin
                            end
                        end

                        // calcutate and apply impulse
			number normalImpulse = softness * (restitution * depthNum / timeStep - damping * rel_vel) * jacLinDiagABInvTemp
                        impulse_vector:Set(normal)
                        impulse_vector:Scale(normalImpulse)

                        parent:Joint3D:itemA:ApplyImpulse(impulse_vector, relPosA)
                        tmp:Set(impulse_vector)
                        tmp:MakeOpposite()

                        parent:Joint3D:itemB:ApplyImpulse(tmp, relPosB)



                        if (poweredLinMotor and (i = 0))
                            // apply linear motor
                            if (accumulatedLinMotorImpulse < maxLinMotorForce)
                                number desiredMotorVel = targetLinMotorVelocity
                                number motor_relvel = desiredMotorVel + rel_vel

                                normalImpulse = -motor_relvel*jacLinDiagABInvTemp

                                // clamp accumulated impulse
                                number new_acc = accumulatedLinMotorImpulse + math:AbsoluteValue(normalImpulse)
                                if (new_acc > maxLinMotorForce)
                                    new_acc = maxLinMotorForce
                                end

                                number del = new_acc - accumulatedLinMotorImpulse
                                if (normalImpulse < 0) 
                                    normalImpulse = -del
                                else
                                    normalImpulse = del
                                end
                                
                                accumulatedLinMotorImpulse = new_acc

                                // apply clamped impulse
                                impulse_vector:Set(normal)
                                impulse_vector:Scale(normalImpulse)
                                
                                parent:Joint3D:itemA:ApplyImpulse(impulse_vector, relPosA)
                                tmp:Set(impulse_vector)
                                tmp:MakeOpposite()

                                parent:Joint3D:itemB:ApplyImpulse(tmp, relPosB)
                            end//end if
                        end //end if (poweredLinMotor && (i == 0))
                        i = i + 1
                end //end for statement
                
		// start solving angular
		// get axes in world space
                Vector3 axisA 
                axisA:Set(calculatedTransformA:GetBasis():GetColumn(0))
                Vector3 axisB
                axisB:Set(calculatedTransformB:GetBasis():GetColumn(0))

                Vector3 angVelA 
                angVelA:Set(parent:Joint3D:itemA:GetAngularVelocity())
               
                Vector3 angVelB 
                angVelB:Set(parent:Joint3D:itemB:GetAngularVelocity()) 

                Vector3 angVelAroundAxisA   
                angVelAroundAxisA:Set(axisA)
                angVelAroundAxisA:Scale(axisA:DotProduct(angVelA))

                Vector3 angVelAroundAxisB   
                angVelAroundAxisB:Set(axisB)
                angVelAroundAxisB:Scale(axisB:DotProduct(angVelB))
                

                Vector3 angAorthog
                angAorthog:Set(angVelA)
                angAorthog:Subtract(angVelAroundAxisA)

                Vector3 angBorthog
                angBorthog:Set(angVelB)
                angBorthog:Subtract(angVelAroundAxisB)

                Vector3 velrelOrthog
                velrelOrthog:Set(angAorthog)
                velrelOrthog:Subtract(angBorthog)


                // solve orthogonal angular velocity correction
                number len = velrelOrthog:Length()
                if (len > 0.00001)
                    Vector3 normalTemp
                    normalTemp:Set(velrelOrthog)
                    normalTemp:Normalize()

                    number denom = parent:Joint3D:itemA:ComputeAngularImpulseDenominator(normalTemp) + parent:Joint3D:itemB:ComputeAngularImpulseDenominator(normalTemp)
                    velrelOrthog:Scale((1.0/denom) * dampingOrthoAng * softnessOrthoAng)
                end

		// solve angular positional correction
		Vector3 angularError
                angularError:Set(axisA:CrossProduct(axisB))
                angularError:Scale(1.0/timeStep)

                number len2 = angularError:Length()


                if (len2 > 0.00001)
                    Vector3 normal2
                    normal2:Set(angularError)
                    normal2:Normalize()

                    number denom2  = parent:Joint3D:itemA:ComputeAngularImpulseDenominator(normal2) + parent:Joint3D:itemB:ComputeAngularImpulseDenominator(normal2)
                    angularError:Scale(1.0/denom2 * restitutionOrthoAng * softnessOrthoAng)
                end


        // apply impulse
        tmp:Set(velrelOrthog)
        tmp:MakeOpposite()
        tmp:Add(angularError)
        parent:Joint3D:itemA:ApplyTorqueImpulse(tmp)

        tmp:Set(velrelOrthog)
        tmp:Subtract(angularError)
        parent:Joint3D:itemB:ApplyTorqueImpulse(tmp)


        number impulseMag = 0
        
        // solve angular limits
        if (solveAngLim)
            tmp:Set(angVelB)
            tmp:Subtract(angVelA)

            impulseMag = tmp:DotProduct(axisA) * dampingLimAng + angDepth * restitutionLimAng / timeStep
            impulseMag = impulseMag * (kAngle * softnessLimAng)
        else
            tmp:Set(angVelB)
            tmp:Subtract(angVelA)
            impulseMag = tmp:DotProduct(axisA) * dampingDirAng + angDepth * restitutionDirAng / timeStep
            impulseMag = impulseMag * kAngle * softnessDirAng
        end

        Vector3 impulse 
        impulse:Set(axisA)
        impulse:Scale(impulseMag)

        parent:Joint3D:itemA:ApplyTorqueImpulse(impulse)
        tmp:Set(impulse)
        tmp:MakeOpposite()
        parent:Joint3D:itemB:ApplyTorqueImpulse(tmp)


		// apply angular motor
		if (poweredAngMotor)
                    if (accumulatedAngMotorImpulse < maxAngMotorForce)
                        Vector3 velrel
                        velrel:Set(angVelAroundAxisA)
                        velrel:Subtract(angVelAroundAxisB)

                        number projRelVel = velrel:DotProduct(axisA)

                        number desiredMotorVel = targetAngMotorVelocity
                        number motor_relvel = desiredMotorVel - projRelVel
                        number angImpulse = kAngle * motor_relvel

                        // clamp accumulated impulse
			number new_acc = accumulatedAngMotorImpulse + math:AbsoluteValue(angImpulse)
                        if (new_acc > maxAngMotorForce)
                            new_acc = maxAngMotorForce
                        end 
                        
                        number del = new_acc - accumulatedAngMotorImpulse

                        if (angImpulse < 0)
                            angImpulse = -del
                        else
                            angImpulse = del
                        end
                        accumulatedAngMotorImpulse = new_acc

                        // apply clamped impulse
			Vector3 motorImp
                        motorImp:Set(axisA)
                        motorImp:Scale(angImpulse)
                        parent:Joint3D:itemA:ApplyTorqueImpulse(motorImp)
                        
                        tmp:Set(motorImp)
                        tmp:MakeOpposite()
                        parent:Joint3D:itemB:ApplyTorqueImpulse(tmp)
                    end
                end //if (poweredAngMotor)
    end


    private action BuildJacobian(Item3D itemA, Item3D itemB, PhysicsPosition3D frameInA, PhysicsPosition3D frameInB)
        PhysicsPosition3D tmpTrans 
        PhysicsPosition3D tmpTrans1 
        PhysicsPosition3D tmpTrans2 
        Vector3 tmp 
        Vector3 tmp2 


        calculatedTransformA:Multiply(parent:Joint3D:itemA:GetCenterOfMassTransform(),frameInA)

        calculatedTransformB:Multiply(parent:Joint3D:itemB:GetCenterOfMassTransform(), frameInB)



        realPivotAInW:Set(calculatedTransformA:GetOrigin())  
        realPivotBInW:Set(calculatedTransformB:GetOrigin())  

        tmp:Set(calculatedTransformA:GetBasis():GetColumn(0))
        sliderAxis:Set(tmp)  // along X

        delta:Set(realPivotBInW)
        delta:Subtract(realPivotAInW)



        number projValue = sliderAxis:DotProduct(delta)
        projPivotInW:Set(sliderAxis)
        projPivotInW:Add(realPivotAInW)
        projPivotInW:Scale(projValue)

        relPosA:Set(projPivotInW)
        tmp:Set(parent:Joint3D:itemA:GetCenterOfMassTransform():GetOrigin())
        relPosA:Subtract(tmp)


        relPosB:Set(realPivotBInW)
        tmp:Set(parent:Joint3D:itemB:GetCenterOfMassTransform():GetOrigin())
        relPosB:Subtract(tmp)


        Vector3 normalWorld

        integer i = 0


        //creating linear limits
        repeat 3 times
            normalWorld:Set(calculatedTransformA:GetBasis():GetColumn(i))
            
            Matrix3 mat1 = itemA:GetCenterOfMassTransform():GetBasis()
            mat1:Transpose()
            Matrix3 mat2 = itemB:GetCenterOfMassTransform():GetBasis()  
            mat2:Transpose()

            if (i = 0)
                jacLin0:Initialize(mat1, mat2, relPosA, relPosB, normalWorld, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemA:GetInverseMass(), parent:Joint3D:itemB:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseMass())
                jacLinDiagABInv0 = 1.0/jacLin0:GetDiagonal()
                depth:Set(delta:DotProduct(normalWorld), depth:GetY(), depth:GetZ())
            elseif (i = 1)
                jacLin1:Initialize(mat1, mat2, relPosA, relPosB, normalWorld, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemA:GetInverseMass(), parent:Joint3D:itemB:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseMass())
                jacLinDiagABInv1 = 1.0/jacLin1:GetDiagonal()
                depth:Set(depth:GetX(), delta:DotProduct(normalWorld), depth:GetZ())
            elseif (i = 2)
                jacLin2:Initialize(mat1, mat2, relPosA, relPosB, normalWorld, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemA:GetInverseMass(), parent:Joint3D:itemB:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseMass())
                jacLinDiagABInv2 = 1.0/jacLin2:GetDiagonal()
                depth:Set(depth:GetX(), depth:GetY(), delta:DotProduct(normalWorld))
            else
                output "error"
            end
            
            i = i + 1
        end


        TestLinearLimits()




        //creating angular limits
        i = 0
        repeat 3 times
            normalWorld:Set(calculatedTransformA:GetBasis():GetColumn(i))

            Matrix3 mat1 = parent:Joint3D:itemA:GetCenterOfMassTransform():GetBasis()
            mat1:Transpose()
            Matrix3 mat2 = parent:Joint3D:itemB:GetCenterOfMassTransform():GetBasis()  
            mat2:Transpose()

            if (i = 0)
                jacAng0:Initialize(normalWorld, mat1, mat2, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseInertiaLocal())
            elseif (i = 1)
                jacAng1:Initialize(normalWorld, mat1, mat2, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseInertiaLocal())

            elseif (i = 2)
                jacAng2:Initialize(normalWorld, mat1, mat2, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseInertiaLocal())

            else
                output "error"
            end
            i = i + 1
        end


        TestAngularLimits()



        Vector3 axisA
        axisA:Set(calculatedTransformA:GetBasis():GetColumn(0))


        number dem1 = parent:Joint3D:itemA:ComputeAngularImpulseDenominator(axisA)
        number dem2 = parent:Joint3D:itemB:ComputeAngularImpulseDenominator(axisA)
        kAngle = 1/(dem1+dem2) 

        // clear accumulator for motors
        accumulatedLinMotorImpulse = 0  
        accumulatedAngMotorImpulse = 0  
    end




    private action TestLinearLimits
        solveLinLim = false
        linPos = depth:GetX()

        if (lowerLinLimit <= upperLinLimit)
            if (depth:GetX() > upperLinLimit)
                    depth:SetX(depth:GetX() - upperLinLimit)
                    solveLinLim = true
            elseif (depth:GetX() < lowerLinLimit)
                    depth:SetX(depth:GetX() - lowerLinLimit)
                    solveLinLim = true
            else
                    depth:SetX(0)
            end
        else
                depth:SetX(0)
        end
    end





    private action TestAngularLimits
        angDepth = 0
        solveAngLim = false

        if (lowerAngLimit <= upperAngLimit)
                Vector3 axisA0
                axisA0:Set(calculatedTransformA:GetBasis():GetColumn(1))

                Vector3 axisA1
                axisA1:Set(calculatedTransformA:GetBasis():GetColumn(2))


                Vector3 axisB0 
                axisB0:Set(calculatedTransformB:GetBasis():GetColumn(1))


                number rot = atan2Fast(axisB0:DotProduct(axisA1), axisB0:DotProduct(axisA0))
                if (rot < lowerAngLimit)
                        angDepth = rot - lowerAngLimit
                        solveAngLim = true
                else 
                    if (rot > upperAngLimit)
                            angDepth = rot - upperAngLimit
                            solveAngLim = true
                    end
                end
        end
    end

    private action atan2Fast(number y, number x) returns number
        number coeff_1 = math:pi/4.0
        number coeff_2 = 3.0*coeff_1

        number abs_y = math:AbsoluteValue(y)

        number angle = 0

        if (x >= 0.0)
            number r = (x - abs_y )/(x+abs_y)
            angle = coeff_1 - coeff_1 * r
        else
            number r = (x + abs_y) / (abs_y - x)
            angle = coeff_2 - coeff_1 * r
        end

        if (y < 0.0)
            return -angle
        else 
            return angle
        end
    end


    action SetLowerLinearLimit(number lowerLimit)
        me:lowerLinLimit = lowerLimit
    end

    action SetUpperLinearLimit(number upperLimit)
        me:upperLinLimit = upperLimit
    end

    action SetLowerAngularLimit(number lowerLimit)
        me:lowerAngLimit = lowerLimit
    end

    action SetUpperAngularLimit(number upperLimit)
        me:upperAngLimit = upperLimit
    end
end