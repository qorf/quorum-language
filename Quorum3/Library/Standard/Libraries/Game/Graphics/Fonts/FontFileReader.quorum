package Libraries.Game.Graphics.Fonts

use Libraries.System.File
use Libraries.System.BinaryFileReader
use Libraries.Containers.ByteArray
use Libraries.Containers.Support.ByteReader
use Libraries.Containers.Array
use Libraries.Containers.HashTable
use Libraries.Containers.Iterator
use Libraries.Compute.BigInteger
use Libraries.Compute.BitwiseOperations
use Libraries.Game.Graphics.Fonts.all

/*
The FontFileReader class is used to read font files. Currently it only supports
TrueType files (.ttf extension). TrueType files come in different formats, and
not all of these formats are supported at the moment. As a result, some TrueType
files will load and be read, but they will not display characters correctly.

Attribute: Example

    use Libraries.Game.Graphics.Fonts.all
    use Libraries.Game.Game
    use Libraries.System.File

    class Main is Game
        action Main
            StartGame()
        end

        action CreateGame
            FontFileReader reader
            File file
            // This is the directory for fonts on Mac
            file:SetWorkingDirectory("/Library/Fonts")
            file:SetPath("Arial.ttf")
            reader:Load(file)
        end
    end
*/
class FontFileReader
    /*ByteArray to store information read from the font file.*/
    ByteArray byteArray = undefined
    /*ByteReader that reads through the font file.*/
    ByteReader byteReader = undefined
    /*Termination null character.*/
    text NULL_TERMINATOR = ""
    /*TrueTypeFileInformation that maintains information about the font, as read from the file.*/
    TrueTypeFileInformation fileInformation
    /*CharacterMap that maintains individual character information, such as its UNICODE
    value, its glyph, and so on.*/
    CharacterMap characterMap
    /*KerningTable that maintains the kerning values between any two pairs of characters*/
    KerningTable kerningTable
    /*TrueTypeCollectionRecords that maintains human-readable information about the font file.*/
    TrueTypeCollectionRecords trueTypeTable

    on create
        NULL_TERMINATOR = NULL_TERMINATOR:GetUnicodeValue(0)
    end

    /*
    This action returns all the information read from the TrueType file.

    Attribute: Returns Returns a TrueTypeFileInformation containing all of the
    contents from the TrueType file.

    Attribute: Example
    
        use Libraries.Game.Graphics.Fonts.all
        use Libraries.Game.Game
        use Libraries.System.File

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                FontFileReader reader
                File file
                TrueTypeFileInformation information
                // This is the directory for fonts on Mac
                file:SetWorkingDirectory("/Library/Fonts")
                file:SetPath("Arial.ttf")
                reader:Load(file)
                information = reader:GetFileInformation()
            end
        end
    */
    action GetFileInformation() returns TrueTypeFileInformation
        return me:fileInformation
    end

    /*
    This action will load the font file if it is found on the system and then read
    all information from the file.

    Attribute: Parameter fileInformation The TrueType font file to read.

    Attribute: Example

        use Libraries.Game.Graphics.Fonts.all
        use Libraries.Game.Game
        use Libraries.System.File

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                FontFileReader reader
                File file
                // This is the directory for fonts on Mac
                file:SetWorkingDirectory("/Library/Fonts")
                file:SetPath("Arial.ttf")
                reader:Load(file)
            end
        end
    */
    action Load(File fileInformation)
        if not fileInformation:Exists()
            alert ("File doesn't exist")
            return now
        end
        BinaryFileReader reader
        reader:OpenForRead(fileInformation)
        byteArray = reader:ReadBytes()
        // True type font format (ttf) is big endian
        byteArray:SetBigEndian(true)
        byteReader = byteArray:GetByteReader()
        GetRecords()
    end

    // This action is used in the GetRecords() when reading a .ttc file. .ttc files
    // have a different format from .ttf so must be read in differently. If this
    // needs to be modified, Microsoft has good documentation on .ttc files
    // in their OpenType documentation (I did not see anything on the Apple TrueType
    // documentation).
    private action GetTrueTypeCollectionRecords()
        fileInformation:SetTrueTypeCollectionFlag(true)
        integer majorVersionNumber = byteReader:NextTwoByteUnsignedInteger()
        integer minorVersionNumber = byteReader:NextTwoByteUnsignedInteger()
        integer numberOfFontsInCollection = byteReader:NextInteger()
        trueTypeTable:SetNumberOfFontsInCollection(numberOfFontsInCollection)
        Array<integer> offsetTable
        Array<TrueTypeCollectionData> collectionTables = trueTypeTable:GetCollectionTables()

        integer i = 0
        repeat while i < numberOfFontsInCollection
            TrueTypeCollectionData data
            integer value = byteReader:NextInteger()
            offsetTable:Add(value)
            collectionTables:Add(data)
            i = i + 1
        end

        trueTypeTable:SetOffsetTable(offsetTable)

        if majorVersionNumber = 2
            integer digitalSignatureTag = byteReader:NextInteger()
            integer digitalSignatureLength = byteReader:NextInteger()
            integer digitalSignatureOffset = byteReader:NextInteger()
        end

        //iterate over all the fonts in the file numberOfFontsInCollection
        i = 0
        repeat while i < numberOfFontsInCollection
            TrueTypeCollectionData data = collectionTables:Get(i)
            byteReader:SetPosition(offsetTable:Get(i))
            i = i + 1
            integer scalertype = byteReader:NextIntegerConvertFromUnsigned()
            fileInformation:SetScalerType(scalertype)
            //output "Scaler type is: " + scalertype

            fileInformation:SetNumberOfTables(byteReader:NextTwoByteUnsignedInteger())
            fileInformation:SetSearchRange(byteReader:NextTwoByteUnsignedInteger())
            fileInformation:SetEntrySelector(byteReader:NextTwoByteUnsignedInteger())
            fileInformation:SetRangeShift(byteReader:NextTwoByteUnsignedInteger())

            integer j = 0
            repeat while j < fileInformation:GetNumberOfTables()
                // these tables exist for every font, need to save them per font
                text tag = byteReader:NextTextRead(4)
                integer checksum = byteReader:NextIntegerConvertFromUnsigned()
                integer offset = byteReader:NextIntegerConvertFromUnsigned()
                integer length = byteReader:NextIntegerConvertFromUnsigned()

                fileInformation:AddFontTableDirectoryEntry(tag, checksum, offset, length)
                if tag = "cmap"
                    // reads character map table into hash table from CharacterMap class
                    ReadCharacterMapTable(byteReader, offset)
                elseif tag = "head"
                    // reads head table into hash table from GlobalFontInformationFlags class
                    ReadGlobalFontInformationTable(byteReader, offset)
                elseif tag = "kern"
                    // saves offset in file where kern table begins
                    ReadKerningTable(byteReader, offset)
                elseif tag = "glyf"
                    // saves offset in file where glyf table begins
                    fileInformation:SetGlyphOutlineTablePosition(offset)
                elseif tag = "loca"
                    // saves offset in file where loca table begins
                    fileInformation:SetGlyphDataLocationTablePosition(offset)
                elseif tag = "hhea"
                    // reads the hhea table, primarily used for maximum ascent and descent of a font
                    ReadHorizontalHeaderTable(byteReader, offset)
                elseif tag = "name"
                    // reads the name table, used to get human-readable text about the font, such as style name (i.e. bold)
                    ReadNameTable(byteReader, offset, data:GetNameRecords())
                end
                j = j + 1
            end
            data:SetAllTrueTypeInformation(fileInformation)
        end

        trueTypeTable:SetCollectionTables(collectionTables)
        fileInformation:SetTrueTypeCollectionRecords(trueTypeTable)
    end

    /*
    This action reads the name table of the ttf or ttc file. Useful primarily
    when dealing with the ttc files, as it allows us to differentiate between
    styles of a font in the collection (such as bold, light, etc.)
    */
    private action ReadNameTable(ByteReader byteReader, integer nameTableOffset, Array<NameRecord> records)
        integer previousPosition = byteReader:GetPosition()
        byteReader:SetPosition(nameTableOffset)
        integer format = byteReader:NextTwoByteUnsignedInteger()
        integer numberOfNameRecords = byteReader:NextTwoByteUnsignedInteger()
        integer stringOffset = byteReader:NextTwoByteUnsignedInteger()
        integer i = 0

        integer platformID = 0
        integer platformSpecificID = 0
        integer languageID = 0
        integer nameID = 0
        integer length = 0
        integer offset = 0

        repeat while i < numberOfNameRecords
            NameRecord nameRecord
            platformID = byteReader:NextTwoByteUnsignedInteger()
            platformSpecificID = byteReader:NextTwoByteUnsignedInteger()
            languageID = byteReader:NextTwoByteUnsignedInteger()
            nameID = byteReader:NextTwoByteUnsignedInteger()
            length = byteReader:NextTwoByteUnsignedInteger()
            offset = byteReader:NextTwoByteUnsignedInteger()

            if nameID = 2       // this is the string that contains the style name, so add it to the record
                nameRecord:SetFileFormat(format)
                nameRecord:SetNumberOfNameRecords(numberOfNameRecords)
                nameRecord:SetStringOffset(stringOffset)
                nameRecord:SetPlatformID(platformID)
                nameRecord:SetPlatformSpecificID(platformSpecificID)
                nameRecord:SetLanguageID(languageID)
                nameRecord:SetNameID(nameID)
                nameRecord:SetWordLength(length)
                nameRecord:SetOffsetToWord(offset)
                text word = ""
                integer currentPosition = byteReader:GetPosition()
                byteReader:SetPosition(nameTableOffset + stringOffset + offset)
                
                if(platformID = 3 or platformID = 0) 
                    word = byteReader:NextTextReadUnicode(length)
                else 
                    word = byteReader:NextTextRead(length)
                end
                
                nameRecord:SetFontStyleName(word)

                records:Add(nameRecord)

                byteReader:SetPosition(currentPosition)
            end
            i = i + 1
        end

        byteReader:SetPosition(previousPosition)
    end

    /*
        Called by FontFileReader:Load() action.

        Reads entire file using class variable byteReader and saves all
        necessary information to fileInformation object from TrueTypeFileInformation 
        class, which includes the character map, global font information table, 
        glyph offset location table, and kern table. 
    */
    private action GetRecords
        if byteReader:CheckIfTrueTypeCollection()   // For .ttc files
            GetTrueTypeCollectionRecords()
        else
            fileInformation:SetTrueTypeCollectionFlag(false)                                        // For .ttf files
            if byteReader:HasNextInteger()
                integer scalertype = byteReader:NextIntegerConvertFromUnsigned()
                fileInformation:SetScalerType(scalertype)
                //output "Scaler type is: " + scalertype
                fileInformation:SetNumberOfTables(byteReader:NextTwoByteUnsignedInteger())
                fileInformation:SetSearchRange(byteReader:NextTwoByteUnsignedInteger())
                fileInformation:SetEntrySelector(byteReader:NextTwoByteUnsignedInteger())
                fileInformation:SetRangeShift(byteReader:NextTwoByteUnsignedInteger())

                integer i = 0
                repeat while i < fileInformation:GetNumberOfTables()

                    text tag = byteReader:NextTextRead(4)
                    integer checksum = byteReader:NextIntegerConvertFromUnsigned()
                    integer offset = byteReader:NextIntegerConvertFromUnsigned()
                    integer length = byteReader:NextIntegerConvertFromUnsigned()

                    fileInformation:AddFontTableDirectoryEntry(tag, checksum, offset, length)
                    if tag = "cmap"
                        // reads character map table into hash table from CharacterMap class
                        ReadCharacterMapTable(byteReader, offset)
                    elseif tag = "head"
                        // reads head table into hash table from GlobalFontInformationFlags class
                        ReadGlobalFontInformationTable(byteReader, offset)
                    elseif tag = "kern"
                        // saves offset in file where kern table begins
                        ReadKerningTable(byteReader, offset)
                    elseif tag = "glyf"
                        // saves offset in file where glyf table begins
                        fileInformation:SetGlyphOutlineTablePosition(offset)
                    elseif tag = "loca"
                        // saves offset in file where loca table begins
                        fileInformation:SetGlyphDataLocationTablePosition(offset)
                    elseif tag = "hhea"
                        ReadHorizontalHeaderTable(byteReader, offset)
                    end
                    i = i + 1
                end
            end
        end
    end

    /*
    This action will return the Bezier curve glyph points of a given character. 
    If the character has already been read, it gets the points from the character
    map. Otherwise, it will get the data from the font file.

    Attribute: Parameter character The character to get the Bezier curve glyph points of.

    Attribute: Returns Returns the Bezier curve glyph points of the character.

    Attribute: Example

        use Libraries.Game.Graphics.Fonts.all
        use Libraries.Game.Game
        use Libraries.System.File

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                FontFileReader reader
                File file
                BezierCurveGlyphPoints points
                // This is the directory for fonts on Mac
                file:SetWorkingDirectory("/Library/Fonts")
                file:SetPath("Arial.ttf")
                reader:Load(file)
                points = reader:GetCharacterGlyphPoints("a")
            end
        end
    */
    action GetCharacterGlyphPoints(text character) returns BezierCurveGlyphPoints
        if not (character:GetSize() = 1)
            alert("I can only get one character at a time")
        end

        BezierCurveGlyphPoints glyphPoints

        if character = " " 
            return glyphPoints
        end

        if characterMap:GlyphPointsHaveBeenRead(character)
            glyphPoints = characterMap:GetGlyphPoints(character)
        else
            glyphPoints = GetCharacterGlyphPointsFromFile(character)
        end

        return glyphPoints
    end

    /*
        called by:
        DrawCharacters in MainGame (commented out)
        GetCharacterGlyph in FontFileReader (above)

        Locates and reads Bezier curve glyph points that outline the character glyph.

        Attribute: Parameter characterCode - integer ASCII value of character (value paired 
        with character in character map)

        Attribute: Returns BezierCurveGlyphPoints object containing information
        about a glyph's Bezier Curve outline
    */
    private action GetCharacterGlyphPointsFromFile(text character) returns BezierCurveGlyphPoints
        BezierCurveGlyphPoints glyphPoints
        integer characterCode = character:GetUnicodeInteger(0)

        integer glyphLocationTableIndex = FindCharacterGlyphIndex(characterCode, byteReader, fileInformation:GetCharacterMapTablePosition(), fileInformation:GetCharacterMapFormat())
        
        integer glyphTableOffset = 0
        check
            glyphTableOffset = GetGlyphOffset(glyphLocationTableIndex, byteReader, fileInformation:GetGlyphDataLocationTablePosition())
        detect e
            glyphTableOffset = 0
        end

        characterMap:SetGlyphIndexAndOffset(character, glyphLocationTableIndex, glyphTableOffset)

        check 
            glyphPoints = ReadGlyphPoints(byteReader, glyphTableOffset + fileInformation:GetGlyphOutlineTablePosition())
        detect e is Error
            return glyphPoints
        end
        characterMap:SetGlyphPoints(character, glyphPoints)

        return glyphPoints
    end

    /*
        Uses character map and passed character code to look up glyph index in 
        glyph offset location table.

        Attribute: Parameter characterCode - ASCII value of character

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file

        Attribute: Parameter characterMapTablePosition - byteReader position 
        of character map table in TrueType file

        Attribute: Parameter characterMapFormat - format of charcter map (must
        be 4)

        Attribute: Returns integer index of character in character map table?

        Attribute: example call: 
        integer index = FindCharacterGlyphIndex(characterCode, byteReader, fileInformation:GetCharacterMapTablePosition(), fileInformation:GetCharacterMapFormat())
    */
    private action FindCharacterGlyphIndex(integer characterCode, ByteReader byteReader, integer characterMapTablePosition, integer characterMapFormat) returns integer
        byteReader:SetPosition(characterMapTablePosition)

        // default is glyph not found
        integer glyphLocationTableIndex = 0

        if characterMapFormat = 4
            integer length = byteReader:NextTwoByteUnsignedInteger()
            integer language = byteReader:NextTwoByteUnsignedInteger()
            integer segmentCountTimesTwo = byteReader:NextTwoByteUnsignedInteger()
            integer segmentCount = segmentCountTimesTwo / 2
            integer searchRange = byteReader:NextTwoByteUnsignedInteger()
            integer entrySelector = byteReader:NextTwoByteUnsignedInteger()
            integer rangeShift = byteReader:NextTwoByteUnsignedInteger()
            
            integer i = 0
            integer position = -1
            integer endCharacterCode = -1
            
            repeat while i < segmentCount 
                endCharacterCode = byteReader:NextTwoByteUnsignedInteger()
                if endCharacterCode >= characterCode and position = -1   // set the first segment found, keep iterating to advance file reader enough
                    position = i
                end
                i = i + 1
            end
            
            integer pad = byteReader:NextTwoByteUnsignedInteger()

            if position = -1 // character not in the font, return missing character index
                return glyphLocationTableIndex
            else
                integer startCharacterCode = -1
                byteReader:SkipBytes(position * 2)  // array of 16 bit startCharacterCodes, we need to jump to the proper index
                startCharacterCode = byteReader:NextTwoByteUnsignedInteger()
                byteReader:SkipBytes((segmentCount - position - 1) * 2)
                
                if startCharacterCode <= characterCode  // character should be present, find it
                    integer idDelta = -1
                    integer idRangeOffset = -1

                    byteReader:SkipBytes(position * 2)
                    idDelta = byteReader:NextTwoByteUnsignedInteger()
                    byteReader:SkipBytes((segmentCount - position - 1) * 2)
                    
                    byteReader:SkipBytes(position * 2)
                    integer idRangeOffsetPosition = byteReader:GetPosition()
                    idRangeOffset = byteReader:NextTwoByteUnsignedInteger()
                    
                    if idRangeOffset not= 0 // this case not working right
                        integer glyphIndexAddress = idRangeOffset + 2 * (characterCode - startCharacterCode) + idRangeOffsetPosition
                        byteReader:SetPosition(glyphIndexAddress)
                        integer glyphID = byteReader:NextTwoByteUnsignedInteger()
                        if glyphID = 0
                            return glyphLocationTableIndex
                        else
                            glyphLocationTableIndex = (idDelta + glyphID) mod 65536
                        end
                    else
                        glyphLocationTableIndex = (idDelta + characterCode) mod 65536
                    end
                else        // character not in the font file, return missing character index
                    return glyphLocationTableIndex
                end
            end

        elseif characterMapFormat = 6
            integer tableLength = byteReader:NextTwoByteUnsignedInteger()
            integer languageCode = byteReader:NextTwoByteUnsignedInteger()
            integer firstCharacterCode = byteReader:NextTwoByteUnsignedInteger()
            integer entryCount = byteReader:NextTwoByteUnsignedInteger()
            
            integer endCharacterCode = firstCharacterCode + entryCount

            if characterCode < firstCharacterCode or characterCode > endCharacterCode
                glyphLocationTableIndex = 0
            else
                integer offset = characterCode - firstCharacterCode
                byteReader:SkipBytes(offset*2)      // each entry in the table is two bytes
                glyphLocationTableIndex = byteReader:NextTwoByteUnsignedInteger()
            end

        elseif characterMapFormat = 12 
            integer formatDecimal = byteReader:NextTwoByteUnsignedInteger() // format 12 files have an additional 2 bytes of info for the format that wasn't read before, so need to advance file
            integer tableLength = byteReader:NextInteger()
            integer languageCode = byteReader:NextInteger()
            integer numberOfGroups = byteReader:NextInteger()

            integer startCharacterCode = 0
            integer endCharacterCode = 0
            integer startGlyphID = 0
            integer i = 0
            
            repeat while i < numberOfGroups
                startCharacterCode = byteReader:NextInteger()
                endCharacterCode = byteReader:NextInteger()
                startGlyphID = byteReader:NextInteger()
                
                if endCharacterCode >= characterCode // the character we want is in this grouping
                    i = numberOfGroups
                end    
                i = i + 1
            end 
            
            glyphLocationTableIndex = startGlyphID + (characterCode - startCharacterCode)
        end

        return glyphLocationTableIndex
    end

    /*
        Uses Glyph Offset Location Table and glyph location table index to 
        look up offset of glyph in Glyph Table.
   
        Attribute: Parameter glyphLocationTableIndex - index of glyph in Character Map Table 

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read

        Attribute: Parameter glyphOffsetLocationTablePosition - byteReader position of Glyph Offset Location Table
        in TrueType file being read
       
        Attribute: Returns integer glyphTableOffset - location of glyph in Glyph Table in TrueType file

        Attribute: example call:
        integer glyphTableOffset = GetGlyphOffset(glyphLocationTableIndex, byteReader, fileInformation:GetGlyphDataLocationTablePosition())
    */
    private action GetGlyphOffset(integer glyphLocationTableIndex, ByteReader byteReader, integer glyphOffsetLocationTablePosition) returns integer
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(glyphOffsetLocationTablePosition)

        integer glyphTableOffset= -1
        if iteratorIsValid
            if fileInformation:GetIndexToLocationTableFormat() = 0 
                
                byteReader:SkipBytes(glyphLocationTableIndex*2)
                glyphTableOffset = byteReader:NextTwoByteUnsignedInteger() * 2
                // if nextoffset - glyphTableOffset = 0, then read whitespace, there is no glyph
            else 
                byteReader:SkipBytes(glyphLocationTableIndex*4)
                glyphTableOffset = byteReader:NextIntegerConvertFromUnsigned()
                // if nextoffset - glyphTableOffset = 0, then read whitespace, there is no glyph
            end
        end
        return glyphTableOffset
    end

    // F2Dot14 is a number where the first two bits of a 16 bit number are the sign and non-decimal value,
    // and the lower 14 bits are the fractional component of the number. 
    private action ConvertIntegerToF2Dot14(integer scale) returns number
        output "Scale is: " + scale 
        BitwiseOperations ops
        integer sign = 0
        number newScale = 0
        integer decimalPortion = 0
        
        if scale < 0
            sign = -1
        else
            sign = 1
        end
        
        newScale = newScale + ops:And(ops:ShiftRight(scale, 14), 1)
        
        decimalPortion = ops:And(scale, ops:Negate(ops:ShiftLeft(-1, 14)))
        
        newScale = newScale + decimalPortion / 16384        // 16384 is the maximum representation possible with 14 bits

        return newScale * sign

    end

    /*
        Reads and stores information from given TrueType file about a single glyph's contours
        and the Bezier points outlining the glyph.

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read

        Attribute: Parameter glyphTablePosition - position of Glyph Table in 
        TrueType file being read

        Attribute: Returns BezierCurveGlyphPoints object containing information
        about a glyph's Bezier Curve outline

        Attribute: example call:
        glyph = ReadGlyph(byteReader, glyphTableOffset + fileInformation:GetGlyphTablePosition())
    */
    private action ReadGlyphPoints(ByteReader byteReader, integer glyphTablePosition) returns BezierCurveGlyphPoints
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(glyphTablePosition)
        //output "Index is: " + glyphTablePosition + ", previousPosition is: " + previousPosition + ", iteratorIsValid is: " + iteratorIsValid
        BezierCurveGlyphPoints glyphPoints
        if iteratorIsValid
            integer numberOfContours = byteReader:NextTwoByteInteger()

            // Glyph bounding box
            integer xMin = byteReader:NextTwoByteInteger()
            integer yMin = byteReader:NextTwoByteInteger()
            integer xMax = byteReader:NextTwoByteInteger()
            integer yMax = byteReader:NextTwoByteInteger()
            
            glyphPoints:SetNumberOfContours(numberOfContours)
            glyphPoints:SetBoundingBox(xMin, yMin, xMax, yMax)

            if numberOfContours >= 0

                integer contourIterator = 0
                Array<integer> endPointsOfContours
                integer numberOfPoints = 0
                // Read contour endpoints
                repeat while contourIterator < numberOfContours
                    numberOfPoints = byteReader:NextTwoByteUnsignedInteger()
                    endPointsOfContours:Add(numberOfPoints)
                    contourIterator = contourIterator + 1
                end

                glyphPoints:SetContourEndpoints(endPointsOfContours)

                numberOfPoints = numberOfPoints + 1
                //glyphPoints:SetNumberOfPoints(numberOfPoints)
                
                integer numberOfInstructions = byteReader:NextTwoByteUnsignedInteger()
                
                integer instructionCount = 0
                Array<integer> instructions                                                 // read hints?
                repeat while instructionCount < numberOfInstructions
                    instructions:Add(byteReader:NextByteAsUnsignedInteger())
                    instructionCount = instructionCount + 1
                end

                // Read Glyph Coordinate flags
                Array<GlyphCoordinateFlag> glyphCoordinateFlagsArray
                repeat while glyphCoordinateFlagsArray:GetSize() < numberOfPoints
                    integer flags = byteReader:NextByteAsUnsignedInteger()
                    
                    GlyphCoordinateFlag glyphCoordinateFlag
                    glyphCoordinateFlag:SetFlags(flags)
                    glyphCoordinateFlagsArray:Add(glyphCoordinateFlag)

                    if glyphCoordinateFlag:RepetitionIsTrue()
                        integer repetitionCount = byteReader:NextByteAsUnsignedInteger()
                        repeat repetitionCount times
                            glyphCoordinateFlagsArray:Add(glyphCoordinateFlag)
                        end
                    end
                end

                // read x-Coordinates (relative)
                Array<integer> relativeXCoordinates
                integer flagIterator = 0
                repeat while relativeXCoordinates:GetSize() < numberOfPoints
                    GlyphCoordinateFlag currentFlag = glyphCoordinateFlagsArray:Get(flagIterator)

                    if currentFlag:XCoordinateIsOneByte()
                        integer currentX = byteReader:NextByteAsUnsignedInteger()
                        if not currentFlag:XCoordinateIsSame()
                            // is negative coordinate
                            currentX = currentX * -1
                        end
                        relativeXCoordinates:Add(currentX)
                    else    
                        if currentFlag:XCoordinateIsSame()
                            integer lastX = 0
                            relativeXCoordinates:Add(lastX)
                        else 
                            integer currentX = byteReader:NextTwoByteInteger()
                            relativeXCoordinates:Add(currentX)
                        end
                    end

                    flagIterator = flagIterator + 1
                end

                // read y-Coordinates (relative)
                Array<integer> relativeYCoordinates
                flagIterator = 0 // reset for y
                repeat while relativeYCoordinates:GetSize() < numberOfPoints
                    GlyphCoordinateFlag currentFlag = glyphCoordinateFlagsArray:Get(flagIterator)
                    
                    if currentFlag:YCoordinateIsOneByte()
                        integer currentY = 0
                        check
                            currentY = byteReader:NextByteAsUnsignedInteger()
                        detect e
                        end
                        if not currentFlag:YCoordinateIsSame()
                            // is negative coordinate
                            currentY = currentY * -1
                        end
                        relativeYCoordinates:Add(currentY)
                    elseif currentFlag:YCoordinateIsSame()
                        integer lastY = 0
                        relativeYCoordinates:Add(lastY)
                    else
                        integer currentY = 0
                        check
                            currentY = byteReader:NextTwoByteInteger()
                        detect e
                        end
                        relativeYCoordinates:Add(currentY)
                    end

                    flagIterator = flagIterator + 1
                end

                integer pointIterator = 0
                repeat while pointIterator < numberOfPoints
                    glyphPoints:AddNewPointRelativeToLast(relativeXCoordinates:Get(pointIterator), relativeYCoordinates:Get(pointIterator), glyphCoordinateFlagsArray:Get(pointIterator):IsOnCurve(), IsEndpoint(pointIterator, endPointsOfContours))
                    pointIterator = pointIterator + 1
                end

                glyphPoints:AddVirtualPoints()
            else
                output "Compound glyph case"
                BitwiseOperations ops
                integer flags = byteReader:NextTwoByteUnsignedInteger()
                integer glyphIndex = byteReader:NextTwoByteUnsignedInteger()

                output "Original glyph index is: " + glyphIndex
                boolean Arg1And2AreWords = ops:And(flags, 1) > 0
                boolean ArgsAreXYValues = ops:And(flags, 2) > 0
                boolean RoundXYToGrid = ops:And(flags, 4) > 0
                boolean WeHaveAScale = ops:And(flags, 8) > 0
                boolean MoreComponents = ops:And(flags, 32) > 0
                boolean WeHaveAnXAndYScale = ops:And(flags, 64) > 0
                boolean WeHaveATwoByTwo = ops:And(flags, 128) > 0
                boolean WeHaveInstructions = ops:And(flags, 256) > 0
                boolean UseMyMetrics = ops:And(flags, 512) > 0
                boolean OverlapCompound = ops:And(flags, 1024) > 0
                boolean ScaledComponentOffset = ops:And(flags, 2048) > 0
                boolean UnscaledComponentOffset = ops:And(flags, 4096) > 0
               
                integer argument1 = -1
                integer argument2 = -1

                if(Arg1And2AreWords)
                    argument1 = byteReader:NextTwoByteInteger()
                    argument2 = byteReader:NextTwoByteInteger()
                    output "Arguments are words: Argument1: " + argument1 + ", argument2: " + argument2
                else    
                    argument1 = byteReader:NextByteAsUnsignedInteger()
                    argument2 = byteReader:NextByteAsUnsignedInteger()
                    output "Arguments are not words: Argument1: " + argument1 + ", argument2: " + argument2
                end

                output "Scale values:"
                output WeHaveAScale
                output WeHaveAnXAndYScale
                output WeHaveATwoByTwo

                if WeHaveAScale
                    integer scale = byteReader:NextTwoByteInteger()
                    output "Scale is: " + scale
                    number newScale = ConvertIntegerToF2Dot14(scale)
                    output "New scale is: " + newScale
                elseif WeHaveAnXAndYScale
                    integer xScale = byteReader:NextTwoByteInteger()
                    integer yScale = byteReader:NextTwoByteInteger()
                    output "xScale is: " + xScale + ", yScale is: " + yScale
                    number newXScale = ConvertIntegerToF2Dot14(xScale)
                    number newYScale = ConvertIntegerToF2Dot14(yScale)
                    output "New xScale is: " + newXScale + ", newYScale is: " + newYScale
                elseif WeHaveATwoByTwo
                    integer xScale = byteReader:NextTwoByteInteger()
                    integer scale01 = byteReader:NextTwoByteInteger()   
                    integer scale10 = byteReader:NextTwoByteInteger()   
                    integer yScale = byteReader:NextTwoByteInteger()  
                    output "xScale is: " + xScale + ", scale01 is: " + scale01 + ", scale10 is: " + scale10 + ", yScale is: " + yScale
                end

                /*
                output "Flags in order: "
                output Arg1And2AreWords
                output ArgsAreXYValues
                output RoundXYToGrid
                output WeHaveAScale
                output WeHaveAnXAndYScale
                output WeHaveATwoByTwo
                output UseMyMetrics
                output OverlapCompound
                output ScaledComponentOffset
                output UnscaledComponentOffset
                */
                repeat while MoreComponents
                    integer currentPosition = byteReader:GetPosition()
                    integer glyphTableOffset = GetGlyphOffset(glyphIndex, byteReader, fileInformation:GetGlyphDataLocationTablePosition())
                    BezierCurveGlyphPoints temporaryPoints = ReadGlyphPoints(byteReader, fileInformation:GetGlyphOutlineTablePosition() + glyphTableOffset)
                    output "TempPoints (component) before any offset: "
                    temporaryPoints:DisplayPoints()
                    if ArgsAreXYValues
                        output "Args are XYValues, offset."
                        temporaryPoints:OffsetXY(argument1, argument2)
                        output "TempPoints (component) after any offset: "
                        temporaryPoints:DisplayPoints()
                    end
                    glyphPoints:CombineBezierCurveGlyphPoints(temporaryPoints)
                    byteReader:SetPosition(currentPosition)

                    flags = byteReader:NextTwoByteUnsignedInteger()
                    glyphIndex = byteReader:NextTwoByteUnsignedInteger()
                    output "Glyph index in loop is: " + glyphIndex
                    Arg1And2AreWords = ops:And(flags, 1) > 0
                    ArgsAreXYValues = ops:And(flags, 2) > 0
                    RoundXYToGrid = ops:And(flags, 4) > 0
                    WeHaveAScale = ops:And(flags, 8) > 0
                    MoreComponents = ops:And(flags, 32) > 0
                    WeHaveAnXAndYScale = ops:And(flags, 64) > 0
                    WeHaveATwoByTwo = ops:And(flags, 128) > 0
                    WeHaveInstructions = ops:And(flags, 256) > 0
                    UseMyMetrics = ops:And(flags, 512) > 0
                    OverlapCompound = ops:And(flags, 1024) > 0
                    ScaledComponentOffset = ops:And(flags, 2048) > 0
                    UnscaledComponentOffset = ops:And(flags, 4096) > 0

                    output "More components inside loop: " + MoreComponents

                    if(Arg1And2AreWords)
                        argument1 = byteReader:NextTwoByteInteger()
                        argument2 = byteReader:NextTwoByteInteger()
                        output "Arguments are words: Argument1: " + argument1 + ", argument2: " + argument2
                    else
                        argument1 = byteReader:NextByteAsUnsignedInteger()
                        argument2 = byteReader:NextByteAsUnsignedInteger()
                        output "Arguments are not words: Argument1: " + argument1 + ", argument2: " + argument2
                    end

                    if WeHaveAScale
                        integer scale = byteReader:NextTwoByteUnsignedInteger()
                        output "Scale is: " + scale
                    elseif WeHaveAnXAndYScale
                        integer first = byteReader:NextTwoByteUnsignedInteger()
                        integer second = byteReader:NextTwoByteUnsignedInteger()
                        output "First is: " + first + ", second is: " + second
                    elseif WeHaveATwoByTwo
                        integer first = byteReader:NextTwoByteUnsignedInteger()
                        integer second = byteReader:NextTwoByteUnsignedInteger()   
                        integer third = byteReader:NextTwoByteUnsignedInteger()   
                        integer fourth = byteReader:NextTwoByteUnsignedInteger()   
                        output "First is: " + first + ", second is: " + second + ", third is: " + third + ", fourth is: " + fourth
                    end
                end

                output "Final Glyph index is: " + glyphIndex
                integer glyphTableOffset = GetGlyphOffset(glyphIndex, byteReader, fileInformation:GetGlyphDataLocationTablePosition())
                BezierCurveGlyphPoints temporaryPoints = ReadGlyphPoints(byteReader, fileInformation:GetGlyphOutlineTablePosition() + glyphTableOffset)
                output "TempPoints (component) before any offset: "
                temporaryPoints:DisplayPoints()
                if ArgsAreXYValues
                    output "Args are XYValues, offset."
                    temporaryPoints:OffsetXY(argument1, argument2)
                    output "TempPoints (component) after any offset: "
                    temporaryPoints:DisplayPoints()
                end
                glyphPoints:CombineBezierCurveGlyphPoints(temporaryPoints)
                //output "File read endpoints before 'fix': " 
                //glyphPoints:DisplayOtherPoints()
                glyphPoints:DisplayPoints()
                //glyphPoints:DisplayOnCurve()
                //glyphPoints:DisplayEndpoint()
                glyphPoints:FixEndPoints()
                //output "File read endpoints after 'fix': "
                //glyphPoints:DisplayOtherPoints()    
            end
        end
                
        byteReader:SetPosition(previousPosition)
        return glyphPoints
    end

    /*
        Called by AddNewPointRelativeToLast() in ReadGlyph() 
        Traverses passed array of endpoints to check if passed targetPoint is
        an endpoint.

        Attribute: Parameter targetPoint - the point to be checked if endpoint
        Attribute: Parameter endpoints - array of endpoints

        Attribute: Returns True if passed point is an endpoint
    */
    private action IsEndpoint (integer targetPoint, Array<integer> endpoints) returns boolean
        
        integer index = 0

        repeat while index < endpoints:GetSize()
            if targetPoint = endpoints:Get(index)
                return true
            end

            index = index + 1
        end

        return false
    end
  
    /*
        Traverses through TrueType file until encounters correct character
        map table of platform ID 0.

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read.

        Attribute: Parameter characterMapTablePosition - byteReader position of 
        beginning of character map table in TrueType file being read.
    */
    private action ReadCharacterMapTable(ByteReader byteReader, integer characterMapTablePosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(characterMapTablePosition)
        if iteratorIsValid
            integer version = byteReader:NextTwoByteUnsignedInteger()
            integer numberOfSubtables = byteReader:NextTwoByteUnsignedInteger()

            integer platformID = -1
            integer platformSpecificID = -1
            integer characterMapOffset = -1

            integer characterMapSubtable = 0
            integer tablePosition = byteReader:GetPosition()
            repeat while characterMapSubtable < numberOfSubtables
                integer tempPlatformID = byteReader:NextTwoByteUnsignedInteger()
                integer tempPlatformSpecificID= byteReader:NextTwoByteUnsignedInteger()
                integer tempCharacterMapOffset = byteReader:NextIntegerConvertFromUnsigned()

                characterMapSubtable = characterMapSubtable + 1

                // The idea here is to use a more generalized and robust cmap table when possible.
                // There are 4 platform ID options, with 1 being deprecated. Of these, Unicode
                // is the most general and useful, followed by Windows, and finally Mac. Each of these
                // platform IDs have encoding IDs that let us know how the tables are encoded. For example,
                // some tables may be unicode UCS-4, which encompasses every current unicode character,
                // while some may be UCS-2, which covers many but not all characters. The ordering here
                // is based on the recommendation from the "cmap" table documentation on the Apple
                // website. We only need one cmap table, and we want the best one the file has,
                // and these conditionals are intended to get us the best one. For more information,
                // read the Apple or Microsoft documentation on the "cmap" table. 

                if tempPlatformID = 0
                    if tempPlatformSpecificID = 4
                        platformID = tempPlatformID
                        platformSpecificID = tempPlatformSpecificID
                        characterMapOffset = tempCharacterMapOffset
                        characterMapSubtable = numberOfSubtables
                    elseif tempPlatformSpecificID < 4 and platformSpecificID not= 4
                        platformID = tempPlatformID
                        platformSpecificID = tempPlatformSpecificID
                        characterMapOffset = tempCharacterMapOffset
                    end
                elseif tempPlatformID = 3 and platformID not= 0
                    if tempPlatformSpecificID = 10
                        platformID = tempPlatformID
                        platformSpecificID = tempPlatformSpecificID
                        characterMapOffset = tempCharacterMapOffset
                    elseif tempPlatformSpecificID = 1 and platformSpecificID not= 10
                        platformID = tempPlatformID
                        platformSpecificID = tempPlatformSpecificID
                        characterMapOffset = tempCharacterMapOffset
                    elseif tempPlatformSpecificID = 0 and platformSpecificID not= 10 and platformSpecificID not= 1
                        platformID = tempPlatformID
                        platformSpecificID = tempPlatformSpecificID
                        characterMapOffset = tempCharacterMapOffset
                    end
                elseif tempPlatformID = 1 and platformID not= 0 and platformID not= 3
                    platformID = tempPlatformID
                    platformSpecificID = tempPlatformSpecificID
                    characterMapOffset = tempCharacterMapOffset
                end
            end
            
            //output "Platform ID: " + platformID + ", platform specific ID: " + platformSpecificID

            ReadCharacterMapMapping(byteReader, characterMapTablePosition + characterMapOffset)

        end
        byteReader:SetPosition(previousPosition)
    end

    /*
        Saves offset of character map in TrueType file to class's 
        TrueTypeFileInformation object.

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read.

        Attribute: Parameter characterMapOffsetPosition - byteReader position of character map
        in TrueType file being read.
    */
    private action ReadCharacterMapMapping(ByteReader byteReader, integer characterMapOffsetPosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(characterMapOffsetPosition)
        if iteratorIsValid
            // Formats have to be read differently, so the format has
            // to be saved
            integer format = byteReader:NextTwoByteUnsignedInteger()
            //output "Format is: " + format
            integer cmapPosition = byteReader:GetPosition()
            fileInformation:SetCharacterMapTablePosition(cmapPosition, format)
        end
        byteReader:SetPosition(previousPosition)
    end

    /*
        called by:
        GetRecords in FontFileReader
    
        Reads heading kern table information from given TrueType file
        into class's TrueTypeFileInformation object. Saves offset of kern tables in class 
        TrueTypeFileInformation object. 

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read

        Attribute: Parameter kernTablePosition - byteReader position of 
        kernTable in TrueType file being read

        kerning table reference: https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html
    */
    private action ReadKerningTable (ByteReader byteReader, integer kernTablePosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(kernTablePosition)
        if iteratorIsValid
            fileInformation:SetKerningSubtablePosition(kernTablePosition)
            
            integer version = byteReader:NextTwoByteUnsignedInteger()
            integer numberOfSubtables = byteReader:NextTwoByteUnsignedInteger()

            integer kerningSubtable = 0            
            repeat while kerningSubtable < numberOfSubtables
                
                BitwiseOperations bitwiseOperation
                integer length = byteReader:NextIntegerConvertFromUnsigned()
                integer coverage = byteReader:NextTwoByteUnsignedInteger()
                integer format = bitwiseOperation:And(coverage, 65280)            // use mask value 0x00ff
                
                // Format 0: Ordered List of Kerning Pairs
                if format = 0
                    ReadKerningSubtableFormat0(byteReader, byteReader:GetPosition())
                end

                kerningSubtable = kerningSubtable + 1
            end 
        end
        
        byteReader:SetPosition(previousPosition)
    end

    /*
    This action reads the Horizontal Header (hhea) table from the font file.
    */  
    private action ReadHorizontalHeaderTable(ByteReader byteReader, integer horizontalHeaderPosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(horizontalHeaderPosition)
        if iteratorIsValid
            fileInformation:SetHorizontalHeaderTablePosition(horizontalHeaderPosition)

            integer version = byteReader:NextTwoByteUnsignedInteger()
            integer versionDecimal = byteReader:NextTwoByteUnsignedInteger()
            integer ascent = byteReader:NextTwoByteInteger()
            fileInformation:SetMaximumAscent(ascent)
            integer descent = byteReader:NextTwoByteInteger()
            fileInformation:SetMaximumDescent(descent)
            integer lineGap = byteReader:NextTwoByteInteger()
            fileInformation:SetLineGap(lineGap)
        end

        byteReader:SetPosition(previousPosition)
    end

    /* 
        called by: 
        ReadKernTables in FontFileReader (above).

        Reads and stores kerning values to kerning table object in class's
        TrueTypeFileInformation object.

        Attribute: Parameter byteReader - used to travers ethrough the binary
        TrueType file being read.

        Attribute: Parameter kerningValuesPosition - byteReader position of
        beginning of kerning values in TrueType file being read.
    */
    private action ReadKerningSubtableFormat0 (ByteReader byteReader, integer kerningSubtablePosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(kerningSubtablePosition)

        if iteratorIsValid
            integer nPairs = byteReader:NextTwoByteUnsignedInteger()
            integer searchRange = byteReader:NextTwoByteUnsignedInteger()
            integer entrySelector = byteReader:NextTwoByteUnsignedInteger()
            integer rangeShift = byteReader:NextTwoByteUnsignedInteger()

            integer pairIterator = 0
            repeat while pairIterator < nPairs
                integer leftCharacterGlyphIndex = byteReader:NextTwoByteUnsignedInteger()
                integer rightCharacterGlyphIndex = byteReader:NextTwoByteUnsignedInteger()
                integer kerningValue = byteReader:NextTwoByteInteger()
     
                //output pairIterator + ": " + leftCharacterGlyphIndex + "-" + rightCharacterGlyphIndex + "-  " + kerningValue
                number kerningValueNumber = kerningValue / 1000
                kerningTable:Add(leftCharacterGlyphIndex, rightCharacterGlyphIndex, kerningValue)
                
                pairIterator = pairIterator + 1
            end 
        end

        byteReader:SetPosition(previousPosition)
    end

    /*
    This action returns the kerning value between two given characters.

    Attribute: Parameter lefthandCharacter The lefthand character of the pair.

    Attribute: Parameter righthandCharacter The righthand character of the pair.

    Attribute: Returns Returns the kerning value between two given characters.

    Attribute: Example

        use Libraries.Game.Graphics.Fonts.all
        use Libraries.Game.Game
        use Libraries.System.File

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                FontFileReader reader
                File file
                // This is the directory for fonts on Mac
                file:SetWorkingDirectory("/Library/Fonts")
                file:SetPath("Arial.ttf")
                reader:Load(file)
                integer kerning = reader:GetKerningValue("A", "V")
                output kerning
            end
        end
    */
    action GetKerningValue(text lefthandCharacter, text righthandCharacter) returns integer
        integer kerningValue = 0
        integer leftCharacterGlyphIndex = -1
        integer rightCharacterGlyphIndex = -1

        // get left character glyph index
        if characterMap:GlyphPointsHaveBeenRead(lefthandCharacter)
            leftCharacterGlyphIndex = characterMap:GetGlyphIndex(lefthandCharacter)
        else
            integer characterCode = characterMap:GetCharacterCode(lefthandCharacter)
            leftCharacterGlyphIndex = FindCharacterGlyphIndex(characterCode, byteReader, fileInformation:GetCharacterMapTablePosition(), fileInformation:GetCharacterMapFormat())
        end
        
        // get right character glyph index
        if characterMap:GlyphPointsHaveBeenRead(righthandCharacter)
            rightCharacterGlyphIndex = characterMap:GetGlyphIndex(righthandCharacter)
        else
            integer characterCode = characterMap:GetCharacterCode(righthandCharacter)
            rightCharacterGlyphIndex = FindCharacterGlyphIndex(characterCode, byteReader, fileInformation:GetCharacterMapTablePosition(), fileInformation:GetCharacterMapFormat())     
        end

        // retrieve kerning value from kerning table
        if leftCharacterGlyphIndex > -1 and rightCharacterGlyphIndex > -1 and kerningTable:HasPair(leftCharacterGlyphIndex, rightCharacterGlyphIndex)
            kerningValue = me:kerningTable:GetKerningValue(leftCharacterGlyphIndex, rightCharacterGlyphIndex)
        end

        return kerningValue
    end

    /*
    This action returns the kerning table, containing kerning values for all
    characters, of the font.

    Attribute: Returns Returns the kerning table of the font.

    Attribute: Example

        use Libraries.Game.Graphics.Fonts.all
        use Libraries.Game.Game
        use Libraries.System.File

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                FontFileReader reader
                File file
                KerningTable table
                // This is the directory for fonts on Mac
                file:SetWorkingDirectory("/Library/Fonts")
                file:SetPath("Arial.ttf")
                reader:Load(file)
                table = reader:GetKerningTable()
            end
        end
    */
    action GetKerningTable() returns KerningTable
        return me:kerningTable
    end

    /*
        Reads and stores information from Global Font Information Table, which 
        contains general measurements that apply to all characters of the font

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read

        Attribute: Parameter GlobalFontInformationTablePosition - position of Global Font Information Table
        in TrueType file being read
    */
    private action ReadGlobalFontInformationTable (ByteReader byteReader, integer GlobalFontInformationTablePosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(GlobalFontInformationTablePosition)
        if iteratorIsValid
            // The first two entries are 16.16 fixed point values, that I don't know
            // how to deal with yet. They contain the version number only, so I am
            // going to skip them  (2x32 bit = 8 byte)
            byteReader:SkipBytes(8)
            integer checksum = byteReader:NextIntegerConvertFromUnsigned()
            integer magicNumber = byteReader:NextIntegerConvertFromUnsigned()
            
            // these are bitflags with specific meanings. See https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6head.html
            integer flags = byteReader:NextTwoByteUnsignedInteger()
            fileInformation:SetGlobalFontInformationFlags(flags)

            integer unitsPerEm = byteReader:NextTwoByteUnsignedInteger()
            fileInformation:SetUnitsPerEm(unitsPerEm)

            fileInformation:SetCreatedDate(byteReader:NextLong())
            fileInformation:SetLastChangedDate(byteReader:NextLong())

            Signed16BitFontUnit xMin
            Signed16BitFontUnit yMin
            Signed16BitFontUnit xMax
            Signed16BitFontUnit yMax

            xMin:SetFontUnit(byteReader:NextTwoByteInteger())
            yMin:SetFontUnit(byteReader:NextTwoByteInteger())
            xMax:SetFontUnit(byteReader:NextTwoByteInteger())
            yMax:SetFontUnit(byteReader:NextTwoByteInteger())

            fileInformation:SetXMinimum(xMin)
            fileInformation:SetYMinimum(yMin)
            fileInformation:SetXMaximum(xMax)
            fileInformation:SetYMaximum(yMax)
            
            // Flags again, this time macStyle.
            integer macStyleFlags = byteReader:NextTwoByteUnsignedInteger()
            fileInformation:SetMacStyleFlags(macStyleFlags)

            // lowest recommended points per EM
            integer lowestRecommendedPixelsPerEm = byteReader:NextTwoByteUnsignedInteger()
            fileInformation:SetLowestRecommendedPixelsPerEm(lowestRecommendedPixelsPerEm)

            // contains small integer giving info on direction
            // 0 : mixed; 1: only left to right; 2: like 1 but contains neutrals
            // -1: right to left; -2: like -1 but contains neutrals
            integer fontDirectionHint = byteReader:NextTwoByteUnsignedInteger()
            fileInformation:SetFontDirectionHint(fontDirectionHint)


            integer indexToLocationTableFormat = byteReader:NextTwoByteInteger()
            fileInformation:SetIndexToLocationTableFormat(indexToLocationTableFormat)
            integer glyphDataFormat = byteReader:NextTwoByteInteger()
           
        end
        byteReader:SetPosition(previousPosition)
    end
end
