use Libraries.Compute.Vector2
use Libraries.Compute.Math

package Libraries.Game.Collision

/*
Let time step be defined as the amount of time it is necessary to update the physics of a 2D mass.
This class calculates the orientation and location of a mass in 2D between time steps
in order to calculate when this 2D mass might collide with another 2D mass (Time of Impact (TOI)),
ideally, before the frame update so we can catch a collision before the frame update and not
have objects penetrate through other objects when they are not supposed to.
*/
class Sweep2D
    Vector2 localCenter   ////center of the object relative to the local coordinates, this won't change during a collision because we are assuming rigid 2D mass
    Vector2 center    //the target center of the object relative to the global coordinates at the end of the time step
    Vector2 center0   //center of the object relative to the global coordinates at the time of (elapsed time before this time step + alpha0*time step)
                      //this is also the center of the object relative to the global coordinates at the previous frame (the frame displayed to the user currently)

    number angle = 0   //the target tilt of the object relative to the global coordinates at the end of the time step [Units: radians]
    number angle0 = 0   //tilt of the object relative to the global coordinates at the time of (elapsed time before this time step + alpha0*time step) [Units: radians]
                        //this is also the tilt of the object relative to the global coordinates at the previous frame (the frame displayed to the user currently)

    number alpha0 = 0   //the fraction of time in the current time step that you are in, so the time from the beginning of the simulation to when you reset "alpha0" would be approximately (elapsed time before this time step + alpha0*time step)
                        //range: [0,1]
    Math math


    /*
    normalize the angles in radius between -pi and pi
    */
    action Normalize    
        // take the floor of angle0 / (2 * pi)
        number temporary = angle0 / (2 * math:pi)    //normalize to 2pi (360 degrees)
        integer tempInt = cast(integer, temporary)
        if temporary < tempInt   //when temporary gets rounded up, we manually round it down
            tempInt = tempInt - 1
        end

        number d = 2.0 * math:pi * tempInt      //gets un-normalized by 2pi
        angle0 = angle0 - d
        angle = angle - d
    end


    /*
    setting a sweep using another sweep object
    */
    action Set(Sweep2D sweep)
        localCenter:Set(sweep:localCenter)
        center0:Set(sweep:center0)
        center:Set(sweep:center)
        angle0 = sweep:angle0
        angle = sweep:angle
        alpha0 = sweep:alpha0
    end


    /*
    tells you what the transformed object will look like some time between the time intervals of physics updates
    this will not change the orientation of the object yet
    Range for beta: [0,1]
    */
    action GetTransform(PhysicsPosition2D transform, number beta)
        transform:GetPosition():SetX((1.0 - beta) * center0:GetX() + beta * center:GetX())
        transform:GetPosition():SetY((1.0 - beta) * center0:GetY() + beta * center:GetY())
        number angle = (1.0 - beta) * angle0 + beta * me:angle
        transform:Set(transform:GetPosition(), angle)

        number sine = transform:GetSine()
        number cosine = transform:GetCosine()
        transform:GetPosition():SetX(transform:GetPosition():GetX() - cosine * localCenter:GetX() - sine * localCenter:GetY())
        transform:GetPosition():SetY(transform:GetPosition():GetY() - sine * localCenter:GetX() + cosine * localCenter:GetY())
    end

    /*
    this will actually set where the object is for sure, however, the object won't be drawn in the new position until the next frame update
    this is useful when the time step of your physics updates are larger than the frame rate

    center0, angle0 is what will be drawn to the screen

    alpha = a fraction of the time step that is > than alpha0
    */
    action Advance(number alpha)
        number beta = (alpha - alpha0) / (1.0 - alpha0)
        center0:SetX(center0:GetX() + beta * (center:GetX() - center0:GetX()))
        center0:SetY(center0:GetY() + beta * (center:GetY() - center0:GetY()))
        angle0 = angle0 + beta * (angle - angle0)
        alpha0 = alpha
    end


    /*
    This action returns the center of the object relative to the local coordinates of the object.
    */
    action GetLocalCenter returns Vector2
        return localCenter
    end


    /*
    This action sets the center of the object relative to the local coordinates of the object.
    */
    action SetLocalCenter(Vector2 center)
        localCenter = center
    end


    /*
    This action gets the target center of the object relative to the global coordinates.
    */
    action GetCenter returns Vector2
        return center
    end

    /*
    This action sets the target center of the object relative to the global coordinates.
    */
    action SetCenter(Vector2 center)
        me:center = center
    end

    /*
    This action gets the current center of the object relative to the global coordinates.
    */
    action GetCenter0 returns Vector2
        return center0
    end

    /*
    This action sets the current center of the object relative to the global coordinates.
    */
    action SetCenter0(Vector2 center)
        center0 = center
    end

    /*
    This action gets the target tilt of the 2D object relative to the global coordinates.
    */
    action GetAngle returns number
        return angle
    end

    /*
    This action sets the target tilt of the 2D object relative to the global coordinates.
    */
    action SetAngle(number angle)
        me:angle = angle
    end

    /*  
    This action gets the current tilt of the 2D object relative to the global coordinates.
    */
    action GetAngle0 returns number
        return angle0
    end

    /*
    This action sets the current tilt of the 2D obejct relative to the global coordinates.
    */
    action SetAngle0(number angle0)
        me:angle0 = angle0
    end

    /*
    This action gets the percentage of how much of the current time step your physics are evaluated at.
    */
    action GetAlpha0 returns number
        return alpha0
    end

    /*
    This action sets the percentage of how much of the current time step your physics are evaluated at.
    */
    action SetAlpha0(number alpha0)
        me:alpha0 = alpha0
    end
end